<!DOCTYPE html><html lang="zh-cn"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"><meta name="format-detection" content="telephone=no"><meta name="format-detection" content="email=no"><meta name="description"><meta name="keywords" content="Hexo, Gruntjs, Nodejs, Reactjs, Vuejs"><title>常见的知识总结 - Youuu</title><link rel="stylesheet" href="/css/main_style.min.css"><link rel="icon" href="/favicon.jpg"></head><body><input id="navi" type="checkbox"><ul class="main-navication"><li><a href="/"><span>Home</span></a></li><li><a href="https://github.com/youhonglian"><span>Github</span></a></li><li><a href="https://segmentfault.com/u/youzhiwan"><span>SegmentFault</span></a></li><li><a href="http://os3fgs3e7.bkt.clouddn.com/%E7%AE%80%E5%8E%86Full.pdf"><span>AboutMe</span></a></li></ul><div class="wrapper" id="wrap"><div class="post-header"><label class="navi-button light" for="navi">MENU</label><img class="background" src="http://callfiles.ueibo.com/hexo-theme-laughing/post_background.jpg"><div class="post-title"><h1 class="title">常见的知识总结</h1><ul class="meta"><li><i class="icon icon-author"></i>Youuu</li><li><i class="icon icon-clock"></i>71 Minutes</li><li><i class="icon icon-calendar"></i>July 29, 2017</li></ul></div></div><div class="article-content" style="max-width:800px"><h3 id="vue中的MVVM模式"><a href="#vue中的MVVM模式" class="headerlink" title="vue中的MVVM模式"></a>vue中的MVVM模式</h3><p>  MVVM即Model-View-ViewModel。<br>  Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。  ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。 DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化</p>
<p><br></p>
<h3 id="v-show指令，v-if的区别"><a href="#v-show指令，v-if的区别" class="headerlink" title="v-show指令，v-if的区别"></a>v-show指令，v-if的区别</h3><p>  条件渲染指令，与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style值</p>
<p><br></p>
<h3 id="指令keep-alive"><a href="#指令keep-alive" class="headerlink" title="指令keep-alive"></a>指令keep-alive</h3><p>  在vue-router写着keep-alive，keep-alive的含义： 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;component :is=<span class="string">'curremtView'</span> keep-alive&gt;&lt;/component&gt;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="指令v-el的使用"><a href="#指令v-el的使用" class="headerlink" title="指令v-el的使用"></a>指令v-el的使用</h3><p>  有时候我们想就像使用jquery那样去访问一个元素，此时就可以使用v-el指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。</p>
<p>  HTML不区分大小写，所以v-el:someEl将转换为全小写。可以用v-el:some-el然后设置this.$el.someEl。<br>示例<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;span v-el:msg&gt;hello&lt;/span&gt; </div><div class="line">&lt;span v-el:other-msg&gt;world&lt;/span&gt;  </div><div class="line">this.$els.msg.textContent // -&gt;"hello"  </div><div class="line">this.$els.otherMsg.textContent // -&gt;"world" </div><div class="line">this.$els.msg //-&gt;&lt;span&gt;hello&lt;/span&gt;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="Vue-js特点"><a href="#Vue-js特点" class="headerlink" title="Vue.js特点"></a>Vue.js特点</h3><p>  简洁：页面由HTML模板+Json数据+Vue实例组成<br>  数据驱动：自动计算属性和追踪依赖的模板表达式<br>  组件化：用可复用、解耦的组件来构造页面<br>  轻量：代码量小，不依赖其他库 快速：精确有效批量DOM更新<br>  模板友好：可通过npm，bower等多种方式安装，很容易融入</p>
<p><br></p>
<h3 id="JS中的常量（基本数据类型）和内置对象"><a href="#JS中的常量（基本数据类型）和内置对象" class="headerlink" title="JS中的常量（基本数据类型）和内置对象"></a>JS中的常量（基本数据类型）和内置对象</h3><p>  js中的基本数据类型：String 、number、null、boolean、undefined、object、symbol（ES6）</p>
<ul>
<li>1、 利用typeof运算符时其中只有null是异常的，typeof（null）=object，所以在判断变量类型是否为null时要注意。同时利用typeof时对于没有声明的变量是不会报错的，返回值为undefined。全局变量和函数变量在没有声明时使用是会报错的，但是在对象中使用没有定义的属性是不会报错同样返回的是undefined。Function变量是具有length属性的，其长度为传入的参数的个数。</li>
<li>2、 变量时弱类型的，即其本身是没有类型的，其值才是具有类型的。</li>
<li>3、 对于number类型，<br>（1）其中要注意的是NAN非数字的数字，用全局的函数isNAN判断时会有问题，即对于非数字类型的变量其也会返回true，所以在使用时可以用以下方式判断NAN：<br>①a!=a<br>②利用ES6中的Number.isNAN;<br>③typeof(a)==’number’&amp;&amp;isNAN(a)<br>（2）还有一个要注意的是+0，-0这两者在使用时是相等的但是在浏览器引擎上还是会有区别，区分二者可以利用：typeof(a)==typeof(b)&amp;&amp;1/a==1/b，+0、-0作为分母时会得到infinite和-infinite。在ES6中有Object.is方法可用于判断两个变量是否相等。可用于上述情况。但是前者的方法的执行效率更好。<br>（3）另外在JS中数字类型也是有最大和最小值的界定的安全范围的<br>（4）判断变量是否为整数的方法：<br>①Number.isInteger(a)，ES6中的方法<br>②typeof（a）==’number’&amp;&amp;a%1==0<br>③或者使用Math.ceil(a)==a等类似的方法</li>
<li>4、变量在复制和作为参数传递时会有引用传递和值传递之分：<br>（1）值传递即普通的变量类型<br>（2）引用传递，如对象和数组等幅值或者作为参数传递传递的是复制的引用会相会影响：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Var a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line">Var b=a;</div><div class="line">b.push(<span class="number">4</span>);<span class="comment">//a=[1,2,3,4];b=[1,2,3,4]</span></div><div class="line">但是当b重新赋值时：</div><div class="line">Var b=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]<span class="comment">//a=[1,2,3,4];b=[4,5,6]因为b的引用已经发生了改变不在是a数组的引用的复制。</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>JS中的内置函数: String、Number、Boolean、RegExp、Date、Error、Array、<br>Function、Object、symbol;类似于对象的构造函数</p>
<ul>
<li>1、这些内置函数构造的变量都是封装了基本类型值的对象如：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Var a=<span class="keyword">new</span> <span class="built_in">String</span>(‘abb’); <span class="comment">//typeof(a)=object</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>除了利用Function构造的变量通过typeof输出为function外其他均为object</p>
<ul>
<li>2、为了知道构造的变量的真实类型可以利用：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Object</span>.prototype.toString.call([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);<span class="comment">//”[object,array]”</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>后面的一个值即为传入参数的类型</p>
<ul>
<li>3、如果有常量形式（即利用基本数据类型）赋值给变量就不要用该方式来定义变量</li>
</ul>
<p><br></p>
<h3 id="js中判断一个对象的类型的种种方法"><a href="#js中判断一个对象的类型的种种方法" class="headerlink" title="js中判断一个对象的类型的种种方法"></a>js中判断一个对象的类型的种种方法</h3><h4 id="javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。"><a href="#javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。" class="headerlink" title="javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。"></a>javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。</h4><ul>
<li><p>typeof：typeof是一个一元运算符，返回结果是一个说明运算数类型的字符串。如：”number”，”string”，”boolean”，”object”，”function”，”undefined”（可用于判断变量是否存在）。 但 typeof 的能力有限，其对于Date、RegExp、Array类型返回的都是”object”。所以它只在区别对象和原始类型的时候才有用。要区一种对象类型和另一种对象类型，必须使用其他的方法。</p>
</li>
<li><p>instanceof 运算符：instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。instanceof方法可以判断变量是否是数组类型，但是只限同一全局环境之内，在一个页面有多个iframe的情况下，instanceof失效。</p>
</li>
<li><p>constructor 属性: JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。如给定一个求知的值 通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。</p>
</li>
<li><p>Object.prototype.toString.call()：该方法是目前为止发现的判断一个对象类型的最好的办法。</p>
</li>
</ul>
<p><br></p>
<h3 id="事件冒泡与事件捕获"><a href="#事件冒泡与事件捕获" class="headerlink" title="事件冒泡与事件捕获"></a>事件冒泡与事件捕获</h3><h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h4><p>微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象，由内向外。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素，由外向内。</p>
<p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.addEventListener(event, <span class="function"><span class="keyword">function</span>, <span class="title">useCapture</span>)</span></div></pre></td></tr></table></figure></p>
<p>第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。</p>
<p>对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。</p>
<h5 id="IE浏览器"><a href="#IE浏览器" class="headerlink" title="IE浏览器"></a>IE浏览器</h5><p>IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ele.attachEvent(<span class="string">"onclick"</span>, doSomething2);</div></pre></td></tr></table></figure></p>
<p>附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。</p>
<h4 id="事件的传播是可以阻止的："><a href="#事件的传播是可以阻止的：" class="headerlink" title="事件的传播是可以阻止的："></a>事件的传播是可以阻止的：</h4><p>• 在W3c中，使用stopPropagation（）方法<br>• 在IE下设置cancelBubble = true；<br>在捕获的过程中stopPropagation（）；后，后面的冒泡过程也不会发生了~<br>3.阻止事件的默认行为，例如click a 后的跳转~<br>• 在W3c中，使用preventDefault（）方法；<br>• 在IE下设置window.event.returnValue = false;</p>
<p><br></p>
<h3 id="浏览器的重绘与重排"><a href="#浏览器的重绘与重排" class="headerlink" title="浏览器的重绘与重排"></a>浏览器的重绘与重排</h3><p>1.重排的概念<br>浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM树和渲染树），DOM树表示页面结构，渲染树表示DOM节点如何显示。重排是DOM元素的几何属性变化，DOM树的结构变化，渲染树需要重新计算。</p>
<p>2.重绘的概念<br>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p>
<p>3.重绘和重排的关系<br>重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。</p>
<p>4.什么情况下会触发重排？<br>(1)页面渲染初始化时；（这个无法避免）<br>(2)浏览器窗口改变尺寸；<br>(3)元素尺寸改变时；<br>(4)元素位置改变时；<br>(5)元素内容改变时；<br>(6)添加或删除可见的DOM 元素时。</p>
<p>6.无论是外链CSS还是内联CSS都会阻塞DOM渲染（Rendering），然而DOM解析（Parsing）会正常进行。 这意味着在CSS下载并解析结束之前，它后面的HTML都不会显示。 这也是为什么我们把样式放在HTML内容之前，以防止被呈现内容发生样式跳动。 当然代价就是显示延迟，所以性能攸关的站点都会内联所有CSS。</p>
<p><br></p>
<h3 id="extend-obj-fn-extend-obj"><a href="#extend-obj-fn-extend-obj" class="headerlink" title="$.extend(obj);$.fn.extend(obj);"></a>$.extend(obj);$.fn.extend(obj);</h3><p>$拓展的方法是静态方法，可以使用$直接调用，其拓展的方式有两种，一般使用$.extend({});而$.fn拓展的方法是实例方法，必须由“对象”$(“”)来调用，其拓展的方式同样有两种，一般使用$.fn.extend({ })。</p>
<p>$.extend(obj);是为了扩展jquery本身，为类添加新的方法</p>
<p>$.fn.extend(obj);给JQUERY对象添加方法。</p>
<p>$.fn 中的fn其实是prototype，即$.fn=$.prototype;</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$.extend(&#123;</div><div class="line"><span class="attr">add</span>:<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a+b;</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">$.add(<span class="number">5</span>,<span class="number">8</span>) <span class="comment">//return 13</span></div></pre></td></tr></table></figure>
<p>这边的调用直接调用，前面不用任何对象。直接$.+方法名</p>
<p>$.fn.extend(obj)；对prototype进行扩展，为jquery类添加成员函数， jquery类的实例可以使用这个成员函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$.fn.extend(&#123;</div><div class="line"><span class="attr">clickwhile</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  $(<span class="keyword">this</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  alert($(<span class="keyword">this</span>).val()) </div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line">&#125;)</div><div class="line">$(<span class="string">'input'</span>).clickwhile();<span class="comment">//当点击输入框会弹出该对象的Value值</span></div></pre></td></tr></table></figure>
<p>注意调用时候前面是有对象的。即$(‘input’) 这么个东西。</p>
<p><br></p>
<h3 id="CSS-hack区分IE6-IE7-IE8-firefox"><a href="#CSS-hack区分IE6-IE7-IE8-firefox" class="headerlink" title="CSS hack区分IE6,IE7,IE8,firefox"></a>CSS hack区分IE6,IE7,IE8,firefox</h3><h4 id="CSS-hack使用原理"><a href="#CSS-hack使用原理" class="headerlink" title="CSS hack使用原理"></a>CSS hack使用原理</h4><p>简单来讲，CSS hack就是浏览器解析CSS时的漏洞，因此不同的浏览器就有不同的CSS hack写法。 CSS hack使用原则: 尽力避免使用CSS hack，并寻找其它的应对方法。事实上，使用IE的条件注释来区分IE各个版本，是非常不错的选择。</p>
<h4 id="CSS-hack使用后的弊端"><a href="#CSS-hack使用后的弊端" class="headerlink" title="CSS hack使用后的弊端"></a>CSS hack使用后的弊端</h4><p>CSS Hack除了能迅速区分浏览器版本，并可能获得大概一直的效果，但从长远看，CSS Hack会引起许多新的错误。</p>
<h4 id="CSS-hack的实现方式-针对IE6"><a href="#CSS-hack的实现方式-针对IE6" class="headerlink" title="CSS hack的实现方式(针对IE6)"></a>CSS hack的实现方式(针对IE6)</h4><ul>
<li>1.利用浏览器对相同代码的解析和支持的不同实现的hack<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#test&#123;</div><div class="line">   _width:80px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>在IE7及以上版本的浏览器中会被当作错误特性而舍弃，但是在IE6中可以被正常的解析。这时候，可以把_width当作hack，专门针对IE6来设置元素的宽度。</p>
<ul>
<li>2.利用IE对标准的支持缺陷写的CSS hack<br>!important只有IE7及以上版本的IE及其他浏览器支持，所以，可以用!important来针对IE6以外的浏览器写CSS代码；再如，head:first-child+bodyselector，:first-child不被IE6支持，所以可以用来针对IE6以外的浏览器编写CSS代码。IE6支持下划线，IE7和firefox均不支持下划线。</li>
</ul>
<blockquote>
<p>CSS hack区别IE6与Firefox：<br>background:orange;*background:blue;</p>
<p>CSS hack区别IE6与IE7：<br>background:green !important;background:blue;</p>
<p>CSS hack区别IE7与Firefox：<br>background:orange; *background:green;</p>
<p>CSS hack区别Firefox，IE7，IE6：<br>background:orange;<em>background:green !important;</em>background:blue;</p>
</blockquote>
<p><br></p>
<h3 id="如何避免FOUC？"><a href="#如何避免FOUC？" class="headerlink" title="如何避免FOUC？"></a>如何避免FOUC？</h3><p>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.原因大致为：</p>
<p>1，使用import方法导入样式表。<br>2，将样式表放在页面底部<br>3，有几个样式表，放在html结构的不同位置。其实原理很清楚：当样式表晚于 结构性html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂 的 花屏现象。解决方法：使用LINK标签将样式表放在文档HEAD中更多</p>
<p><br></p>
<h3 id="DOM-中-Property-和-Attribute-的区别"><a href="#DOM-中-Property-和-Attribute-的区别" class="headerlink" title="DOM 中 Property 和 Attribute 的区别"></a>DOM 中 Property 和 Attribute 的区别</h3><ul>
<li><p>Property：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型直接继承自Element并添加了一些属性，添加的这些属性分别对应于每个HTML元素都有下面的这5个标准特性: id,title,lang,dir,className。DOM节点是一个对象，因此，他可以和其他的JavaScript对象一样添加自定义的属性以及方法。property的值可以是任何的数据类型，对大小写敏感，自定义的property不会出现在html代码中，只存在js中。</p>
</li>
<li><p>Attribute：特性，区别于property，attribute只能是字符串，大小写不敏感，出现在innerHTML中，通过类数组attributes可以罗列所有的attribute。</p>
</li>
</ul>
<p><br></p>
<h3 id="document-onload和document-ready两个事件的区别"><a href="#document-onload和document-ready两个事件的区别" class="headerlink" title="document.onload和document.ready两个事件的区别"></a>document.onload和document.ready两个事件的区别</h3><ul>
<li>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）</li>
<li>onload，指示页面包含图片等文件在内的所有元素都加载完成。</li>
</ul>
<p><br></p>
<h3 id="JavaScript的同源策略"><a href="#JavaScript的同源策略" class="headerlink" title="JavaScript的同源策略"></a>JavaScript的同源策略</h3><p>在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>
<p><br></p>
<h3 id="给选择器一个上下文"><a href="#给选择器一个上下文" class="headerlink" title="给选择器一个上下文"></a>给选择器一个上下文</h3><p>jQuery选择器中有一个这样的选择器，它能指定上下文。jQuery(expression,context);通过它，能缩小选择器在DOM中搜索的范围，达到节省时间，提高效率。普通方式：$(‘.myDiv’)改进方式：$(‘.myDiv’,$(“#listItem”))。</p>
<p><br></p>
<h3 id="请解释JSONP的工作原理，以及它为什么不是真正的AJAX"><a href="#请解释JSONP的工作原理，以及它为什么不是真正的AJAX" class="headerlink" title="请解释JSONP的工作原理，以及它为什么不是真正的AJAX"></a>请解释JSONP的工作原理，以及它为什么不是真正的AJAX</h3><p>JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>
<p>AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！</p>
<p><br></p>
<h3 id="浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别"><a href="#浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别" class="headerlink" title="浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别"></a>浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别</h3><p>特性检测：为特定浏览器的特性进行测试，并仅当特性存在时即可应用特性。</p>
<p>User-Agent检测：最早的浏览器嗅探即用户代理检测，服务端（以及后来的客户端）根据UA字符串屏蔽某些特定的浏览器查看网站内容。</p>
<p>特性推断：尝试使用多个特性但仅验证了其中之一。根据一个特性的存在推断另一个特性是否存在。问题是，推断是假设并非事实，而且可能导致可维护性的问题</p>
<p><br></p>
<h3 id="JavaScript宿主对象和原生对象的区别"><a href="#JavaScript宿主对象和原生对象的区别" class="headerlink" title="JavaScript宿主对象和原生对象的区别"></a>JavaScript宿主对象和原生对象的区别</h3><h4 id="原生对象"><a href="#原生对象" class="headerlink" title="原生对象"></a>原生对象</h4><p>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>
<p>“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。</p>
<p>由此可以看出，简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。</p>
<h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。</p>
<p>同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。如此就可以理解了。内置对象是本地对象的一种。</p>
<h4 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h4><p>何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。</p>
<p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的BOM和DOM都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。</p>
<p><br></p>
<h3 id="AMD、CMD和CommonJS规范"><a href="#AMD、CMD和CommonJS规范" class="headerlink" title="AMD、CMD和CommonJS规范"></a>AMD、CMD和CommonJS规范</h3><h4 id="CommonJS规范"><a href="#CommonJS规范" class="headerlink" title="CommonJS规范"></a>CommonJS规范</h4><p> CommonJS是在浏览器环境之外构建JavaScript生态系统为目标产生的项目，比如服务器和桌面环境中。CommonJS规范是为了解决JavaScript的作用域问题而定义的模块形式，<br>可以使每个模块在它自身的命名空间中执行。该规范的主要内容是：模块必须通过  module.exports导出对外的变量或接口，通过require()来导入其他模块的输出到当前模块。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleA.js  </span></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params"> value </span>)</span>&#123;  </div><div class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleB.js  </span></div><div class="line"><span class="keyword">var</span> multiplyBy2 = <span class="built_in">require</span>(<span class="string">'./moduleA'</span>);  </div><div class="line"><span class="keyword">var</span> result = multiplyBy2(<span class="number">4</span>);</div></pre></td></tr></table></figure>
<p>CommonJS是同步加载模块，但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过id进行索引，这样就可以浏览器进行解析了</p>
<p>服务器端的Node.js遵循CommonJS规范。核心思想是允许模块通过require 方法来同步加载所要依赖的其他模块，然后通过 exports或module.exports来导出需要暴露的接口。</p>
<p>优点：<br>服务器端便于重用<br>NPM中已经将近20w个模块包<br>简单并容易使用<br>缺点：<br>同步的模块方式不适合不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的<br>不能非阻塞的并行加载多个模块</p>
<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>AMD规范其实只有一个主要接口 define(id,dependencies,factory)，它要在声明模块的时候指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">define(<span class="string">"module"</span>, [<span class="string">"dep1"</span>, <span class="string">"dep2"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">d1, d2</span>) </span>&#123;  </div><div class="line">  <span class="keyword">return</span> someExportedValue;  </div><div class="line">&#125;);  </div><div class="line"><span class="built_in">require</span>([<span class="string">"module"</span>, <span class="string">"../file"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">module, file</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;);  \</div></pre></td></tr></table></figure>
<p>优点：<br>适合在浏览器环境异步加载<br>并行加载多个模块<br>缺点：<br>提高开发成本，代码阅读和书写比较困难<br>不符合通用的模块思维方式，是一种妥协的实现</p>
<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD规范和AMD相似，尽量保持简单，并且与CommonJS和NodeJS的Modules规范保持了很大的兼容性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;  </div><div class="line">  <span class="keyword">var</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);  </div><div class="line">  <span class="keyword">var</span> Spinning = <span class="built_in">require</span>(<span class="string">'./spinning'</span>);  </div><div class="line">  exports.doSomething = ...  </div><div class="line">  module.exports = ...  </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>优点：<br>依赖就近，延迟执行<br>很容易在node中运行<br>缺点：<br>依赖SPM打包，模块的加载逻辑偏重</p>
<p><br></p>
<h3 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h3><p>JavaScript事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个父级元素上，这样就避免了把事件处理器添加到多个子级元素上。当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。事件代理用到了两个在JavaSciprt事件中常被忽略的特性：事件冒泡以及目标元素。</p>
<p><br></p>
<h3 id="如果设计中使用了非标准的字体，如何去实现"><a href="#如果设计中使用了非标准的字体，如何去实现" class="headerlink" title="如果设计中使用了非标准的字体，如何去实现"></a>如果设计中使用了非标准的字体，如何去实现</h3><p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。<br>方法：</p>
<ul>
<li>用图片代替</li>
<li>web fonts在线字库，如Google Webfonts，Typekit等等；<a href="http://www.chinaz.com/free/2012/0815/269267.shtml；" target="_blank" rel="external">http://www.chinaz.com/free/2012/0815/269267.shtml；</a></li>
<li>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)</li>
</ul>
<p><br></p>
<h3 id="使用CSS预处理器的优缺点"><a href="#使用CSS预处理器的优缺点" class="headerlink" title="使用CSS预处理器的优缺点"></a>使用CSS预处理器的优缺点</h3><p>LESS&amp;SassLESS是受Sass启发而开发的工具，它列出了如下开发的理由：</p>
<p>“为什么要开发一个Sass的替代品呢？原因很简单：首先是语法。Sass的一个关键特性是缩进式的语法，这种语法可以产生柱式外观的代码。但是你需要花费时间学习一门新的语法以及重新构建你现在的样式表。LESS给CSS带来了很多特性，使得LESS能够和CSS无缝地紧密结合在一起。因此，你可以平滑地由CSS迁移到LESS，如果你只是对使用变量或者操作感兴趣的话，你不需要学习一整门全新的语言。”</p>
<p>Stylus相对前两者较新，可以看官方文档介绍的功能。</p>
<p>1.来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：<a href="http://learnboost.github.io/stylus/docs/js.html；" target="_blank" rel="external">http://learnboost.github.io/stylus/docs/js.html；</a><br>2.支持Ruby之类等等框架；<br>3.更多更强大的支持和功能总结：Sass看起来在提供的特性上占有优势，但是LESS能够让开发者平滑地从现存CSS文件过渡到LESS，而不需要像Sass那样需要将CSS文件转换成Sass格式。Stylus功能上更为强壮，和js联系更加紧密。</p>
<p><br></p>
<h3 id="cookies，sessionStorage和localStorage的区别"><a href="#cookies，sessionStorage和localStorage的区别" class="headerlink" title="cookies，sessionStorage和localStorage的区别"></a>cookies，sessionStorage和localStorage的区别</h3><p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>
<p>存储大小：<br>  cookie数据大小不能超过4k。<br>  sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>
<p>有期时间：<br>  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>  sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>
<p><br></p>
<h3 id="浏览器标准模式和怪异模式之间的区别"><a href="#浏览器标准模式和怪异模式之间的区别" class="headerlink" title="浏览器标准模式和怪异模式之间的区别"></a>浏览器标准模式和怪异模式之间的区别</h3><p>W3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。这样浏览器渲染上就产生了Quircks mode和Standars mode，两种渲染方法共存在一个浏览器上。IE盒子模型和标准W3C盒子模型：ie的width包括：padding\border。标准的width不包括：padding\border</p>
<p> 在js中如何判断当前浏览器正在以何种方式解析？<br>         document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。</p>
<p><br></p>
<h3 id="doctype（文档类型）的作用，有多少种文档类型"><a href="#doctype（文档类型）的作用，有多少种文档类型" class="headerlink" title="doctype（文档类型）的作用，有多少种文档类型"></a>doctype（文档类型）的作用，有多少种文档类型</h3><p>此标签可告知浏览器文档使用哪种HTML或XHTML规范。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。</p>
<p>HTML 4.01规定了三种文档类型：Strict、Transitional以及Frameset。</p>
<p>XHTML 1.0规定了三种XML文档类型：Strict、Transitional以及Frameset。</p>
<p>Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>
<p><br></p>
<h3 id="对语义化的理解"><a href="#对语义化的理解" class="headerlink" title="对语义化的理解"></a>对语义化的理解</h3><p>1：去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如 h1 是粗体，字体大小2em，加粗；strong 是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</p>
<p>2.屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页。</p>
<p>3.PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）。</p>
<p>4.有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。</p>
<p>5.便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>
<p><br></p>
<h3 id="渐进增强和优雅降级"><a href="#渐进增强和优雅降级" class="headerlink" title="渐进增强和优雅降级"></a>渐进增强和优雅降级</h3><p>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p>
<p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>
<p><br></p>
<h3 id="浏览器同一时间可以从一个域名下载多少资源"><a href="#浏览器同一时间可以从一个域名下载多少资源" class="headerlink" title="浏览器同一时间可以从一个域名下载多少资源"></a>浏览器同一时间可以从一个域名下载多少资源</h3><p>这个专业的说法叫“浏览器并发请求数”。意即，同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻止。所有浏览器的并发数目一般限制在10以内。</p>
<p> <img src="https://pic4.zhimg.com/ea606d016e8ab77db9d8a8dfa5243a1b_r.jpg" width="200" height="200"></p>
<p><br></p>
<h3 id="Canvas-与-SVG"><a href="#Canvas-与-SVG" class="headerlink" title="Canvas 与 SVG"></a>Canvas 与 SVG</h3><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><ul>
<li>依赖分辨率</li>
<li>不支持事件处理器</li>
<li>弱的文本渲染能力</li>
<li>能够以 .png 或 .jpg 格式保存结果图像</li>
<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘<h3 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h3></li>
<li>不依赖分辨率</li>
<li>支持事件处理器</li>
<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
<li>不适合游戏应用</li>
</ul>
<p><br></p>
<h3 id="页面导入样式时，使用link和-import有什么区别"><a href="#页面导入样式时，使用link和-import有什么区别" class="headerlink" title="页面导入样式时，使用link和@import有什么区别"></a>页面导入样式时，使用link和@import有什么区别</h3><p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</p>
<p>（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>
<p>（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问</p>
<p><br></p>
<h3 id="介绍一下你对浏览器内核的理解"><a href="#介绍一下你对浏览器内核的理解" class="headerlink" title="介绍一下你对浏览器内核的理解"></a>介绍一下你对浏览器内核的理解</h3><p>  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>
<p>  JS引擎则：解析和执行javascript来实现网页的动态效果。</p>
<p>  最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<p><br></p>
<h3 id="常见的浏览器内核有哪些？"><a href="#常见的浏览器内核有哪些？" class="headerlink" title="常见的浏览器内核有哪些？"></a>常见的浏览器内核有哪些？</h3><p>  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br>  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p>
<p><br></p>
<h3 id="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和"><a href="#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和" class="headerlink" title="html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和</h3><p>HTML5？</p>
<ul>
<li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>
<pre><code>绘画 canvas;
用于媒介回放的 video 和 audio 元素;
本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;
sessionStorage 的数据在浏览器关闭后自动删除;
语意化更好的内容元素，比如 article、footer、header、nav、section;
表单控件，calendar、date、time、email、url、search;
新的技术webworker, websocket, Geolocation;
</code></pre><p>   移除的元素：</p>
<pre><code>纯表现的元素：basefont，big，center，font, s，strike，tt，u;
对可用性产生负面影响的元素：frame，frameset，noframes；
</code></pre><ul>
<li><p>支持HTML5新标签：<br>   IE8/IE7/IE6支持通过document.createElement方法产生的标签，</p>
<pre><code>可以利用这一特性让这些浏览器支持HTML5新标签，
浏览器支持新标签后，还需要添加标签默认的样式。
</code></pre><p>   当然也可以直接使用成熟的框架、比如html5shim;</p>
</li>
<li><p>如何区分HTML5： DOCTYPE声明\新增的结构元素\功能元素</p>
</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="HTML5的离线储存怎么使用"><a href="#HTML5的离线储存怎么使用" class="headerlink" title="HTML5的离线储存怎么使用"></a>HTML5的离线储存怎么使用</h3><p>  在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>
<p><br></p>
<h3 id="浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？"><a href="#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？" class="headerlink" title="浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h3><p>  在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>  离线的情况下，浏览器就直接使用离线存储的资源。</p>
<p><br></p>
<h3 id="iframe有那些缺点？"><a href="#iframe有那些缺点？" class="headerlink" title="iframe有那些缺点？"></a>iframe有那些缺点？</h3><ul>
<li>iframe会阻塞主页面的Onload事件；</li>
<li><p>搜索引擎的检索程序无法解读这种页面，不利于SEO;</p>
</li>
<li><p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p>
<p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript<br>动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>
</li>
</ul>
<p><br></p>
<h3 id="Label的作用是什么？是怎么用的"><a href="#Label的作用是什么？是怎么用的" class="headerlink" title="Label的作用是什么？是怎么用的?"></a>Label的作用是什么？是怎么用的?</h3><p> label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;label <span class="keyword">for</span>=<span class="string">"Name"</span>&gt;<span class="built_in">Number</span>:&lt;/label&gt;</div><div class="line">&lt;input type=“text“name=<span class="string">"Name"</span> id=<span class="string">"Name"</span>/&gt;</div><div class="line"></div><div class="line">&lt;label&gt;Date:&lt;input type="text" name="B"/&gt;&lt;/label&gt;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="HTML5的form如何关闭自动完成功能？"><a href="#HTML5的form如何关闭自动完成功能？" class="headerlink" title="HTML5的form如何关闭自动完成功能？"></a>HTML5的form如何关闭自动完成功能？</h3><p>  给不想要提示的 form 或某个 input 设置为 autocomplete=off。</p>
<p><br></p>
<h3 id="如何实现浏览器内多个标签页之间的通信"><a href="#如何实现浏览器内多个标签页之间的通信" class="headerlink" title="如何实现浏览器内多个标签页之间的通信?"></a>如何实现浏览器内多个标签页之间的通信?</h3><p>  WebSocket、SharedWorker；<br>  也可以调用localstorge、cookies等本地存储方式；</p>
<p>  localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，<br>  我们通过监听事件，控制它的值来进行页面信息通信；<br>  注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</p>
<p><br></p>
<h3 id="webSocket如何兼容低浏览器？"><a href="#webSocket如何兼容低浏览器？" class="headerlink" title="webSocket如何兼容低浏览器？"></a>webSocket如何兼容低浏览器？</h3><ul>
<li>Adobe Flash Socket 、</li>
<li>ActiveX HTMLFile (IE) 、</li>
<li>基于 multipart 编码发送 XHR 、</li>
<li>基于长轮询的 XHR</li>
</ul>
<p><br></p>
<h3 id="页面可见性（Page-Visibility-API）-可以有哪些用途？"><a href="#页面可见性（Page-Visibility-API）-可以有哪些用途？" class="headerlink" title="页面可见性（Page Visibility API） 可以有哪些用途？"></a>页面可见性（Page Visibility API） 可以有哪些用途？</h3><p>  通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;<br>  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</p>
<p><br></p>
<h3 id="实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"><a href="#实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。" class="headerlink" title="实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。"></a>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div style=<span class="string">"height:1px;overflow:hidden;background:red"</span>&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"><a href="#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？" class="headerlink" title="介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3><p>  （1）有两种， IE 盒子模型、W3C 盒子模型；<br>  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>  （3）区  别： IE的content部分把 border 和 padding计算了进去;</p>
<p><br></p>
<h3 id="CSS优先级算法如何计算？"><a href="#CSS优先级算法如何计算？" class="headerlink" title="CSS优先级算法如何计算？"></a>CSS优先级算法如何计算？</h3><ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li><p>载入样式以最后载入的定位为准;</p>
<p>优先级为:<br>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。<br>!important &gt;  id &gt; class &gt; tag<br>important 比 内联优先级高</p>
</li>
</ul>
<p><br></p>
<h3 id="CSS3新增伪类有那些？"><a href="#CSS3新增伪类有那些？" class="headerlink" title="CSS3新增伪类有那些？"></a>CSS3新增伪类有那些？</h3><pre><code>举例：
p:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。
p:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。
p:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。

:after            在元素之前添加内容,也可以用来做清除浮动。
:before            在元素之后添加内容
 :enabled          
:disabled         控制表单控件的禁用状态。
:checked        单选框或复选框被选中。
</code></pre><p><br></p>
<h3 id="CSS3有哪些新特性？"><a href="#CSS3有哪些新特性？" class="headerlink" title="CSS3有哪些新特性？"></a>CSS3有哪些新特性？</h3><p> 新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）<br>      圆角            （border-radius:8px）<br>    多列布局        （multi-column layout）<br>    阴影和反射    （Shadow\Reflect）<br>    文字特效        （text-shadow、）<br>    文字渲染        （Text-decoration）<br>    线性渐变        （gradient）<br>    旋转             （transform）<br>    缩放,定位,倾斜,动画,多背景<br>    例如:transform:\scale(0.85,0.90)\ translate(0px,-30px)\ skew(-9deg,0deg)\Animation:</p>
<p><br></p>
<h3 id="请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景"><a href="#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景" class="headerlink" title="请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景"></a>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景</h3><p>  一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。<br>   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。<br>   采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。<br>   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。<br>   在布局上有了比以前更加灵活的空间。</p>
<p><br></p>
<h3 id="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"><a href="#li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？" class="headerlink" title="li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？"></a>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p> 行框的排列会受到中间空白（回车\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p>
<p><br></p>
<h3 id="对BFC规范-块级格式化上下文：block-formatting-context-的理解？"><a href="#对BFC规范-块级格式化上下文：block-formatting-context-的理解？" class="headerlink" title="对BFC规范(块级格式化上下文：block formatting context)的理解？"></a>对BFC规范(块级格式化上下文：block formatting context)的理解？</h3><p>（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）<br>   一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。<br>   不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</p>
<p><br></p>
<h3 id="before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用"><a href="#before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用" class="headerlink" title="::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用"></a>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用</h3><p>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）<br>  双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，<br>  比如:first-line、:first-letter、:before、:after等，<br>  而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</p>
<p>  想让插入的内容出现在其它内容前，使用::before，否者，使用::after；<br>  在代码顺序上，::after生成的内容也比::before生成的内容靠后。<br>  如果按堆栈视角，::after生成的内容会在::before生成的内容之上</p>
<p><br></p>
<h3 id="让页面里的字体变清晰，变细用CSS怎么做？"><a href="#让页面里的字体变清晰，变细用CSS怎么做？" class="headerlink" title="让页面里的字体变清晰，变细用CSS怎么做？"></a>让页面里的字体变清晰，变细用CSS怎么做？</h3><p>  -webkit-font-smoothing: antialiased;</p>
<p><br></p>
<h3 id="position-fixed-在android下无效怎么处理？"><a href="#position-fixed-在android下无效怎么处理？" class="headerlink" title="position:fixed;在android下无效怎么处理？"></a>position:fixed;在android下无效怎么处理？</h3><p>  fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，<br>  原来的网页还好好的在那，fixed的内容也没有变过位置，<br>  所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。<br>  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"></p>
<p><br></p>
<h3 id="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"><a href="#如果需要手动写动画，你认为最小时间间隔是多久，为什么？" class="headerlink" title="如果需要手动写动画，你认为最小时间间隔是多久，为什么？"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</p>
<p>display:inline-block 什么时候会显示间隙？</p>
<p>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p>
<p><br></p>
<h3 id="什么是CSS-预处理器-后处理器？"><a href="#什么是CSS-预处理器-后处理器？" class="headerlink" title="什么是CSS 预处理器 / 后处理器？"></a>什么是CSS 预处理器 / 后处理器？</h3><ul>
<li><p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，<br> 还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p>
<ul>
<li>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的<br>是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</li>
</ul>
</li>
</ul>
<p><br></p>
<h3 id="JavaScript原型，原型链-有什么特点？"><a href="#JavaScript原型，原型链-有什么特点？" class="headerlink" title="JavaScript原型，原型链 ? 有什么特点？"></a>JavaScript原型，原型链 ? 有什么特点？</h3><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br> 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br> 于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br> 关系：instance.constructor.prototype = instance.<strong>proto</strong></p>
<p> 特点：<br> JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>
<p><br></p>
<h3 id="如何将字符串转化为数字，例如’12-3b’"><a href="#如何将字符串转化为数字，例如’12-3b’" class="headerlink" title="如何将字符串转化为数字，例如’12.3b’?"></a>如何将字符串转化为数字，例如’12.3b’?</h3><ul>
<li>parseFloat(‘12.3b’);</li>
<li>正则表达式，’12.3b’.match(/(\d)+(.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</li>
</ul>
<p><br></p>
<h3 id="如何实现数组的随机排序？"><a href="#如何实现数组的随机排序？" class="headerlink" title="如何实现数组的随机排序？"></a>如何实现数组的随机排序？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>];</div><div class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</div><div class="line">&#125;)</div><div class="line"><span class="built_in">console</span>.log(arr);</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="Javascript如何实现继承？"><a href="#Javascript如何实现继承？" class="headerlink" title="Javascript如何实现继承？"></a>Javascript如何实现继承？</h3><p>1、构造继承<br> 2、原型继承<br> 3、实例继承<br> 4、拷贝继承</p>
<p> 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.name = <span class="string">'wang'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">this</span>.age = <span class="number">28</span>;</div><div class="line">&#125;</div><div class="line">Child.prototype = <span class="keyword">new</span> Parent();<span class="comment">//继承了Parent，通过原型</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> demo = <span class="keyword">new</span> Child();</div><div class="line">alert(demo.age);</div><div class="line">alert(demo.name);<span class="comment">//得到被继承的属性</span></div></pre></td></tr></table></figure></p>
<p><br></p>
<h3 id="javascript创建对象的几种方式？"><a href="#javascript创建对象的几种方式？" class="headerlink" title="javascript创建对象的几种方式？"></a>javascript创建对象的几种方式？</h3><pre><code>1、对象字面量的方式
2、用function来模拟无参的构造函数
3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）
4 、用原型方式来创建
</code></pre><p><br></p>
<h3 id="Javascript作用链域"><a href="#Javascript作用链域" class="headerlink" title="Javascript作用链域?"></a>Javascript作用链域?</h3><p> 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。<br> 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，<br> 直至全局函数，这种组织形式就是作用域链。</p>
<p><br></p>
<h3 id="eval是做什么的？"><a href="#eval是做什么的？" class="headerlink" title="eval是做什么的？"></a>eval是做什么的？</h3><p>它的功能是把对应的字符串解析成JS代码并运行；<br> 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。<br> 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’);</p>
<p>什么是window对象? 什么是document对象?</p>
<p> window对象是指浏览器打开的窗口。<br> document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</p>
<p><br></p>
<h3 id="“1”-“2”-“3”-map-parseInt-答案是多少？"><a href="#“1”-“2”-“3”-map-parseInt-答案是多少？" class="headerlink" title="[“1”, “2”, “3”].map(parseInt) 答案是多少？"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><p> parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，<br> 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;<br> 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。</p>
<p> function parseInt(str, radix) {<br>     return str+’-‘+radix;<br> };<br> var a=[“1”, “2”, “3”];<br> a.map(parseInt);  // [“1-0”, “2-1”, “3-2”] 不能大于radix</p>
<p> 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN<br> 所以[“1”, “2”, “3”].map(parseInt) 答案也就是：[1, NaN, NaN]</p>
<p><br></p>
<h3 id="什么是闭包（closure），为什么要用它？"><a href="#什么是闭包（closure），为什么要用它？" class="headerlink" title="什么是闭包（closure），为什么要用它？"></a>什么是闭包（closure），为什么要用它？</h3><p>  闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</p>
<p> 闭包的特性：</p>
<p> 1.函数内再嵌套函数<br> 2.内部函数可以引用外层的参数和变量<br> 3.参数和变量不会被垃圾回收机制回收</p>
<p><br></p>
<h3 id="new操作符具体干了什么呢"><a href="#new操作符具体干了什么呢" class="headerlink" title="new操作符具体干了什么呢?"></a>new操作符具体干了什么呢?</h3><pre><code>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。
2、属性和方法被加入到 this 引用的对象中。
3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。
</code></pre><p><br></p>
<h3 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h3><p> defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p>
<p><br></p>
<h3 id="Ajax-是什么-如何创建一个Ajax？"><a href="#Ajax-是什么-如何创建一个Ajax？" class="headerlink" title="Ajax 是什么? 如何创建一个Ajax？"></a>Ajax 是什么? 如何创建一个Ajax？</h3><p>ajax的全称：Asynchronous Javascript And XML。<br> 异步传输+js+xml。<br> 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</p>
<p> (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象<br> (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br> (3)设置响应HTTP请求状态变化的函数<br> (4)发送HTTP请求<br> (5)获取异步调用返回的数据<br> (6)使用JavaScript和DOM实现局部刷新</p>
<p><br></p>
<h3 id="如何判断当前脚本运行在浏览器还是node环境中？"><a href="#如何判断当前脚本运行在浏览器还是node环境中？" class="headerlink" title="如何判断当前脚本运行在浏览器还是node环境中？"></a>如何判断当前脚本运行在浏览器还是node环境中？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span> === <span class="built_in">window</span> ? <span class="string">'browser'</span> : <span class="string">'node'</span>;</div></pre></td></tr></table></figure>
<p>  通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</p>
<p><br></p>
<h3 id="那些操作会造成内存泄漏？"><a href="#那些操作会造成内存泄漏？" class="headerlink" title="那些操作会造成内存泄漏？"></a>那些操作会造成内存泄漏？</h3><p> 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br> 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>
<p> setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br> 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>
<p><br></p>
<h3 id="检测浏览器版本版本有哪些方式？"><a href="#检测浏览器版本版本有哪些方式？" class="headerlink" title="检测浏览器版本版本有哪些方式？"></a>检测浏览器版本版本有哪些方式？</h3><p>  功能检测、userAgent特征检测</p>
<p>  比如：navigator.userAgent</p>
<p><br></p>
<h3 id="Object-is-与原来的比较操作符“-”、“-”的区别？"><a href="#Object-is-与原来的比较操作符“-”、“-”的区别？" class="headerlink" title="Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？"></a>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</h3><p> 两等号判等，会在比较时进行类型转换；<br>  三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；</p>
<p>  Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，<br>  但 Object.is(NaN, NaN) 会返回 true.</p>
<p>   Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。<br>  前端框架相关</p>
<p><br></p>
<h3 id="是否了解公钥加密和私钥加密。"><a href="#是否了解公钥加密和私钥加密。" class="headerlink" title="是否了解公钥加密和私钥加密。"></a>是否了解公钥加密和私钥加密。</h3><p>  一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;<br>  HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</p>
<p><br></p>
<h3 id="对Node的优点和缺点提出了自己的看法？"><a href="#对Node的优点和缺点提出了自己的看法？" class="headerlink" title="对Node的优点和缺点提出了自己的看法？"></a>对Node的优点和缺点提出了自己的看法？</h3><pre><code>*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，
  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，
  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，
  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。
</code></pre><p><br></p>
<h3 id="你有用过哪些前端性能优化的方法？"><a href="#你有用过哪些前端性能优化的方法？" class="headerlink" title="你有用过哪些前端性能优化的方法？"></a>你有用过哪些前端性能优化的方法？</h3><pre><code>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。

（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数

（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。

（4） 当需要设置的样式很多时设置className而不是直接操作style。

（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。

（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。

（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。

（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。
对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。
</code></pre><p><br></p>
<h3 id="http状态码有那些？分别代表是什么意思？"><a href="#http状态码有那些？分别代表是什么意思？" class="headerlink" title="http状态码有那些？分别代表是什么意思？"></a>http状态码有那些？分别代表是什么意思？</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line">  [</div><div class="line">      <span class="number">100</span>  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</div><div class="line">      <span class="number">200</span>  OK         正常返回信息</div><div class="line">      <span class="number">201</span>  Created      请求成功并且服务器创建了新的资源</div><div class="line">      <span class="number">202</span>  Accepted     服务器已接受请求，但尚未处理</div><div class="line">      <span class="number">301</span>  Moved Permanently  请求的网页已永久移动到新位置。</div><div class="line">      <span class="number">302</span> Found          临时性重定向。</div><div class="line">      <span class="number">303</span> See Other      临时性重定向，且总是使用 GET 请求新的 URI。</div><div class="line">      <span class="number">304</span>  Not Modified 自从上次请求后，请求的网页未修改过。</div><div class="line"></div><div class="line">      <span class="number">400</span> Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</div><div class="line">      <span class="number">401</span> Unauthorized 请求未授权。</div><div class="line">      <span class="number">403</span> Forbidden      禁止访问。</div><div class="line">      <span class="number">404</span> Not Found      找不到如何与 URI 相匹配的资源。</div><div class="line"></div><div class="line">      <span class="number">500</span> Internal Server <span class="built_in">Error</span>  最常见的服务器端错误。</div><div class="line">      <span class="number">503</span> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</div><div class="line">  ]</div><div class="line"></div><div class="line">完整版</div><div class="line"><span class="number">1</span>**(信息类)：表示接收到请求并且继续处理</div><div class="line">  <span class="number">100</span>——客户必须继续发出请求</div><div class="line">  <span class="number">101</span>——客户要求服务器根据请求转换HTTP协议版本</div><div class="line"></div><div class="line"><span class="number">2</span>**(响应成功)：表示动作被成功接收、理解和接受</div><div class="line">  <span class="number">200</span>——表明该请求被成功地完成，所请求的资源发送回客户端</div><div class="line">  <span class="number">201</span>——提示知道新文件的URL</div><div class="line">  <span class="number">202</span>——接受和处理、但处理未完成</div><div class="line">  <span class="number">203</span>——返回信息不确定或不完整</div><div class="line">  <span class="number">204</span>——请求收到，但返回信息为空</div><div class="line">  <span class="number">205</span>——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</div><div class="line">  <span class="number">206</span>——服务器已经完成了部分用户的GET请求</div><div class="line"></div><div class="line"><span class="number">3</span>**(重定向类)：为了完成指定的动作，必须接受进一步处理</div><div class="line">  <span class="number">300</span>——请求的资源可在多处得到</div><div class="line">  <span class="number">301</span>——本网页被永久性转移到另一个URL</div><div class="line">  <span class="number">302</span>——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</div><div class="line">  <span class="number">303</span>——建议客户访问其他URL或访问方式</div><div class="line">  <span class="number">304</span>——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</div><div class="line">  <span class="number">305</span>——请求的资源必须从服务器指定的地址得到</div><div class="line">  <span class="number">306</span>——前一版本HTTP中使用的代码，现行版本中不再使用</div><div class="line">  <span class="number">307</span>——申明请求的资源临时性删除</div><div class="line"></div><div class="line"><span class="number">4</span>**(客户端错误类)：请求包含错误语法或不能正确执行</div><div class="line">  <span class="number">400</span>——客户端请求有语法错误，不能被服务器所理解</div><div class="line">  <span class="number">401</span>——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</div><div class="line">  HTTP <span class="number">401.1</span> - 未授权：登录失败</div><div class="line">  　　HTTP <span class="number">401.2</span> - 未授权：服务器配置问题导致登录失败</div><div class="line">  　　HTTP <span class="number">401.3</span> - ACL 禁止访问资源</div><div class="line">  　　HTTP <span class="number">401.4</span> - 未授权：授权被筛选器拒绝</div><div class="line">  HTTP <span class="number">401.5</span> - 未授权：ISAPI 或 CGI 授权失败</div><div class="line">  <span class="number">402</span>——保留有效ChargeTo头响应</div><div class="line">  <span class="number">403</span>——禁止访问，服务器收到请求，但是拒绝提供服务</div><div class="line">  HTTP <span class="number">403.1</span> 禁止访问：禁止可执行访问</div><div class="line">  　　HTTP <span class="number">403.2</span> - 禁止访问：禁止读访问</div><div class="line">  　　HTTP <span class="number">403.3</span> - 禁止访问：禁止写访问</div><div class="line">  　　HTTP <span class="number">403.4</span> - 禁止访问：要求 SSL</div><div class="line">  　　HTTP <span class="number">403.5</span> - 禁止访问：要求 SSL <span class="number">128</span></div><div class="line">  　　HTTP <span class="number">403.6</span> - 禁止访问：IP 地址被拒绝</div><div class="line">  　　HTTP <span class="number">403.7</span> - 禁止访问：要求客户证书</div><div class="line">  　　HTTP <span class="number">403.8</span> - 禁止访问：禁止站点访问</div><div class="line">  　　HTTP <span class="number">403.9</span> - 禁止访问：连接的用户过多</div><div class="line">  　　HTTP <span class="number">403.10</span> - 禁止访问：配置无效</div><div class="line">  　　HTTP <span class="number">403.11</span> - 禁止访问：密码更改</div><div class="line">  　　HTTP <span class="number">403.12</span> - 禁止访问：映射器拒绝访问</div><div class="line">  　　HTTP <span class="number">403.13</span> - 禁止访问：客户证书已被吊销</div><div class="line">  　　HTTP <span class="number">403.15</span> - 禁止访问：客户访问许可过多</div><div class="line">  　　HTTP <span class="number">403.16</span> - 禁止访问：客户证书不可信或者无效</div><div class="line">  HTTP <span class="number">403.17</span> - 禁止访问：客户证书已经到期或者尚未生效</div><div class="line">  <span class="number">404</span>——一个<span class="number">404</span>错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</div><div class="line">  <span class="number">405</span>——用户在Request-Line字段定义的方法不允许</div><div class="line">  <span class="number">406</span>——根据用户发送的Accept拖，请求资源不可访问</div><div class="line">  <span class="number">407</span>——类似<span class="number">401</span>，用户必须首先在代理服务器上得到授权</div><div class="line">  <span class="number">408</span>——客户端没有在用户指定的饿时间内完成请求</div><div class="line">  <span class="number">409</span>——对当前资源状态，请求不能完成</div><div class="line">  <span class="number">410</span>——服务器上不再有此资源且无进一步的参考地址</div><div class="line">  <span class="number">411</span>——服务器拒绝用户定义的Content-Length属性请求</div><div class="line">  <span class="number">412</span>——一个或多个请求头字段在当前请求中错误</div><div class="line">  <span class="number">413</span>——请求的资源大于服务器允许的大小</div><div class="line">  <span class="number">414</span>——请求的资源URL长于服务器允许的长度</div><div class="line">  <span class="number">415</span>——请求资源不支持请求项目格式</div><div class="line">  <span class="number">416</span>——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</div><div class="line">  <span class="number">417</span>——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</div><div class="line"></div><div class="line"><span class="number">5</span>**(服务端错误类)：服务器不能正确执行一个正确的请求</div><div class="line">  HTTP <span class="number">500</span> - 服务器遇到错误，无法完成请求</div><div class="line">  　　HTTP <span class="number">500.100</span> - 内部服务器错误 - ASP 错误</div><div class="line">  　　HTTP <span class="number">500</span><span class="number">-11</span> 服务器关闭</div><div class="line">  　　HTTP <span class="number">500</span><span class="number">-12</span> 应用程序重新启动</div><div class="line">  　　HTTP <span class="number">500</span><span class="number">-13</span> - 服务器太忙</div><div class="line">  　　HTTP <span class="number">500</span><span class="number">-14</span> - 应用程序无效</div><div class="line">  　　HTTP <span class="number">500</span><span class="number">-15</span> - 不允许请求 global.asa</div><div class="line">  　　<span class="built_in">Error</span> <span class="number">501</span> - 未实现</div><div class="line">HTTP <span class="number">502</span> - 网关错误</div><div class="line">HTTP <span class="number">503</span>：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"><a href="#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）" class="headerlink" title="一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">详细版：</div><div class="line">  <span class="number">1</span>、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</div><div class="line">  <span class="number">2</span>、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</div><div class="line">  <span class="number">3</span>、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</div><div class="line">  <span class="number">4</span>、进行HTTP协议会话，客户端发送报头(请求报头);</div><div class="line">  <span class="number">5</span>、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</div><div class="line">  <span class="number">6</span>、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</div><div class="line">  <span class="number">7</span>、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回<span class="number">304</span>;</div><div class="line">  <span class="number">8</span>、浏览器开始下载html文档(响应报头，状态码<span class="number">200</span>)，同时使用缓存;</div><div class="line">  <span class="number">9</span>、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</div><div class="line">  <span class="number">10</span>、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</div><div class="line"></div><div class="line">简洁版：</div><div class="line">  浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</div><div class="line">  服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</div><div class="line">  浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</div><div class="line">  载入解析到的资源文件，渲染页面，完成。</div></pre></td></tr></table></figure>
<p><br></p>
<h3 id="移动端（Android-IOS）怎么做好用户体验"><a href="#移动端（Android-IOS）怎么做好用户体验" class="headerlink" title="移动端（Android IOS）怎么做好用户体验?"></a>移动端（Android IOS）怎么做好用户体验?</h3><p>  清晰的视觉纵线、<br>  信息的分组、极致的减法、<br>  利用选择代替输入、<br>  标签及文字的排布方式、<br>  依靠明文确认密码、<br>  合理的键盘利用、</p>
<h3 id="TCP传输的三次握手四次挥手策略"><a href="#TCP传输的三次握手四次挥手策略" class="headerlink" title="TCP传输的三次握手四次挥手策略"></a>TCP传输的三次握手四次挥手策略</h3><p>第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。</p>
<p>第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。</p>
<p>第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。</p>
<ul>
<li><p>为什么要三次握手：<br>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源<br>TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！</p>
</li>
<li><p>四次挥手</p>
</li>
</ul>
<p>1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段；<br>2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段；<br>3、服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接；<br>4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；</p>
<h3 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h3><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来</p>
<p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>
<h3 id="HTTP和HTTPS"><a href="#HTTP和HTTPS" class="headerlink" title="HTTP和HTTPS"></a>HTTP和HTTPS</h3><p>1、HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS<br>2、默认HTTP的端口号为80，HTTPS的端口号为443</p>
<p>HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。</p>
<h3 id="什么是Etag"><a href="#什么是Etag" class="headerlink" title="什么是Etag"></a>什么是Etag</h3><p>把Last-Modified和ETag请求的http报头一起使用，可利用客户端（例如浏览器）的缓存。ETag用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么ETag也随之发生变化。浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，<br>假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。</p>
<h3 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h3><p>1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。<br>2、CSS文件下载完成，开始构建CSSOM<br>3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。<br>4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。<br>5、最后一步，按照算出来的规则，把内容渲染到屏幕上。</p>
<p>以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。</p>
<h3 id="一个完整的URL包括以下几部分"><a href="#一个完整的URL包括以下几部分" class="headerlink" title="一个完整的URL包括以下几部分"></a>一个完整的URL包括以下几部分</h3><p>1、协议部分<br>2、域名部分<br>3、端口部分<br>4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止<br>5、文件名部分：从域名后的最后一个“/”开始到“？”为止<br>6、参数部分：从“？”开始到“#”为止之间的部分<br>7、锚部分：从“#”开始到最后</p>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在1024字节，Get是通过地址栏来传值。</p>
<p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post是通过提交表单来传值。</p>
<h3 id="说说网络分层里七层模型是哪七层"><a href="#说说网络分层里七层模型是哪七层" class="headerlink" title="说说网络分层里七层模型是哪七层"></a>说说网络分层里七层模型是哪七层</h3><p>应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）</p>
<p>传输层（TCP和UDP）</p>
<p>网络层（IP）</p>
<p>物理和数据链路层（以太网）</p>
<h3 id="讲讲304缓存的原理"><a href="#讲讲304缓存的原理" class="headerlink" title="讲讲304缓存的原理"></a>讲讲304缓存的原理</h3><p>服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>
<p>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</p>
<h3 id="http-keep-alive与tcp-keep-alive"><a href="#http-keep-alive与tcp-keep-alive" class="headerlink" title="http keep-alive与tcp keep-alive"></a>http keep-alive与tcp keep-alive</h3><p>http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。</p>
<h3 id="常见web安全及防护原理"><a href="#常见web安全及防护原理" class="headerlink" title="常见web安全及防护原理"></a>常见web安全及防护原理</h3><ul>
<li>sql注入原理<br>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</li>
<li>XSS<br>指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</li>
<li>CSRF<br>CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤：1、登录受信任网站A，并在本地生成Cookie。2、在不登出A的情况下，访问危险网站B。</li>
</ul>
<h3 id="对重构的理解"><a href="#对重构的理解" class="headerlink" title="对重构的理解"></a>对重构的理解</h3><p>在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p>
<p>减少代码间的耦合<br>让代码保持弹性<br>严格按规范编写代码<br>设计可扩展的API<br>代替旧有的框架、语言(如VB)<br>增强用户体验<br>通常来说对于速度的优化也包含在重构中</p>
</div><div class="article-meta" style="max-width:800px"><div class="tags"><i class="icon icon-tag"></i><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/interview/">interview</a><span class="tag-list-count">2</span></li></ul></div><div class="categories"><i class="icon icon-category"></i><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/面试/">面试</a><span class="category-list-count">2</span></li></ul></div></div><div class="article-comment" style="max-width:800px"><div class="ds-thread" id="ds-thread" data-thread-key="cj5zccdmb000f88u4t0aslako" data-title="常见的知识总结" data-url="http://youhonglian.github.io/2017/07/29/interview-test/" site-name="ueibo"></div><script>var siteName = document.getElementById('ds-thread').getAttribute('site-name');
var duoshuoQuery = {short_name: siteName};
(function() {
  var ds = document.createElement('script');
  ds.type = 'text/javascript';ds.async = true;
  ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
  ds.charset = 'UTF-8';
  (document.getElementsByTagName('head')[0] 
  || document.getElementsByTagName('body')[0]).appendChild(ds);
})();</script></div><ul class="navication"><li class="home"><a href="/"><i class="icon icon-home"></i></a></li><li><a href="/2017/08/03/javascript-quiz/"><i class="icon icon-arror-left"></i></a></li><li><a href="/2017/06/21/vue-bilibili/"><i class="icon icon-arror-right"></i></a></li></ul><div class="page-footer"><div class="top"><ul class="social"><li><a href="https://github.com/youhonglian" title="Github" target="_blank"><i class="icon icon-github"></i></a></li><li><a href="https://segmentfault.com/u/youzhiwan" title="SegmentFault" target="_blank"><i class="icon icon-segmentfault"></i></a></li><li><a href="http://weibo.com/537727123/profile?rightmod=1&amp;wvr=6&amp;mod=personinfo&amp;is_all=1" title="Weibo" target="_blank"><i class="icon icon-weibo"></i></a></li><li><a href="https://www.zhihu.com/people/jing-xiang-95-49/activities" title="zhihu" target="_blank"><i class="icon icon-zhihu"></i></a></li></ul></div><div class="bottom"><p class="copyright">© 2017 Youuu<br><small>POWER BY <a href="https://hexo.io" target="_blank">HEXO</a></small><small>, THEME BY <a href="https://github.com/BoizZ/hexo-theme-laughing" target="_blank">LAUGHING</a></small></p></div></div></div><script>var wrap = document.getElementById('wrap');
window.onload = function () {
  wrap.className += ' done';
}</script></body></html>