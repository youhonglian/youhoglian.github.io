{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hexo-theme-laughing/source/QQ.png","path":"QQ.png","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/favicon.jpg","path":"favicon.jpg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/css/main_style.css.map","path":"css/main_style.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/css/main_style.min.css.map","path":"css/main_style.min.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/fonts/icon.svg","path":"fonts/icon.svg","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/fonts/icon.eot","path":"fonts/icon.eot","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/fonts/icon.ttf","path":"fonts/icon.ttf","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/fonts/icon.woff","path":"fonts/icon.woff","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/sass/main_style.scss","path":"sass/main_style.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/css/main_style.css","path":"css/main_style.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/css/main_style.min.css","path":"css/main_style.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/LICENSE","path":"components/reset-css/LICENSE","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/README.md","path":"components/reset-css/README.md","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/gruntfile.js","path":"components/reset-css/gruntfile.js","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/package.json","path":"components/reset-css/package.json","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/main.scss","path":"components/reset-css/sass/main.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/mobile-native.scss","path":"components/reset-css/sass/mobile-native.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/mobile-single.scss","path":"components/reset-css/sass/mobile-single.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/dist/mobile/reset.css","path":"components/reset-css/dist/mobile/reset.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/dist/mobile/reset.min.css","path":"components/reset-css/dist/mobile/reset.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/dist/pc/reset.css","path":"components/reset-css/dist/pc/reset.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/mobile/reset.css.map","path":"components/reset-css/public/mobile/reset.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/mobile/reset.min.css.map","path":"components/reset-css/public/mobile/reset.min.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/dist/pc/reset.min.css","path":"components/reset-css/dist/pc/reset.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/mobile/reset.min.css","path":"components/reset-css/public/mobile/reset.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/mobile/reset.css","path":"components/reset-css/public/mobile/reset.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/main/reset.css.map","path":"components/reset-css/public/main/reset.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/main/reset.css","path":"components/reset-css/public/main/reset.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/main/reset.min.css.map","path":"components/reset-css/public/main/reset.min.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/native/reset.css.map","path":"components/reset-css/public/native/reset.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/native/reset.min.css.map","path":"components/reset-css/public/native/reset.min.css.map","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/custom/imitation-native.scss","path":"components/reset-css/sass/custom/imitation-native.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/main/reset.min.css","path":"components/reset-css/public/main/reset.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/reset/basic.scss","path":"components/reset-css/sass/reset/basic.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/reset/ie.scss","path":"components/reset-css/sass/reset/ie.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/native/reset.css","path":"components/reset-css/public/native/reset.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/native/reset.min.css","path":"components/reset-css/public/native/reset.min.css","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/reset/macos.scss","path":"components/reset-css/sass/reset/macos.scss","modified":1,"renderable":1},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/reset/mobile.scss","path":"components/reset-css/sass/reset/mobile.scss","modified":1,"renderable":1}],"Cache":[{"_id":"source/about.md","hash":"f3b8d07d78b0f4473dc86efa3cf22e49201b6411","modified":1497601826000},{"_id":"themes/hexo-theme-laughing/LICENSE","hash":"a1963a5785638110395343a67809226481891219","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/README.md","hash":"1592ed7a9cf88465308ae9f543a78952bf144299","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/_config.yml","hash":"002f1abb10ed5cafd3bb506f1cd9c60a1569b347","modified":1506491232000},{"_id":"themes/hexo-theme-laughing/gruntfile.js","hash":"f80f2a78c69603db35452a12b81f6aa63a4704da","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/.bowerrc","hash":"b75a692434bf6eacc36d6f794b578f1cb8ad5084","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/.gitignore","hash":"696f7166d4feaa4ea9b776cc0e73ef197743baad","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/package.json","hash":"9055802e4cc6bda54b7b38f7296461d756baf75a","modified":1497339770000},{"_id":"source/_posts/broswer.md","hash":"27dd807ec16ab23085a7379c58a7c44c6cc6a281","modified":1504876488000},{"_id":"source/_posts/docker-push.md","hash":"2881755c237030599b22dc20cb697014be3aba20","modified":1521026132000},{"_id":"source/_posts/http.md","hash":"629a317b9c9cde01830954000b920417fc6e7c67","modified":1504876448000},{"_id":"source/_posts/javascript-quiz.md","hash":"00ed9733cdf34433aa3ff69054e72dd02241b05b","modified":1506399058000},{"_id":"source/_posts/javascript-test.md","hash":"6da9f843da86028a7cb7d188948579e15785e38d","modified":1506399034000},{"_id":"source/_posts/lazy_img.md","hash":"c90de17e2cad5799198f2a15751c1257f0a01d3d","modified":1503407928000},{"_id":"source/_posts/mobile- optimization.md","hash":"3c0b81dd186dbaa170a50c2ffd850133ea0ac3ac","modified":1506323852000},{"_id":"source/_posts/promise.md","hash":"e6a8b8eb2c759381782670dd7f97ca3a9f3fc4bd","modified":1506399010000},{"_id":"source/_posts/vue-bilibili.md","hash":"60a43f3887c06fb8060644fcc61676632822220d","modified":1498443068000},{"_id":"source/_posts/vuex.md","hash":"f3b8d07d78b0f4473dc86efa3cf22e49201b6411","modified":1497601596000},{"_id":"source/_posts.1/broswer.md","hash":"76a4d1c858f8e0776d04494b9be24146698e07f5","modified":1501320030000},{"_id":"source/_posts.1/vue-bilibili.md","hash":"60a43f3887c06fb8060644fcc61676632822220d","modified":1501320030000},{"_id":"source/_posts.1/vuex.md","hash":"f3b8d07d78b0f4473dc86efa3cf22e49201b6411","modified":1501320030000},{"_id":"themes/hexo-theme-laughing/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/.git/FETCH_HEAD","hash":"d2b51ea4206ac6c0b487d1825bcfbb717308d8e9","modified":1498110278000},{"_id":"themes/hexo-theme-laughing/.git/config","hash":"3adbe2396417cf042937688477e09a1a6c171c36","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/.git/ORIG_HEAD","hash":"e2e6594ed16e335db3c2f0b7975a7e7a78f647fc","modified":1498110280000},{"_id":"themes/hexo-theme-laughing/.git/index","hash":"8ee16afab4baf2318b8a9ca82802846b77870a6b","modified":1521098550000},{"_id":"themes/hexo-theme-laughing/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/packed-refs","hash":"cd020244ff3cdc4acfddd06339b03bab188fd6e8","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/layout/index.pug","hash":"5852d5858f506b12d5f6c56d84dd31785bb00b12","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/layout/post.pug","hash":"cc276349e69b5cb4b9e8f31850cd4a9618e7c1e7","modified":1501320894000},{"_id":"themes/hexo-theme-laughing/source/QQ.png","hash":"3133c4d34719dc4a4a92391877fd7047af54da1a","modified":1506489132000},{"_id":"themes/hexo-theme-laughing/source/favicon.jpg","hash":"ac3902d5e0c43a07a03ae5c3589e96f6a8c8d710","modified":1492266980000},{"_id":"source/_posts/interview-test.md","hash":"e434761a50fbcab41f1f937cf70bb86d35d97ee4","modified":1502682658000},{"_id":"themes/hexo-theme-laughing/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1497339764000},{"_id":"themes/hexo-theme-laughing/.git/logs/HEAD","hash":"9d9cdd22dfea6bf3e080359869215b046762c61c","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/layout/_partial/footer.pug","hash":"bab4bc82e351120dabf081c890ce882b4240acec","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/layout/_partial/layout.pug","hash":"2cbba20bb5b47ef1695e1309704064ad89eb8ebf","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/layout/_partial/page_header.pug","hash":"1eaf8a4f321d41fd6df495cebd02a971904c60dc","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/layout/_partial/pagination.pug","hash":"66760d1ffc79c2c4b8b31bd101c35f55e8edd667","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/layout/_partial/post_header.pug","hash":"52900ad4c45f72ace94c791184f0e57adb39cf29","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/css/main_style.css.map","hash":"34deafa6968222c2d605993963218b0d6cc3a1c2","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/css/main_style.min.css.map","hash":"8ae4bcc6d949178074d58c107235705c6656efa7","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/fonts/icon.svg","hash":"c1733f71323f938b4c4c1d282733c7c651e5bf20","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/fonts/icon.eot","hash":"845e74fd0134d11cb064e5440ae490c846670f2e","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/fonts/icon.ttf","hash":"c403df27000403dd4de7ffe2b4e80d04c4475a07","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/fonts/icon.woff","hash":"7d828283afa799b70a8531b9a2662c559b346439","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/main_style.scss","hash":"de0f792d028edd1115ba310efbe6016c01fb37bf","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/css/main_style.css","hash":"edc2ddc7e202208a6207d66ef65a7523d6153ff4","modified":1497349880000},{"_id":"themes/hexo-theme-laughing/source/css/main_style.min.css","hash":"6ca4b2696f886f0ea72d719cce000fc720f09690","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/.git/refs/heads/master","hash":"e2e6594ed16e335db3c2f0b7975a7e7a78f647fc","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/.git/objects/pack/pack-fe740b91db11efa67196082ece3951a152c16a02.idx","hash":"267b9cf81bb525f8a1860559d4038eb46e49b53f","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/LICENSE","hash":"a1963a5785638110395343a67809226481891219","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/README.md","hash":"adcd30abc9771724c51646d82e109461ecc7439f","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/gruntfile.js","hash":"1d49dc6b7a33ba3f24622f6638528a7abc45ed2b","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/.bower.json","hash":"c325b80d23bf177fc7cc626a6c417765635e7646","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/.gitignore","hash":"b54c108d488f239962023a617b5246f939259dee","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/package.json","hash":"a4d8b5cd6801d2c342da0f300a0515ea5e78ffaa","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/duoshuo.scss","hash":"ca662ef3da30ea17aabd694b6ee587c16343f252","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/footer.scss","hash":"cdc201f780c77f17bd106b2345d1bf49f0ab2c26","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/layout.scss","hash":"850832c81da2935bbba7541501bd0ac07ff06334","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/list.scss","hash":"afab82351c0204a3bf98316a8f3ec54a70a5b375","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/main_navi.scss","hash":"bdb3767b7f9580f24e4410ebea678688fb146b00","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/navication.scss","hash":"11a1105fafbc86a1138dfd30baf62d0ee22eed23","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/page_header.scss","hash":"00ae8c279ef8b50bbedab0a81296cabf96c701c6","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/pagination.scss","hash":"a1bd4e4ac36f428cc8a86dc324eee73558ad240e","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/post.scss","hash":"64d31a608f2e5ac59ce84b384a8a9d704184f85a","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_partial/post_header.scss","hash":"903f3d5b827085bed87e1a66e845d65feac7ba88","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_util/color.scss","hash":"d7aba613cdc8184855fb6050ccadfee997dc366d","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_util/hightlight.scss","hash":"43a603004401e5b64cf0421e5c4bcfea46bc5154","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_util/icon.scss","hash":"acd092eba96d5dd01c170bbe9cc6e1cb6f4a7a8c","modified":1506490894000},{"_id":"themes/hexo-theme-laughing/source/sass/_util/media.scss","hash":"91ac0109aa4c1188f212677224638763a665f1ec","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/sass/_util/mixin.scss","hash":"a827fc341d3baa45fd3be1f5dfd23cbe2a79b247","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/.git/logs/refs/heads/master","hash":"9d9cdd22dfea6bf3e080359869215b046762c61c","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/_common.scss","hash":"e43ee0cc485b6e8ee11e33434dd8472e449f8804","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/main.scss","hash":"c8c8dac049e6f1f03c4806e3b0edd1b527b4bcbf","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/mobile-native.scss","hash":"517e2ca2de4f9556a0bb6e966183967f7bf1f860","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/mobile-single.scss","hash":"d72bccef30971eefbf81bef7bf7ce60e1ac0103e","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/dist/mobile/reset.css","hash":"0521f9a7d0549e17d161f06a9af772a33425860e","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/dist/mobile/reset.min.css","hash":"752bcb20555fb6152867a7437aacf079f3c93c36","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/dist/pc/reset.css","hash":"ce583f5d4a070592882ab3ff5bfef6c3b1298ba6","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/.git/logs/refs/remotes/origin/HEAD","hash":"9d9cdd22dfea6bf3e080359869215b046762c61c","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/mobile/reset.css.map","hash":"445951f6ffd9f5fb3ae8293cf181f4b325e78e91","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/mobile/reset.min.css.map","hash":"391be8903caeb13fc78eccc26554d6c867e4c01f","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/dist/pc/reset.min.css","hash":"d0e76dd5d95e95deee9c745438d8bf36b342081c","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/mobile/reset.min.css","hash":"075dc29373e343e78f9360a17a37c68fb8cc6233","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/mobile/reset.css","hash":"65ab82344dcdf2ac0a1ad27e9fd794bc435567b5","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/main/reset.css.map","hash":"5fecf7b914ca0bb1a5f4eaf4b2611b9c213a10ac","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/main/reset.css","hash":"b9ae9b280a5111838b333ba2fe58ad71784a9d7e","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/main/reset.min.css.map","hash":"460769e3339222fccba1ee502f61815df3165ba4","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/native/reset.css.map","hash":"cca7d0a6572c76c78e5c0155a47ee38ceced455f","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/native/reset.min.css.map","hash":"93ff7a851ba44801bab6e573b2c35e2c3ce873b8","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/custom/_microsoft-yahei.scss","hash":"4c29be667ae1decd0cc2da424e89c792b901eefe","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/custom/imitation-native.scss","hash":"86430c4b851d435240c6f7c7ac3deb78ce409648","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/main/reset.min.css","hash":"7727d79fe774c70caa451fce8a7fc09c2f446716","modified":1497339770000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/reset/basic.scss","hash":"9a6ad501a75ee9b6eb8d6dd7e009c0a5cf891fdc","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/reset/ie.scss","hash":"cf51b7dd03fd769f3c86bfb63edc974df42020f7","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/native/reset.css","hash":"a7ae24f842349ac80b5de5720ed9eb3bc35fc93f","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/public/native/reset.min.css","hash":"0f7aa0d05acd90087aca7614e55df2471941d78a","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/reset/macos.scss","hash":"d5258c47f89e1a06337f88043f6143480abf4826","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/source/components/reset-css/sass/reset/mobile.scss","hash":"61223c6c44083cf61dba24b508e61be4640703d8","modified":1497339772000},{"_id":"themes/hexo-theme-laughing/.git/objects/pack/pack-fe740b91db11efa67196082ece3951a152c16a02.pack","hash":"e5e07c45962cd7c6f90c8e51dcafb4f1bd12ad9a","modified":1497339770000}],"Category":[{"name":"面试","_id":"cjvuo4aca0003gvk9rhdrmfkg"},{"name":"docker","_id":"cjvuo4aci0008gvk9aj2710zo"},{"name":"javascript","_id":"cjvuo4aco000egvk9v4puk7n3"},{"name":"js","_id":"cjvuo4acs000mgvk9l25o8x6d"},{"name":"css","_id":"cjvuo4act000rgvk9eb08bu0p"},{"name":"ES6","_id":"cjvuo4act000vgvk9wgnd25aw"},{"name":"vue.js","_id":"cjvuo4acu000zgvk9d7ujrzrw"},{"name":"http","_id":"cjvuo4aib001agvk9mz02b8cl"}],"Data":[],"Page":[{"title":"对Vuex的基本理解","categories":"vue.js","tags":["vuex"],"_content":"\n## Vuex\n> vuex是为vue.js开发的状态管理模式，存储应用中的所有数据状态，便于统一管理。它是应用中唯一的数据源，所以一个应用中只有一个store实例。\n\n\n### 安装和使用\n\n```JavaScript\nimport Vue from 'vue'\n\nimport Vuex from 'vuex'\n\n//Vuex用过store选项，提供了一种机制，将数据从跟组件注入到每个子组件中（需要调用Vue.use(Vuex)）:\n\nVue.use(Vuex)\n```\n\n\n\n### state\n\n通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中。且子组件能通过this.$store访问到\n\n```JavaScript \n const Counter = {\n      template: `<div>{{ count }}</div>`,\n      //从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：\n      computed: {\n          count () {\n          return this.$store.state.count\n          }\n      }\n  }\n \n```\n\n\n\n### mapState辅助函数\n\n当一个组件需要获取多个状态时，逐个声明计算属性会很麻烦，为此我们可以使用mapState辅助函数帮我们生成： // 在单独构建的版本中辅助函数为 Vuex.mapState\n\n```JavaScript\nimport { mapState } from 'vuex'\n\nexport default {\n  computed: mapState({\n         /*三种不同的方式*/\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n    // 传字符串参数 'count' 等同于 `state => state.count`\n        countAlias: 'count',\n        // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n        countPlusLocalState (state) {\n          return state.count + this.localCount\n        }\n  })\n}\n```\n\n上边我们给mapState传了一个对象，如果我们要生成的计算属性名称与state子节点名称相同时，也可以直接给mapState传入一个字符串数组：\n\n```JavaScript\n   computed: mapState([\n      // 映射 this.count 为 store.state.count\n      'count'\n    ])\n```\n\n### 对象展开运算符\n\nmapState函数返回的是一个对象，但是一个组件中的计算属性，不仅有来自store的，还有它局部的。那么如何混用呢？我们使用对象展开运算符：\n\n```JavaScript \n computed: {\n      //localComputed 是组件的局部计算属性\n      localComputed () { /* ... */ },\n      // 使用对象展开运算符将此对象混入到外部对象中\n      ...mapState({\n        // ...\n      })\n    }\n    \n```\n\n\n### Getters\n\n有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：\n\n```JavaScript\n     computed: {\n      doneTodosCount () {\n        return this.$store.state.todos.filter(todo => todo.done).length\n      }\n   }\n```\nVuex允许我们在store中定义getters（可以认为是store的计算属性）。getter接受state作为第一个参数：\n\n```JavaScript\n// 在'store/index.js'中\n    const store = new Vuex.Store({\n      state: {\n        todos: [\n          { id: 1, text: '...', done: true },\n           { id: 2, text: '...', done: false }\n            ]\n      },\n      getters: {\n            doneTodos: state => {\n          return state.todos.filter(todo => todo.done)\n        },\n    // getters也可以接受其他getters作为第二个参数\n        doneTodosCount: (state, getters) => {\n          return getters.doneTodos.length\n            }\n      }\n    })\n```\n\n### mapGetters辅助函数\n\nmapGetters辅助函数仅仅是将store中的getters映射到局部计算属性：\n```JavaScript\n    import { mapGetters } from 'vuex'\n\n    export default {\n    // ...\n    computed: {\n    // 使用对象展开运算符将 getters 混入 computed 对象中\n    ...mapGetters([\n    'doneTodosCount',\n    'anotherGetter',\n    // ...\n    ])\n    //如果想给getter属性领取一个名字，可以对象形式：\n    mapGetters({\n    // 映射 this.doneCount 为 store.getters.doneTodosCount\n    doneCount: 'doneTodosCount'\n    })\n    }\n    }\n```\n\n### Mutations\n\n更改Vuex的store中的状态的唯一方法是提交mutation。Vuex的mutataions非常类似于事件：每个mutation都有一个字符串的事件类型（type）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，他会接受state作为第一个参数：\n\n```JavaScript\n    const store = new Vuex.Store({\n    state: {\n            count: 1\n    },\n    mutations: {\n            increment (state) {\n        // 变更状态\n        state.count++\n            }\n    }\n    })\n```\n\n上边注册了一个类型为increment的mutation：“当触发一个类型为increment的mutation时，调用此函数。”实际使用时：store.commit('increment')\n\n### 使用常量替代Mutation事件类型\n\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```JavaScript \n  //mutation-types.js\n\n  export const SOME_MUTATION = 'SOME_MUTATION'\n```\n\n```JavaScript\n    //store.js\n    import Vuex from 'vuex'\n    import * as types from './mutation-types'\n\n    const store = new Vuex.Store({\n    state: { ... },\n    mutations: {\n      // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n      [types.SOME_MUTATION] (state) {\n      // mutate state\n      }\n     }\n    })\n```\n\nmutation必须是同步函数你可以在组件中使用this.store.commit('type')提交mutataion，或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用（需要在根节点注入store）。\n\n```JavaScript\n    import { mapMutations } from 'vuex'\n\n    export default {\n    // ...\n    methods: {\n      ...mapMutations([\n      'increment' // 映射 this.increment() 为 this.$store.commit('increment')\n    ]),\n    ...mapMutations({\n       add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')\n    })\n    }\n    }\n```\n\n### Actions\n\nAction类似于mutation，不同之处在于：\n\nAction提交的是mutataion，而不是直接变更状态。\nAction可以包含任意异步操作。\n注册一个简单的Action：\n\n```JavaScript\n    const store = new Vuex.Store({\n    state: {\n        count: 0\n    },\n    mutations: {\n        increment (state) {\n        state.count++\n        }\n    },\n    actions: {\n        increment (context) {\n        context.commit('increment')\n        }\n    }\n    })\n```\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n\n>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。\n\n```JavaScript\n    //例如：赋值  var [a,b,c] = [1,2,3]\n    //例如：交换变量 [x,y] = [y,x]\n    //例如：函数参数解构：\n    // function add([x, y]){\n    //   return x + y;\n    // }\n    //实践中我们常用到 参数解构 来简化代码，下边\n    //的 { commit } 就用到了解构。\n\n    actions: {\n    increment ({ commit }) {\n        commit('increment')\n    }\n}\n```\n这里解构的对象是context对象，也就是说context <==> { commit }，这样写就可以用commit替代context.commit，简化代码。\n\n### 分发Action\n\nAction通过store.dispatch方法触发：store.dispatch('increment') Actions 支持同样的载荷方式和对象方式进行分发：\n\n* 以载荷形式分发\n```JavaScript\n    store.dispatch('incrementAsync', {\n        amount: 10\n    })\n```\n* 以对象形式分发\n```JavaScript\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n我们可以在Action内部执行异步操作：\n```JavaScript\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\n* 在组件中分发Action\n\n你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：\n```JavaScript\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n       'increment' // 映射 this.increment() 为 this.$store.dispatch('increment')\n    ]),\n    ...mapActions({\n       add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment')\n    })\n  }\n}\n```\n\n### Modules\n使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。\n\n为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：\n\n```JavaScript\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n","source":"about.md","raw":"---\ntitle: 对Vuex的基本理解\ncategories:  vue.js\ntags: \n- vuex\n---\n\n## Vuex\n> vuex是为vue.js开发的状态管理模式，存储应用中的所有数据状态，便于统一管理。它是应用中唯一的数据源，所以一个应用中只有一个store实例。\n\n\n### 安装和使用\n\n```JavaScript\nimport Vue from 'vue'\n\nimport Vuex from 'vuex'\n\n//Vuex用过store选项，提供了一种机制，将数据从跟组件注入到每个子组件中（需要调用Vue.use(Vuex)）:\n\nVue.use(Vuex)\n```\n\n\n\n### state\n\n通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中。且子组件能通过this.$store访问到\n\n```JavaScript \n const Counter = {\n      template: `<div>{{ count }}</div>`,\n      //从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：\n      computed: {\n          count () {\n          return this.$store.state.count\n          }\n      }\n  }\n \n```\n\n\n\n### mapState辅助函数\n\n当一个组件需要获取多个状态时，逐个声明计算属性会很麻烦，为此我们可以使用mapState辅助函数帮我们生成： // 在单独构建的版本中辅助函数为 Vuex.mapState\n\n```JavaScript\nimport { mapState } from 'vuex'\n\nexport default {\n  computed: mapState({\n         /*三种不同的方式*/\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n    // 传字符串参数 'count' 等同于 `state => state.count`\n        countAlias: 'count',\n        // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n        countPlusLocalState (state) {\n          return state.count + this.localCount\n        }\n  })\n}\n```\n\n上边我们给mapState传了一个对象，如果我们要生成的计算属性名称与state子节点名称相同时，也可以直接给mapState传入一个字符串数组：\n\n```JavaScript\n   computed: mapState([\n      // 映射 this.count 为 store.state.count\n      'count'\n    ])\n```\n\n### 对象展开运算符\n\nmapState函数返回的是一个对象，但是一个组件中的计算属性，不仅有来自store的，还有它局部的。那么如何混用呢？我们使用对象展开运算符：\n\n```JavaScript \n computed: {\n      //localComputed 是组件的局部计算属性\n      localComputed () { /* ... */ },\n      // 使用对象展开运算符将此对象混入到外部对象中\n      ...mapState({\n        // ...\n      })\n    }\n    \n```\n\n\n### Getters\n\n有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：\n\n```JavaScript\n     computed: {\n      doneTodosCount () {\n        return this.$store.state.todos.filter(todo => todo.done).length\n      }\n   }\n```\nVuex允许我们在store中定义getters（可以认为是store的计算属性）。getter接受state作为第一个参数：\n\n```JavaScript\n// 在'store/index.js'中\n    const store = new Vuex.Store({\n      state: {\n        todos: [\n          { id: 1, text: '...', done: true },\n           { id: 2, text: '...', done: false }\n            ]\n      },\n      getters: {\n            doneTodos: state => {\n          return state.todos.filter(todo => todo.done)\n        },\n    // getters也可以接受其他getters作为第二个参数\n        doneTodosCount: (state, getters) => {\n          return getters.doneTodos.length\n            }\n      }\n    })\n```\n\n### mapGetters辅助函数\n\nmapGetters辅助函数仅仅是将store中的getters映射到局部计算属性：\n```JavaScript\n    import { mapGetters } from 'vuex'\n\n    export default {\n    // ...\n    computed: {\n    // 使用对象展开运算符将 getters 混入 computed 对象中\n    ...mapGetters([\n    'doneTodosCount',\n    'anotherGetter',\n    // ...\n    ])\n    //如果想给getter属性领取一个名字，可以对象形式：\n    mapGetters({\n    // 映射 this.doneCount 为 store.getters.doneTodosCount\n    doneCount: 'doneTodosCount'\n    })\n    }\n    }\n```\n\n### Mutations\n\n更改Vuex的store中的状态的唯一方法是提交mutation。Vuex的mutataions非常类似于事件：每个mutation都有一个字符串的事件类型（type）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，他会接受state作为第一个参数：\n\n```JavaScript\n    const store = new Vuex.Store({\n    state: {\n            count: 1\n    },\n    mutations: {\n            increment (state) {\n        // 变更状态\n        state.count++\n            }\n    }\n    })\n```\n\n上边注册了一个类型为increment的mutation：“当触发一个类型为increment的mutation时，调用此函数。”实际使用时：store.commit('increment')\n\n### 使用常量替代Mutation事件类型\n\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```JavaScript \n  //mutation-types.js\n\n  export const SOME_MUTATION = 'SOME_MUTATION'\n```\n\n```JavaScript\n    //store.js\n    import Vuex from 'vuex'\n    import * as types from './mutation-types'\n\n    const store = new Vuex.Store({\n    state: { ... },\n    mutations: {\n      // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n      [types.SOME_MUTATION] (state) {\n      // mutate state\n      }\n     }\n    })\n```\n\nmutation必须是同步函数你可以在组件中使用this.store.commit('type')提交mutataion，或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用（需要在根节点注入store）。\n\n```JavaScript\n    import { mapMutations } from 'vuex'\n\n    export default {\n    // ...\n    methods: {\n      ...mapMutations([\n      'increment' // 映射 this.increment() 为 this.$store.commit('increment')\n    ]),\n    ...mapMutations({\n       add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')\n    })\n    }\n    }\n```\n\n### Actions\n\nAction类似于mutation，不同之处在于：\n\nAction提交的是mutataion，而不是直接变更状态。\nAction可以包含任意异步操作。\n注册一个简单的Action：\n\n```JavaScript\n    const store = new Vuex.Store({\n    state: {\n        count: 0\n    },\n    mutations: {\n        increment (state) {\n        state.count++\n        }\n    },\n    actions: {\n        increment (context) {\n        context.commit('increment')\n        }\n    }\n    })\n```\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n\n>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。\n\n```JavaScript\n    //例如：赋值  var [a,b,c] = [1,2,3]\n    //例如：交换变量 [x,y] = [y,x]\n    //例如：函数参数解构：\n    // function add([x, y]){\n    //   return x + y;\n    // }\n    //实践中我们常用到 参数解构 来简化代码，下边\n    //的 { commit } 就用到了解构。\n\n    actions: {\n    increment ({ commit }) {\n        commit('increment')\n    }\n}\n```\n这里解构的对象是context对象，也就是说context <==> { commit }，这样写就可以用commit替代context.commit，简化代码。\n\n### 分发Action\n\nAction通过store.dispatch方法触发：store.dispatch('increment') Actions 支持同样的载荷方式和对象方式进行分发：\n\n* 以载荷形式分发\n```JavaScript\n    store.dispatch('incrementAsync', {\n        amount: 10\n    })\n```\n* 以对象形式分发\n```JavaScript\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n我们可以在Action内部执行异步操作：\n```JavaScript\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\n* 在组件中分发Action\n\n你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：\n```JavaScript\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n       'increment' // 映射 this.increment() 为 this.$store.dispatch('increment')\n    ]),\n    ...mapActions({\n       add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment')\n    })\n  }\n}\n```\n\n### Modules\n使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。\n\n为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：\n\n```JavaScript\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n","date":"2019-05-19T08:16:23.533Z","updated":"2017-06-16T08:30:26.000Z","path":"about.html","comments":1,"layout":"page","_id":"cjvuo4ac40000gvk9zd5t9loo","content":"<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><blockquote>\n<p>vuex是为vue.js开发的状态管理模式，存储应用中的所有数据状态，便于统一管理。它是应用中唯一的数据源，所以一个应用中只有一个store实例。</p>\n</blockquote>\n<h3 id=\"安装和使用\"><a href=\"#安装和使用\" class=\"headerlink\" title=\"安装和使用\"></a>安装和使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Vuex用过store选项，提供了一种机制，将数据从跟组件注入到每个子组件中（需要调用Vue.use(Vuex)）:</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>\n<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p>通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中。且子组件能通过this.$store访问到</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Counter = &#123;</span><br><span class=\"line\">     template: <span class=\"string\">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class=\"line\">     <span class=\"comment\">//从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：</span></span><br><span class=\"line\">     computed: &#123;</span><br><span class=\"line\">         count () &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapState辅助函数\"><a href=\"#mapState辅助函数\" class=\"headerlink\" title=\"mapState辅助函数\"></a>mapState辅助函数</h3><p>当一个组件需要获取多个状态时，逐个声明计算属性会很麻烦，为此我们可以使用mapState辅助函数帮我们生成： // 在单独构建的版本中辅助函数为 Vuex.mapState</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*三种不同的方式*/</span></span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可使代码更简练</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">        countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class=\"line\">        countPlusLocalState (state) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上边我们给mapState传了一个对象，如果我们要生成的计算属性名称与state子节点名称相同时，也可以直接给mapState传入一个字符串数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">   <span class=\"comment\">// 映射 this.count 为 store.state.count</span></span><br><span class=\"line\">   <span class=\"string\">'count'</span></span><br><span class=\"line\"> ])</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象展开运算符\"><a href=\"#对象展开运算符\" class=\"headerlink\" title=\"对象展开运算符\"></a>对象展开运算符</h3><p>mapState函数返回的是一个对象，但是一个组件中的计算属性，不仅有来自store的，还有它局部的。那么如何混用呢？我们使用对象展开运算符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">     <span class=\"comment\">//localComputed 是组件的局部计算属性</span></span><br><span class=\"line\">     localComputed () &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">     <span class=\"comment\">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class=\"line\">     ...mapState(&#123;</span><br><span class=\"line\">       <span class=\"comment\">// ...</span></span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h3><p>有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">   doneTodosCount () &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done).length</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vuex允许我们在store中定义getters（可以认为是store的计算属性）。getter接受state作为第一个参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在'store/index.js'中</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">      state: &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">text</span>: <span class=\"string\">'...'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">           &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">text</span>: <span class=\"string\">'...'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      getters: &#123;</span><br><span class=\"line\">            doneTodos: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// getters也可以接受其他getters作为第二个参数</span></span><br><span class=\"line\">        doneTodosCount: <span class=\"function\">(<span class=\"params\">state, getters</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> getters.doneTodos.length</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapGetters辅助函数\"><a href=\"#mapGetters辅助函数\" class=\"headerlink\" title=\"mapGetters辅助函数\"></a>mapGetters辅助函数</h3><p>mapGetters辅助函数仅仅是将store中的getters映射到局部计算属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\"><span class=\"comment\">// 使用对象展开运算符将 getters 混入 computed 对象中</span></span><br><span class=\"line\">...mapGetters([</span><br><span class=\"line\"><span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\"><span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"comment\">//如果想给getter属性领取一个名字，可以对象形式：</span></span><br><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\"><span class=\"comment\">// 映射 this.doneCount 为 store.getters.doneTodosCount</span></span><br><span class=\"line\">doneCount: <span class=\"string\">'doneTodosCount'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mutations\"><a href=\"#Mutations\" class=\"headerlink\" title=\"Mutations\"></a>Mutations</h3><p>更改Vuex的store中的状态的唯一方法是提交mutation。Vuex的mutataions非常类似于事件：每个mutation都有一个字符串的事件类型（type）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，他会接受state作为第一个参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">        count: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">        increment (state) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 变更状态</span></span><br><span class=\"line\">    state.count++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上边注册了一个类型为increment的mutation：“当触发一个类型为increment的mutation时，调用此函数。”实际使用时：store.commit(‘increment’)</p>\n<h3 id=\"使用常量替代Mutation事件类型\"><a href=\"#使用常量替代Mutation事件类型\" class=\"headerlink\" title=\"使用常量替代Mutation事件类型\"></a>使用常量替代Mutation事件类型</h3><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mutation-types.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SOME_MUTATION = <span class=\"string\">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//store.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'./mutation-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123; ... &#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class=\"line\">  [types.SOME_MUTATION] (state) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// mutate state</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>mutation必须是同步函数你可以在组件中使用this.store.commit(‘type’)提交mutataion，或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用（需要在根节点注入store）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapMutations([</span><br><span class=\"line\">  <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 为 this.$store.commit('increment')</span></span><br><span class=\"line\">]),</span><br><span class=\"line\">...mapMutations(&#123;</span><br><span class=\"line\">   add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 为 this.$store.commit('increment')</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>Action类似于mutation，不同之处在于：</p>\n<p>Action提交的是mutataion，而不是直接变更状态。<br>Action可以包含任意异步操作。<br>注册一个简单的Action：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">    state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    increment (context) &#123;</span><br><span class=\"line\">    context.commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。</p>\n<blockquote>\n<p>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//例如：赋值  var [a,b,c] = [1,2,3]</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：交换变量 [x,y] = [y,x]</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：函数参数解构：</span></span><br><span class=\"line\">    <span class=\"comment\">// function add([x, y])&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   return x + y;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//实践中我们常用到 参数解构 来简化代码，下边</span></span><br><span class=\"line\">    <span class=\"comment\">//的 &#123; commit &#125; 就用到了解构。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">    increment (&#123; commit &#125;) &#123;</span><br><span class=\"line\">        commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里解构的对象是context对象，也就是说context &lt;==&gt; { commit }，这样写就可以用commit替代context.commit，简化代码。</p>\n<h3 id=\"分发Action\"><a href=\"#分发Action\" class=\"headerlink\" title=\"分发Action\"></a>分发Action</h3><p>Action通过store.dispatch方法触发：store.dispatch(‘increment’) Actions 支持同样的载荷方式和对象方式进行分发：</p>\n<ul>\n<li><p>以载荷形式分发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(<span class=\"string\">'incrementAsync'</span>, &#123;</span><br><span class=\"line\">    amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以对象形式分发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'incrementAsync'</span>,</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们可以在Action内部执行异步操作：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>在组件中分发Action</li>\n</ul>\n<p>你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">       <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 为 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">       add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 为 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><blockquote>\n<p>vuex是为vue.js开发的状态管理模式，存储应用中的所有数据状态，便于统一管理。它是应用中唯一的数据源，所以一个应用中只有一个store实例。</p>\n</blockquote>\n<h3 id=\"安装和使用\"><a href=\"#安装和使用\" class=\"headerlink\" title=\"安装和使用\"></a>安装和使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Vuex用过store选项，提供了一种机制，将数据从跟组件注入到每个子组件中（需要调用Vue.use(Vuex)）:</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>\n<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p>通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中。且子组件能通过this.$store访问到</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Counter = &#123;</span><br><span class=\"line\">     template: <span class=\"string\">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class=\"line\">     <span class=\"comment\">//从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：</span></span><br><span class=\"line\">     computed: &#123;</span><br><span class=\"line\">         count () &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapState辅助函数\"><a href=\"#mapState辅助函数\" class=\"headerlink\" title=\"mapState辅助函数\"></a>mapState辅助函数</h3><p>当一个组件需要获取多个状态时，逐个声明计算属性会很麻烦，为此我们可以使用mapState辅助函数帮我们生成： // 在单独构建的版本中辅助函数为 Vuex.mapState</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*三种不同的方式*/</span></span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可使代码更简练</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">        countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class=\"line\">        countPlusLocalState (state) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上边我们给mapState传了一个对象，如果我们要生成的计算属性名称与state子节点名称相同时，也可以直接给mapState传入一个字符串数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">   <span class=\"comment\">// 映射 this.count 为 store.state.count</span></span><br><span class=\"line\">   <span class=\"string\">'count'</span></span><br><span class=\"line\"> ])</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象展开运算符\"><a href=\"#对象展开运算符\" class=\"headerlink\" title=\"对象展开运算符\"></a>对象展开运算符</h3><p>mapState函数返回的是一个对象，但是一个组件中的计算属性，不仅有来自store的，还有它局部的。那么如何混用呢？我们使用对象展开运算符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">     <span class=\"comment\">//localComputed 是组件的局部计算属性</span></span><br><span class=\"line\">     localComputed () &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">     <span class=\"comment\">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class=\"line\">     ...mapState(&#123;</span><br><span class=\"line\">       <span class=\"comment\">// ...</span></span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h3><p>有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">   doneTodosCount () &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done).length</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vuex允许我们在store中定义getters（可以认为是store的计算属性）。getter接受state作为第一个参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在'store/index.js'中</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">      state: &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">text</span>: <span class=\"string\">'...'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">           &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">text</span>: <span class=\"string\">'...'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      getters: &#123;</span><br><span class=\"line\">            doneTodos: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// getters也可以接受其他getters作为第二个参数</span></span><br><span class=\"line\">        doneTodosCount: <span class=\"function\">(<span class=\"params\">state, getters</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> getters.doneTodos.length</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapGetters辅助函数\"><a href=\"#mapGetters辅助函数\" class=\"headerlink\" title=\"mapGetters辅助函数\"></a>mapGetters辅助函数</h3><p>mapGetters辅助函数仅仅是将store中的getters映射到局部计算属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\"><span class=\"comment\">// 使用对象展开运算符将 getters 混入 computed 对象中</span></span><br><span class=\"line\">...mapGetters([</span><br><span class=\"line\"><span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\"><span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"comment\">//如果想给getter属性领取一个名字，可以对象形式：</span></span><br><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\"><span class=\"comment\">// 映射 this.doneCount 为 store.getters.doneTodosCount</span></span><br><span class=\"line\">doneCount: <span class=\"string\">'doneTodosCount'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mutations\"><a href=\"#Mutations\" class=\"headerlink\" title=\"Mutations\"></a>Mutations</h3><p>更改Vuex的store中的状态的唯一方法是提交mutation。Vuex的mutataions非常类似于事件：每个mutation都有一个字符串的事件类型（type）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，他会接受state作为第一个参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">        count: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">        increment (state) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 变更状态</span></span><br><span class=\"line\">    state.count++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上边注册了一个类型为increment的mutation：“当触发一个类型为increment的mutation时，调用此函数。”实际使用时：store.commit(‘increment’)</p>\n<h3 id=\"使用常量替代Mutation事件类型\"><a href=\"#使用常量替代Mutation事件类型\" class=\"headerlink\" title=\"使用常量替代Mutation事件类型\"></a>使用常量替代Mutation事件类型</h3><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mutation-types.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SOME_MUTATION = <span class=\"string\">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//store.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'./mutation-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123; ... &#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class=\"line\">  [types.SOME_MUTATION] (state) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// mutate state</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>mutation必须是同步函数你可以在组件中使用this.store.commit(‘type’)提交mutataion，或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用（需要在根节点注入store）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapMutations([</span><br><span class=\"line\">  <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 为 this.$store.commit('increment')</span></span><br><span class=\"line\">]),</span><br><span class=\"line\">...mapMutations(&#123;</span><br><span class=\"line\">   add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 为 this.$store.commit('increment')</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>Action类似于mutation，不同之处在于：</p>\n<p>Action提交的是mutataion，而不是直接变更状态。<br>Action可以包含任意异步操作。<br>注册一个简单的Action：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">    state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    increment (context) &#123;</span><br><span class=\"line\">    context.commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。</p>\n<blockquote>\n<p>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//例如：赋值  var [a,b,c] = [1,2,3]</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：交换变量 [x,y] = [y,x]</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：函数参数解构：</span></span><br><span class=\"line\">    <span class=\"comment\">// function add([x, y])&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   return x + y;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//实践中我们常用到 参数解构 来简化代码，下边</span></span><br><span class=\"line\">    <span class=\"comment\">//的 &#123; commit &#125; 就用到了解构。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">    increment (&#123; commit &#125;) &#123;</span><br><span class=\"line\">        commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里解构的对象是context对象，也就是说context &lt;==&gt; { commit }，这样写就可以用commit替代context.commit，简化代码。</p>\n<h3 id=\"分发Action\"><a href=\"#分发Action\" class=\"headerlink\" title=\"分发Action\"></a>分发Action</h3><p>Action通过store.dispatch方法触发：store.dispatch(‘increment’) Actions 支持同样的载荷方式和对象方式进行分发：</p>\n<ul>\n<li><p>以载荷形式分发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(<span class=\"string\">'incrementAsync'</span>, &#123;</span><br><span class=\"line\">    amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以对象形式分发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'incrementAsync'</span>,</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们可以在Action内部执行异步操作：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>在组件中分发Action</li>\n</ul>\n<p>你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">       <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 为 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">       add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 为 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>\n"}],"Post":[{"title":"常见的浏览器兼容问题","_content":"\n## 浏览器兼容问题\n\n\n\n###  不同浏览器的标签默认的外补丁和内补丁不同\n\n 这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。\n\n ```javascript\n *{margin:0;padding:0;}\n ```\n\n ###  图片处理问题\n\n png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.\n\n ### IE6双边距bug\n\n 块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）\n 解决方案是在float的标签样式控制中加入\n```\n_display:inline;\n```\n将其转化为行内属性。(_这个符号只有ie6会识别)\n\n### 上下margin重合问题\n\nie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。\n解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。\n\n### 图片默认有间距\n\n使用float属性为img布局,因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以尽量不要使用。）\n\n### 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度\n\n给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。\n\n### 行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug\n\n在display:block;后面加入display:inline;display:table.行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。","source":"_posts/broswer.md","raw":"---\ntitle: 常见的浏览器兼容问题\ncategories:  面试\ntags: \n- interview\n---\n\n## 浏览器兼容问题\n\n\n\n###  不同浏览器的标签默认的外补丁和内补丁不同\n\n 这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。\n\n ```javascript\n *{margin:0;padding:0;}\n ```\n\n ###  图片处理问题\n\n png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.\n\n ### IE6双边距bug\n\n 块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）\n 解决方案是在float的标签样式控制中加入\n```\n_display:inline;\n```\n将其转化为行内属性。(_这个符号只有ie6会识别)\n\n### 上下margin重合问题\n\nie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。\n解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。\n\n### 图片默认有间距\n\n使用float属性为img布局,因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以尽量不要使用。）\n\n### 设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度\n\n给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。\n\n### 行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug\n\n在display:block;后面加入display:inline;display:table.行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。","slug":"broswer","published":1,"date":"2017-09-08T13:14:48.000Z","updated":"2017-09-08T13:14:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4ac60001gvk97dc6vgwj","content":"<h2 id=\"浏览器兼容问题\"><a href=\"#浏览器兼容问题\" class=\"headerlink\" title=\"浏览器兼容问题\"></a>浏览器兼容问题</h2><h3 id=\"不同浏览器的标签默认的外补丁和内补丁不同\"><a href=\"#不同浏览器的标签默认的外补丁和内补丁不同\" class=\"headerlink\" title=\"不同浏览器的标签默认的外补丁和内补丁不同\"></a>不同浏览器的标签默认的外补丁和内补丁不同</h3><p> 这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;<span class=\"attr\">margin</span>:<span class=\"number\">0</span>;padding:<span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"图片处理问题\"><a href=\"#图片处理问题\" class=\"headerlink\" title=\"图片处理问题\"></a>图片处理问题</h3><p> png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</p>\n<h3 id=\"IE6双边距bug\"><a href=\"#IE6双边距bug\" class=\"headerlink\" title=\"IE6双边距bug\"></a>IE6双边距bug</h3><p> 块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br> 解决方案是在float的标签样式控制中加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_display:inline;</span><br></pre></td></tr></table></figure></p>\n<p>将其转化为行内属性。(_这个符号只有ie6会识别)</p>\n<h3 id=\"上下margin重合问题\"><a href=\"#上下margin重合问题\" class=\"headerlink\" title=\"上下margin重合问题\"></a>上下margin重合问题</h3><p>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>\n<h3 id=\"图片默认有间距\"><a href=\"#图片默认有间距\" class=\"headerlink\" title=\"图片默认有间距\"></a>图片默认有间距</h3><p>使用float属性为img布局,因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以尽量不要使用。）</p>\n<h3 id=\"设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度\"><a href=\"#设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度\" class=\"headerlink\" title=\"设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度\"></a>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度</h3><p>给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。</p>\n<h3 id=\"行内属性标签，设置display-block后采用float布局，又有横行的margin的情况，IE6间距bug\"><a href=\"#行内属性标签，设置display-block后采用float布局，又有横行的margin的情况，IE6间距bug\" class=\"headerlink\" title=\"行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug\"></a>行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug</h3><p>在display:block;后面加入display:inline;display:table.行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"浏览器兼容问题\"><a href=\"#浏览器兼容问题\" class=\"headerlink\" title=\"浏览器兼容问题\"></a>浏览器兼容问题</h2><h3 id=\"不同浏览器的标签默认的外补丁和内补丁不同\"><a href=\"#不同浏览器的标签默认的外补丁和内补丁不同\" class=\"headerlink\" title=\"不同浏览器的标签默认的外补丁和内补丁不同\"></a>不同浏览器的标签默认的外补丁和内补丁不同</h3><p> 这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的CSS文件开头都会用通配符*来设置各个标签的内外补丁是0。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*&#123;<span class=\"attr\">margin</span>:<span class=\"number\">0</span>;padding:<span class=\"number\">0</span>;&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"图片处理问题\"><a href=\"#图片处理问题\" class=\"headerlink\" title=\"图片处理问题\"></a>图片处理问题</h3><p> png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理.</p>\n<h3 id=\"IE6双边距bug\"><a href=\"#IE6双边距bug\" class=\"headerlink\" title=\"IE6双边距bug\"></a>IE6双边距bug</h3><p> 块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）<br> 解决方案是在float的标签样式控制中加入<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_display:inline;</span><br></pre></td></tr></table></figure></p>\n<p>将其转化为行内属性。(_这个符号只有ie6会识别)</p>\n<h3 id=\"上下margin重合问题\"><a href=\"#上下margin重合问题\" class=\"headerlink\" title=\"上下margin重合问题\"></a>上下margin重合问题</h3><p>ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。<br>解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。</p>\n<h3 id=\"图片默认有间距\"><a href=\"#图片默认有间距\" class=\"headerlink\" title=\"图片默认有间距\"></a>图片默认有间距</h3><p>使用float属性为img布局,因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道。（使用负margin，虽然能解决，但负margin本身就是容易引起浏览器兼容问题的用法，所以尽量不要使用。）</p>\n<h3 id=\"设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度\"><a href=\"#设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度\" class=\"headerlink\" title=\"设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度\"></a>设置较小高度标签（一般小于10px），在IE6，IE7中高度超出自己设置高度</h3><p>给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是IE8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。</p>\n<h3 id=\"行内属性标签，设置display-block后采用float布局，又有横行的margin的情况，IE6间距bug\"><a href=\"#行内属性标签，设置display-block后采用float布局，又有横行的margin的情况，IE6间距bug\" class=\"headerlink\" title=\"行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug\"></a>行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，IE6间距bug</h3><p>在display:block;后面加入display:inline;display:table.行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在IE6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。</p>\n"},{"title":"docker 的前端持续集成开发环境","_content":"\n## 准备\n\n  1. 注册DaoCloud账号 \n  \n  2. 使用DaoCloud Service\n  \n  3. 将vue.js项目push到Github\n\n## 目的\n\n 1. 代码无需在本地构建\n\n 2. 只需将代码推上 Github ，自动构建 -> 部署\n\n 3. 版本易管理，可轻松回退版本\n \n\n## 步骤\n\n### 1.基于vue.js的前端项目（例：使用vue-cli）\n### 2. 在项目根目录下编 Dockerfile\n```\n\t FROM node:6.10.3-slim\n    RUN apt-get update \\    && apt-get install -y nginx\n    WORKDIR /app\n    COPY . /app/\n    EXPOSE 80\n    RUN  npm install \\     && npm run build \\     && cp -r dist/* /var/www/html \\     && rm -rf /app\n    CMD [\"nginx\",\"-g\",\"daemon off;\"]\n\n```\n### 3.使用 DaoCloud Service搭建 Devops 流程\n* 授权DaoCloud Service可以访问github账号\n* 在 Devops 项目中新建一个项目，并选择 Github 中对应刚才新创建的项目\n* 先手动构建一个镜像版本，便于用这个镜像版本创建一个应用\n* 连接自有主机（没有自有主机的，也可以使用云端测试环境，主机需要安装docker，将服务开启service docker start）\n* 创建应用，进入【镜像仓库】选择刚才手动构建出来的镜像，并部署最新版本到自由主机或者云端测试环境\n* 部署应用\n* 等待镜像拉取成功，容器UP后即可访问vue项目\n* 使用自动构建流程，自动发布任务\n* 触发行为可以设置为branch及tag两种模式，当本地push更新后的代码，dcs将自动部署上线\n* 完成啦！！！","source":"_posts/docker-push.md","raw":"---\ntitle: docker 的前端持续集成开发环境\ncategories:  docker\ntags: \n- docker\n---\n\n## 准备\n\n  1. 注册DaoCloud账号 \n  \n  2. 使用DaoCloud Service\n  \n  3. 将vue.js项目push到Github\n\n## 目的\n\n 1. 代码无需在本地构建\n\n 2. 只需将代码推上 Github ，自动构建 -> 部署\n\n 3. 版本易管理，可轻松回退版本\n \n\n## 步骤\n\n### 1.基于vue.js的前端项目（例：使用vue-cli）\n### 2. 在项目根目录下编 Dockerfile\n```\n\t FROM node:6.10.3-slim\n    RUN apt-get update \\    && apt-get install -y nginx\n    WORKDIR /app\n    COPY . /app/\n    EXPOSE 80\n    RUN  npm install \\     && npm run build \\     && cp -r dist/* /var/www/html \\     && rm -rf /app\n    CMD [\"nginx\",\"-g\",\"daemon off;\"]\n\n```\n### 3.使用 DaoCloud Service搭建 Devops 流程\n* 授权DaoCloud Service可以访问github账号\n* 在 Devops 项目中新建一个项目，并选择 Github 中对应刚才新创建的项目\n* 先手动构建一个镜像版本，便于用这个镜像版本创建一个应用\n* 连接自有主机（没有自有主机的，也可以使用云端测试环境，主机需要安装docker，将服务开启service docker start）\n* 创建应用，进入【镜像仓库】选择刚才手动构建出来的镜像，并部署最新版本到自由主机或者云端测试环境\n* 部署应用\n* 等待镜像拉取成功，容器UP后即可访问vue项目\n* 使用自动构建流程，自动发布任务\n* 触发行为可以设置为branch及tag两种模式，当本地push更新后的代码，dcs将自动部署上线\n* 完成啦！！！","slug":"docker-push","published":1,"date":"2018-03-14T11:15:32.000Z","updated":"2018-03-14T11:15:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4ac80002gvk9xzg78d0t","content":"<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><ol>\n<li><p>注册DaoCloud账号 </p>\n</li>\n<li><p>使用DaoCloud Service</p>\n</li>\n<li><p>将vue.js项目push到Github</p>\n</li>\n</ol>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><ol>\n<li><p>代码无需在本地构建</p>\n</li>\n<li><p>只需将代码推上 Github ，自动构建 -&gt; 部署</p>\n</li>\n<li><p>版本易管理，可轻松回退版本</p>\n</li>\n</ol>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"1-基于vue-js的前端项目（例：使用vue-cli）\"><a href=\"#1-基于vue-js的前端项目（例：使用vue-cli）\" class=\"headerlink\" title=\"1.基于vue.js的前端项目（例：使用vue-cli）\"></a>1.基于vue.js的前端项目（例：使用vue-cli）</h3><h3 id=\"2-在项目根目录下编-Dockerfile\"><a href=\"#2-在项目根目录下编-Dockerfile\" class=\"headerlink\" title=\"2. 在项目根目录下编 Dockerfile\"></a>2. 在项目根目录下编 Dockerfile</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM node:6.10.3-slim</span><br><span class=\"line\">  RUN apt-get update \\    &amp;&amp; apt-get install -y nginx</span><br><span class=\"line\">  WORKDIR /app</span><br><span class=\"line\">  COPY . /app/</span><br><span class=\"line\">  EXPOSE 80</span><br><span class=\"line\">  RUN  npm install \\     &amp;&amp; npm run build \\     &amp;&amp; cp -r dist/* /var/www/html \\     &amp;&amp; rm -rf /app</span><br><span class=\"line\">  CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-使用-DaoCloud-Service搭建-Devops-流程\"><a href=\"#3-使用-DaoCloud-Service搭建-Devops-流程\" class=\"headerlink\" title=\"3.使用 DaoCloud Service搭建 Devops 流程\"></a>3.使用 DaoCloud Service搭建 Devops 流程</h3><ul>\n<li>授权DaoCloud Service可以访问github账号</li>\n<li>在 Devops 项目中新建一个项目，并选择 Github 中对应刚才新创建的项目</li>\n<li>先手动构建一个镜像版本，便于用这个镜像版本创建一个应用</li>\n<li>连接自有主机（没有自有主机的，也可以使用云端测试环境，主机需要安装docker，将服务开启service docker start）</li>\n<li>创建应用，进入【镜像仓库】选择刚才手动构建出来的镜像，并部署最新版本到自由主机或者云端测试环境</li>\n<li>部署应用</li>\n<li>等待镜像拉取成功，容器UP后即可访问vue项目</li>\n<li>使用自动构建流程，自动发布任务</li>\n<li>触发行为可以设置为branch及tag两种模式，当本地push更新后的代码，dcs将自动部署上线</li>\n<li>完成啦！！！</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><ol>\n<li><p>注册DaoCloud账号 </p>\n</li>\n<li><p>使用DaoCloud Service</p>\n</li>\n<li><p>将vue.js项目push到Github</p>\n</li>\n</ol>\n<h2 id=\"目的\"><a href=\"#目的\" class=\"headerlink\" title=\"目的\"></a>目的</h2><ol>\n<li><p>代码无需在本地构建</p>\n</li>\n<li><p>只需将代码推上 Github ，自动构建 -&gt; 部署</p>\n</li>\n<li><p>版本易管理，可轻松回退版本</p>\n</li>\n</ol>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"1-基于vue-js的前端项目（例：使用vue-cli）\"><a href=\"#1-基于vue-js的前端项目（例：使用vue-cli）\" class=\"headerlink\" title=\"1.基于vue.js的前端项目（例：使用vue-cli）\"></a>1.基于vue.js的前端项目（例：使用vue-cli）</h3><h3 id=\"2-在项目根目录下编-Dockerfile\"><a href=\"#2-在项目根目录下编-Dockerfile\" class=\"headerlink\" title=\"2. 在项目根目录下编 Dockerfile\"></a>2. 在项目根目录下编 Dockerfile</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM node:6.10.3-slim</span><br><span class=\"line\">  RUN apt-get update \\    &amp;&amp; apt-get install -y nginx</span><br><span class=\"line\">  WORKDIR /app</span><br><span class=\"line\">  COPY . /app/</span><br><span class=\"line\">  EXPOSE 80</span><br><span class=\"line\">  RUN  npm install \\     &amp;&amp; npm run build \\     &amp;&amp; cp -r dist/* /var/www/html \\     &amp;&amp; rm -rf /app</span><br><span class=\"line\">  CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</span><br></pre></td></tr></table></figure>\n<h3 id=\"3-使用-DaoCloud-Service搭建-Devops-流程\"><a href=\"#3-使用-DaoCloud-Service搭建-Devops-流程\" class=\"headerlink\" title=\"3.使用 DaoCloud Service搭建 Devops 流程\"></a>3.使用 DaoCloud Service搭建 Devops 流程</h3><ul>\n<li>授权DaoCloud Service可以访问github账号</li>\n<li>在 Devops 项目中新建一个项目，并选择 Github 中对应刚才新创建的项目</li>\n<li>先手动构建一个镜像版本，便于用这个镜像版本创建一个应用</li>\n<li>连接自有主机（没有自有主机的，也可以使用云端测试环境，主机需要安装docker，将服务开启service docker start）</li>\n<li>创建应用，进入【镜像仓库】选择刚才手动构建出来的镜像，并部署最新版本到自由主机或者云端测试环境</li>\n<li>部署应用</li>\n<li>等待镜像拉取成功，容器UP后即可访问vue项目</li>\n<li>使用自动构建流程，自动发布任务</li>\n<li>触发行为可以设置为branch及tag两种模式，当本地push更新后的代码，dcs将自动部署上线</li>\n<li>完成啦！！！</li>\n</ul>\n"},{"title":"理解14道Javascript Quiz","_content":"\n\n```javascript\n(function(){\n    return typeof arguments;\n})();\n```\n答案： \"object\"\n> arguments 是对象，虽然像数组.就算是数组，typeof 返回的也是 \"object\" \n\n<br/>\n<br/>\n\n```javascript\nvar f = function g(){ return 23; };\ntypeof g();\n```\n答案：Error.\n>  g 未定义。在 JS 里，声明函数只有 2 种方法：第 1 种： function foo(){...}  （函数声明）第 2 种： var foo = function(){...}   （等号后面必须是匿名函数，这句实质是函数表达式）除此之外，类似于 var foo = function bar(){...} 这样的东西统一按 2 方法处理，即在函数外部无法通过 bar 访问到函数，因为这已经变成了一个表达式。此处g是函数名,然而第一行不是一个函数声明,因此函数名g仅能在该函数内部被访问到\n\n<br/>\n<br/>\n\n```javascript\n(function(x){\n    delete x;\n    return x;\n})(1);\n```\n答案：1\n> delete 操作符用于删除对象的成员变量，不能删除函数的参数及变量。\n\n<br/>\n<br/>\n\n\n```javascript\n  var y = 1, x = y = typeof x;\n  x;\n```\n答案：\"undefined\"\n> 先定义了 y 并赋值为 1，然后将 typeof x 赋值给 y ，此时 x 未定义，故为 \"undefined\"，最后将 y 的值赋给 x\n\n<br/>\n<br/>\n\n```javascript\n(function f(f){\n    return typeof f();\n})(function(){ return 1; });\n```\n答案：\"number\"\n> 在函数里的 f() 其实是参数的那个 f 的执行结果，所以是 typeof 1，也就是 \"number\"\n\n<br/>\n<br/>\n\n```javascript\nvar foo = {\n    bar: function() { return this.baz; },\n    baz: 1\n  };\n  (function(){\n    return typeof arguments[0]();\n  })(foo.bar);\n```\n答案：\"undefined\"\n> 这里的 this 指的是 arguments\n\n<br/>\n<br/>\n\n```javascript\nvar foo = {\n    bar: function(){ return this.baz; },\n    baz: 1\n  }\n  typeof (f = foo.bar)();\n```\n答案：\"undefined\"\n> 因为CallExpression是不带有上下文信息，this会指向global；当你以foo.bar() 调用时，被调用的function是「MemberExpression」，而如果进行了f=foo.bar()赋值之后，那么function就会变成「CallExpression」了，因此this绑定就失效了\n\n<br/>\n<br/>\n\n```javascript\n var f = (function f(){ return \"1\"; }, function g(){ return 2; })();\n  typeof f;\n```\n答案：\"number\"\n> 只有最后面的函数会被执行。逗号操作符多用于声明多个变量，逗号操作符还可以用于赋值，在用于赋值时，逗号操作符总会返回表达式的最后一项，例如： var num = (5,1,4,8,0); //num的值为0\n\n<br/>\n<br/>\n\n```javascript\n  var x = 1;\n  if (function f(){}) {\n    x += typeof f;\n  }\n  x;\n```\n答案：\"1undefined\"\n> 括号内的 function f(){} 不是函数声明，会被转换成 true ，因此 f 未定义。if语句的判断部分内是一个函数f,转化为布尔值为真。(只有\"\"(空字符串)、0、NaN、null、undefined的布尔值是false).这段代码里的function f(){}并不是函数声明。而是函数表达式。因此全局内并无f这个标识符，代码相当于  \n```javascript\nvar x = 1;\nif(true) {\n    x=1+'undefined';\n}\nx;\n```\n\n<br/>\n<br/>\n\n```javascript\n var x = [typeof x, typeof y][1];\n  typeof typeof x;\n```\n答案：\"string\"\n> 第一行执行完后 x === \"undefined\" ，所以连续求 2 次 typeof 还是 \"string\"\n\n\n<br/>\n<br/>\n\n\n```javascript\n  (function(foo){\n    return typeof foo.bar;\n  })({ foo: { bar: 1 } });\n```\n答案：\"undefined\"\n> typeof foo.bar 中的 foo 是参数\n\n<br/>\n<br/>\n\n\n\n```javascript\n(function f(){\n    function f(){ return 1; }\n    return f();\n    function f(){ return 2; }\n  })();\n```\n答案：2\n> 由于声明提前，后面的 f() 会覆盖前面的 f()\n\n<br/>\n<br/>\n\n\n```javascript\nfunction f(){ return f; }\nnew f() instanceof f;\n```\n答案：false\n> 构造函数不需要显式声明返回值，默认返回this值。当显式声明了返回值时，如果返回值是非对象（数字、字符串等），这个返回值会被忽略，继续返回this值。但是如果返回值是对象，那么这个显式返回值会被返回。因为 f() 内部返回了自己，故此时 new f() 的结果和 f 相等。\n\n<br/>\n<br/>\n\n```javascript\nwith (function(x, undefined){}) length;\n```\n答案：2\n> with 限定了作用域是这个函数，而一个函数对象的length属性是该函数的形参个数，function.length 返回函数的参数个数，所以是 2。undefined 虽然是关键词，但可以被覆写。但 null 不能。","source":"_posts/javascript-quiz.md","raw":"---\ntitle: 理解14道Javascript Quiz \ncategories:  javascript\ntags: \n- test\n---\n\n\n```javascript\n(function(){\n    return typeof arguments;\n})();\n```\n答案： \"object\"\n> arguments 是对象，虽然像数组.就算是数组，typeof 返回的也是 \"object\" \n\n<br/>\n<br/>\n\n```javascript\nvar f = function g(){ return 23; };\ntypeof g();\n```\n答案：Error.\n>  g 未定义。在 JS 里，声明函数只有 2 种方法：第 1 种： function foo(){...}  （函数声明）第 2 种： var foo = function(){...}   （等号后面必须是匿名函数，这句实质是函数表达式）除此之外，类似于 var foo = function bar(){...} 这样的东西统一按 2 方法处理，即在函数外部无法通过 bar 访问到函数，因为这已经变成了一个表达式。此处g是函数名,然而第一行不是一个函数声明,因此函数名g仅能在该函数内部被访问到\n\n<br/>\n<br/>\n\n```javascript\n(function(x){\n    delete x;\n    return x;\n})(1);\n```\n答案：1\n> delete 操作符用于删除对象的成员变量，不能删除函数的参数及变量。\n\n<br/>\n<br/>\n\n\n```javascript\n  var y = 1, x = y = typeof x;\n  x;\n```\n答案：\"undefined\"\n> 先定义了 y 并赋值为 1，然后将 typeof x 赋值给 y ，此时 x 未定义，故为 \"undefined\"，最后将 y 的值赋给 x\n\n<br/>\n<br/>\n\n```javascript\n(function f(f){\n    return typeof f();\n})(function(){ return 1; });\n```\n答案：\"number\"\n> 在函数里的 f() 其实是参数的那个 f 的执行结果，所以是 typeof 1，也就是 \"number\"\n\n<br/>\n<br/>\n\n```javascript\nvar foo = {\n    bar: function() { return this.baz; },\n    baz: 1\n  };\n  (function(){\n    return typeof arguments[0]();\n  })(foo.bar);\n```\n答案：\"undefined\"\n> 这里的 this 指的是 arguments\n\n<br/>\n<br/>\n\n```javascript\nvar foo = {\n    bar: function(){ return this.baz; },\n    baz: 1\n  }\n  typeof (f = foo.bar)();\n```\n答案：\"undefined\"\n> 因为CallExpression是不带有上下文信息，this会指向global；当你以foo.bar() 调用时，被调用的function是「MemberExpression」，而如果进行了f=foo.bar()赋值之后，那么function就会变成「CallExpression」了，因此this绑定就失效了\n\n<br/>\n<br/>\n\n```javascript\n var f = (function f(){ return \"1\"; }, function g(){ return 2; })();\n  typeof f;\n```\n答案：\"number\"\n> 只有最后面的函数会被执行。逗号操作符多用于声明多个变量，逗号操作符还可以用于赋值，在用于赋值时，逗号操作符总会返回表达式的最后一项，例如： var num = (5,1,4,8,0); //num的值为0\n\n<br/>\n<br/>\n\n```javascript\n  var x = 1;\n  if (function f(){}) {\n    x += typeof f;\n  }\n  x;\n```\n答案：\"1undefined\"\n> 括号内的 function f(){} 不是函数声明，会被转换成 true ，因此 f 未定义。if语句的判断部分内是一个函数f,转化为布尔值为真。(只有\"\"(空字符串)、0、NaN、null、undefined的布尔值是false).这段代码里的function f(){}并不是函数声明。而是函数表达式。因此全局内并无f这个标识符，代码相当于  \n```javascript\nvar x = 1;\nif(true) {\n    x=1+'undefined';\n}\nx;\n```\n\n<br/>\n<br/>\n\n```javascript\n var x = [typeof x, typeof y][1];\n  typeof typeof x;\n```\n答案：\"string\"\n> 第一行执行完后 x === \"undefined\" ，所以连续求 2 次 typeof 还是 \"string\"\n\n\n<br/>\n<br/>\n\n\n```javascript\n  (function(foo){\n    return typeof foo.bar;\n  })({ foo: { bar: 1 } });\n```\n答案：\"undefined\"\n> typeof foo.bar 中的 foo 是参数\n\n<br/>\n<br/>\n\n\n\n```javascript\n(function f(){\n    function f(){ return 1; }\n    return f();\n    function f(){ return 2; }\n  })();\n```\n答案：2\n> 由于声明提前，后面的 f() 会覆盖前面的 f()\n\n<br/>\n<br/>\n\n\n```javascript\nfunction f(){ return f; }\nnew f() instanceof f;\n```\n答案：false\n> 构造函数不需要显式声明返回值，默认返回this值。当显式声明了返回值时，如果返回值是非对象（数字、字符串等），这个返回值会被忽略，继续返回this值。但是如果返回值是对象，那么这个显式返回值会被返回。因为 f() 内部返回了自己，故此时 new f() 的结果和 f 相等。\n\n<br/>\n<br/>\n\n```javascript\nwith (function(x, undefined){}) length;\n```\n答案：2\n> with 限定了作用域是这个函数，而一个函数对象的length属性是该函数的形参个数，function.length 返回函数的参数个数，所以是 2。undefined 虽然是关键词，但可以被覆写。但 null 不能。","slug":"javascript-quiz","published":1,"date":"2017-09-26T04:10:58.000Z","updated":"2017-09-26T04:10:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4acc0005gvk9uxc26qp9","content":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>答案： “object”</p>\n<blockquote>\n<p>arguments 是对象，虽然像数组.就算是数组，typeof 返回的也是 “object” </p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">23</span>; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> g();</span><br></pre></td></tr></table></figure>\n<p>答案：Error.</p>\n<blockquote>\n<p> g 未定义。在 JS 里，声明函数只有 2 种方法：第 1 种： function foo(){…}  （函数声明）第 2 种： var foo = function(){…}   （等号后面必须是匿名函数，这句实质是函数表达式）除此之外，类似于 var foo = function bar(){…} 这样的东西统一按 2 方法处理，即在函数外部无法通过 bar 访问到函数，因为这已经变成了一个表达式。此处g是函数名,然而第一行不是一个函数声明,因此函数名g仅能在该函数内部被访问到</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;)(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>答案：1</p>\n<blockquote>\n<p>delete 操作符用于删除对象的成员变量，不能删除函数的参数及变量。</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">1</span>, x = y = <span class=\"keyword\">typeof</span> x;</span><br><span class=\"line\">x;</span><br></pre></td></tr></table></figure>\n<p>答案：”undefined”</p>\n<blockquote>\n<p>先定义了 y 并赋值为 1，然后将 typeof x 赋值给 y ，此时 x 未定义，故为 “undefined”，最后将 y 的值赋给 x</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> f();</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<p>答案：”number”</p>\n<blockquote>\n<p>在函数里的 f() 其实是参数的那个 f 的执行结果，所以是 typeof 1，也就是 “number”</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.baz; &#125;,</span><br><span class=\"line\">    baz: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]();</span><br><span class=\"line\">  &#125;)(foo.bar);</span><br></pre></td></tr></table></figure>\n<p>答案：”undefined”</p>\n<blockquote>\n<p>这里的 this 指的是 arguments</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.baz; &#125;,</span><br><span class=\"line\">    baz: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">typeof</span> (f = foo.bar)();</span><br></pre></td></tr></table></figure>\n<p>答案：”undefined”</p>\n<blockquote>\n<p>因为CallExpression是不带有上下文信息，this会指向global；当你以foo.bar() 调用时，被调用的function是「MemberExpression」，而如果进行了f=foo.bar()赋值之后，那么function就会变成「CallExpression」了，因此this绑定就失效了</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"1\"</span>; &#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>; &#125;)();</span><br><span class=\"line\"> <span class=\"keyword\">typeof</span> f;</span><br></pre></td></tr></table></figure>\n<p>答案：”number”</p>\n<blockquote>\n<p>只有最后面的函数会被执行。逗号操作符多用于声明多个变量，逗号操作符还可以用于赋值，在用于赋值时，逗号操作符总会返回表达式的最后一项，例如： var num = (5,1,4,8,0); //num的值为0</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;) &#123;</span><br><span class=\"line\">  x += <span class=\"keyword\">typeof</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">x;</span><br></pre></td></tr></table></figure>\n<p>答案：”1undefined”</p>\n<blockquote>\n<p>括号内的 function f(){} 不是函数声明，会被转换成 true ，因此 f 未定义。if语句的判断部分内是一个函数f,转化为布尔值为真。(只有””(空字符串)、0、NaN、null、undefined的布尔值是false).这段代码里的function f(){}并不是函数声明。而是函数表达式。因此全局内并无f这个标识符，代码相当于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    x=<span class=\"number\">1</span>+<span class=\"string\">'undefined'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">x;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"keyword\">typeof</span> x, <span class=\"keyword\">typeof</span> y][<span class=\"number\">1</span>];</span><br><span class=\"line\"> <span class=\"keyword\">typeof</span> <span class=\"keyword\">typeof</span> x;</span><br></pre></td></tr></table></figure>\n<p>答案：”string”</p>\n<blockquote>\n<p>第一行执行完后 x === “undefined” ，所以连续求 2 次 typeof 还是 “string”</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">foo</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> foo.bar;</span><br><span class=\"line\">&#125;)(&#123; <span class=\"attr\">foo</span>: &#123; <span class=\"attr\">bar</span>: <span class=\"number\">1</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>\n<p>答案：”undefined”</p>\n<blockquote>\n<p>typeof foo.bar 中的 foo 是参数</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">  &#125;)();</span><br></pre></td></tr></table></figure>\n<p>答案：2</p>\n<blockquote>\n<p>由于声明提前，后面的 f() 会覆盖前面的 f()</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> f; &#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> f() <span class=\"keyword\">instanceof</span> f;</span><br></pre></td></tr></table></figure>\n<p>答案：false</p>\n<blockquote>\n<p>构造函数不需要显式声明返回值，默认返回this值。当显式声明了返回值时，如果返回值是非对象（数字、字符串等），这个返回值会被忽略，继续返回this值。但是如果返回值是对象，那么这个显式返回值会被返回。因为 f() 内部返回了自己，故此时 new f() 的结果和 f 相等。</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, undefined</span>)</span>&#123;&#125;) length;</span><br></pre></td></tr></table></figure>\n<p>答案：2</p>\n<blockquote>\n<p>with 限定了作用域是这个函数，而一个函数对象的length属性是该函数的形参个数，function.length 返回函数的参数个数，所以是 2。undefined 虽然是关键词，但可以被覆写。但 null 不能。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>;</span><br><span class=\"line\">&#125;)();</span><br></pre></td></tr></table></figure>\n<p>答案： “object”</p>\n<blockquote>\n<p>arguments 是对象，虽然像数组.就算是数组，typeof 返回的也是 “object” </p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">23</span>; &#125;;</span><br><span class=\"line\"><span class=\"keyword\">typeof</span> g();</span><br></pre></td></tr></table></figure>\n<p>答案：Error.</p>\n<blockquote>\n<p> g 未定义。在 JS 里，声明函数只有 2 种方法：第 1 种： function foo(){…}  （函数声明）第 2 种： var foo = function(){…}   （等号后面必须是匿名函数，这句实质是函数表达式）除此之外，类似于 var foo = function bar(){…} 这样的东西统一按 2 方法处理，即在函数外部无法通过 bar 访问到函数，因为这已经变成了一个表达式。此处g是函数名,然而第一行不是一个函数声明,因此函数名g仅能在该函数内部被访问到</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">delete</span> x;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> x;</span><br><span class=\"line\">&#125;)(<span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure>\n<p>答案：1</p>\n<blockquote>\n<p>delete 操作符用于删除对象的成员变量，不能删除函数的参数及变量。</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> y = <span class=\"number\">1</span>, x = y = <span class=\"keyword\">typeof</span> x;</span><br><span class=\"line\">x;</span><br></pre></td></tr></table></figure>\n<p>答案：”undefined”</p>\n<blockquote>\n<p>先定义了 y 并赋值为 1，然后将 typeof x 赋值给 y ，此时 x 未定义，故为 “undefined”，最后将 y 的值赋给 x</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">f</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> f();</span><br><span class=\"line\">&#125;)(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;);</span><br></pre></td></tr></table></figure>\n<p>答案：”number”</p>\n<blockquote>\n<p>在函数里的 f() 其实是参数的那个 f 的执行结果，所以是 typeof 1，也就是 “number”</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.baz; &#125;,</span><br><span class=\"line\">    baz: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]();</span><br><span class=\"line\">  &#125;)(foo.bar);</span><br></pre></td></tr></table></figure>\n<p>答案：”undefined”</p>\n<blockquote>\n<p>这里的 this 指的是 arguments</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> foo = &#123;</span><br><span class=\"line\">    bar: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.baz; &#125;,</span><br><span class=\"line\">    baz: <span class=\"number\">1</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">typeof</span> (f = foo.bar)();</span><br></pre></td></tr></table></figure>\n<p>答案：”undefined”</p>\n<blockquote>\n<p>因为CallExpression是不带有上下文信息，this会指向global；当你以foo.bar() 调用时，被调用的function是「MemberExpression」，而如果进行了f=foo.bar()赋值之后，那么function就会变成「CallExpression」了，因此this绑定就失效了</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"string\">\"1\"</span>; &#125;, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">g</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>; &#125;)();</span><br><span class=\"line\"> <span class=\"keyword\">typeof</span> f;</span><br></pre></td></tr></table></figure>\n<p>答案：”number”</p>\n<blockquote>\n<p>只有最后面的函数会被执行。逗号操作符多用于声明多个变量，逗号操作符还可以用于赋值，在用于赋值时，逗号操作符总会返回表达式的最后一项，例如： var num = (5,1,4,8,0); //num的值为0</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;&#125;) &#123;</span><br><span class=\"line\">  x += <span class=\"keyword\">typeof</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">x;</span><br></pre></td></tr></table></figure>\n<p>答案：”1undefined”</p>\n<blockquote>\n<p>括号内的 function f(){} 不是函数声明，会被转换成 true ，因此 f 未定义。if语句的判断部分内是一个函数f,转化为布尔值为真。(只有””(空字符串)、0、NaN、null、undefined的布尔值是false).这段代码里的function f(){}并不是函数声明。而是函数表达式。因此全局内并无f这个标识符，代码相当于<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"literal\">true</span>) &#123;</span><br><span class=\"line\">    x=<span class=\"number\">1</span>+<span class=\"string\">'undefined'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">x;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> x = [<span class=\"keyword\">typeof</span> x, <span class=\"keyword\">typeof</span> y][<span class=\"number\">1</span>];</span><br><span class=\"line\"> <span class=\"keyword\">typeof</span> <span class=\"keyword\">typeof</span> x;</span><br></pre></td></tr></table></figure>\n<p>答案：”string”</p>\n<blockquote>\n<p>第一行执行完后 x === “undefined” ，所以连续求 2 次 typeof 还是 “string”</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">foo</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">typeof</span> foo.bar;</span><br><span class=\"line\">&#125;)(&#123; <span class=\"attr\">foo</span>: &#123; <span class=\"attr\">bar</span>: <span class=\"number\">1</span> &#125; &#125;);</span><br></pre></td></tr></table></figure>\n<p>答案：”undefined”</p>\n<blockquote>\n<p>typeof foo.bar 中的 foo 是参数</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">1</span>; &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f();</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">2</span>; &#125;</span><br><span class=\"line\">  &#125;)();</span><br></pre></td></tr></table></figure>\n<p>答案：2</p>\n<blockquote>\n<p>由于声明提前，后面的 f() 会覆盖前面的 f()</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>)</span>&#123; <span class=\"keyword\">return</span> f; &#125;</span><br><span class=\"line\"><span class=\"keyword\">new</span> f() <span class=\"keyword\">instanceof</span> f;</span><br></pre></td></tr></table></figure>\n<p>答案：false</p>\n<blockquote>\n<p>构造函数不需要显式声明返回值，默认返回this值。当显式声明了返回值时，如果返回值是非对象（数字、字符串等），这个返回值会被忽略，继续返回this值。但是如果返回值是对象，那么这个显式返回值会被返回。因为 f() 内部返回了自己，故此时 new f() 的结果和 f 相等。</p>\n</blockquote>\n<p><br><br><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">x, undefined</span>)</span>&#123;&#125;) length;</span><br></pre></td></tr></table></figure>\n<p>答案：2</p>\n<blockquote>\n<p>with 限定了作用域是这个函数，而一个函数对象的length属性是该函数的形参个数，function.length 返回函数的参数个数，所以是 2。undefined 虽然是关键词，但可以被覆写。但 null 不能。</p>\n</blockquote>\n"},{"title":"Javascript Test","_content":"\n\n\n### 字符串反转，输入一串字符串，包括逗号和句号(, .)，整体反转但单词不反转，包括空格，实现以下效果 \n ```javascript \n 输入 '   hello,world...   '  \n 输出 '    ...world,   hello'\n```\n<br/>\n\n参考：\n```javascript\nfunction test(str) {\n    var arr = []; \n    for(var i = 0; i<str.split(',').length; i++) {\n        var subStr = str.split(',')[i];\n        var length = subStr.lastIndexOf('.')-subStr.indexOf('.')\n        if(length>0) {\n            var first = subStr.indexOf('.')\n            var last = subStr.lastIndexOf('.')\n            subStr = subStr.slice(last+1)+ subStr.slice(first, first+length+1) + subStr.slice(0, first)\n            arr.push(subStr)\n        } else {\n            arr.push(subStr);\n        }\n    }\n    var reStr =arr.reverse().join(',')\n    retun restr\n}\ntest('   hello,world...   ')\n```\n<br/>\n<br/>\n\n### 为了得到一个数的\"相反数\",我们将这个数的数字顺序颠倒,然后再加上原先的数得到\"相反数\"。例如,为了得到1325的\"相反数\",首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1. \n\n ```javascript \n输入例子1:\n1325\n输出例子1:\n6556\n输入例子2:\n100\n输出例子2:\n101\n```\n<br/>\n\n参考： \n```javascript\n   function test(p) {\n        if(1 <= p <= 10^5) {\n            return parseInt(p.toString().split('').reverse().join('')) + p   \n        }\n    }\n    test(100)\n```","source":"_posts/javascript-test.md","raw":"---\ntitle: Javascript Test\ncategories:  javascript\ntags: \n- test\n---\n\n\n\n### 字符串反转，输入一串字符串，包括逗号和句号(, .)，整体反转但单词不反转，包括空格，实现以下效果 \n ```javascript \n 输入 '   hello,world...   '  \n 输出 '    ...world,   hello'\n```\n<br/>\n\n参考：\n```javascript\nfunction test(str) {\n    var arr = []; \n    for(var i = 0; i<str.split(',').length; i++) {\n        var subStr = str.split(',')[i];\n        var length = subStr.lastIndexOf('.')-subStr.indexOf('.')\n        if(length>0) {\n            var first = subStr.indexOf('.')\n            var last = subStr.lastIndexOf('.')\n            subStr = subStr.slice(last+1)+ subStr.slice(first, first+length+1) + subStr.slice(0, first)\n            arr.push(subStr)\n        } else {\n            arr.push(subStr);\n        }\n    }\n    var reStr =arr.reverse().join(',')\n    retun restr\n}\ntest('   hello,world...   ')\n```\n<br/>\n<br/>\n\n### 为了得到一个数的\"相反数\",我们将这个数的数字顺序颠倒,然后再加上原先的数得到\"相反数\"。例如,为了得到1325的\"相反数\",首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1. \n\n ```javascript \n输入例子1:\n1325\n输出例子1:\n6556\n输入例子2:\n100\n输出例子2:\n101\n```\n<br/>\n\n参考： \n```javascript\n   function test(p) {\n        if(1 <= p <= 10^5) {\n            return parseInt(p.toString().split('').reverse().join('')) + p   \n        }\n    }\n    test(100)\n```","slug":"javascript-test","published":1,"date":"2017-09-26T04:10:34.000Z","updated":"2017-09-26T04:10:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4ace0006gvk9xunai8eq","content":"<h3 id=\"字符串反转，输入一串字符串，包括逗号和句号-，整体反转但单词不反转，包括空格，实现以下效果\"><a href=\"#字符串反转，输入一串字符串，包括逗号和句号-，整体反转但单词不反转，包括空格，实现以下效果\" class=\"headerlink\" title=\"字符串反转，输入一串字符串，包括逗号和句号(, .)，整体反转但单词不反转，包括空格，实现以下效果\"></a>字符串反转，输入一串字符串，包括逗号和句号(, .)，整体反转但单词不反转，包括空格，实现以下效果</h3> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入 <span class=\"string\">'   hello,world...   '</span>  </span><br><span class=\"line\">输出 <span class=\"string\">'    ...world,   hello'</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>参考：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i&lt;str.split(<span class=\"string\">','</span>).length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> subStr = str.split(<span class=\"string\">','</span>)[i];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> length = subStr.lastIndexOf(<span class=\"string\">'.'</span>)-subStr.indexOf(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(length&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> first = subStr.indexOf(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">var</span> last = subStr.lastIndexOf(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">            subStr = subStr.slice(last+<span class=\"number\">1</span>)+ subStr.slice(first, first+length+<span class=\"number\">1</span>) + subStr.slice(<span class=\"number\">0</span>, first)</span><br><span class=\"line\">            arr.push(subStr)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            arr.push(subStr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reStr =arr.reverse().join(<span class=\"string\">','</span>)</span><br><span class=\"line\">    retun restr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(<span class=\"string\">'   hello,world...   '</span>)</span><br></pre></td></tr></table></figure></p>\n<p><br><br><br></p>\n<h3 id=\"为了得到一个数的”相反数”-我们将这个数的数字顺序颠倒-然后再加上原先的数得到”相反数”。例如-为了得到1325的”相反数”-首先我们将该数的数字顺序颠倒-我们得到5231-之后再加上原先的数-我们得到5231-1325-6556-如果颠倒之后的数字有前缀零-前缀零将会被忽略。例如n-100-颠倒之后是1\"><a href=\"#为了得到一个数的”相反数”-我们将这个数的数字顺序颠倒-然后再加上原先的数得到”相反数”。例如-为了得到1325的”相反数”-首先我们将该数的数字顺序颠倒-我们得到5231-之后再加上原先的数-我们得到5231-1325-6556-如果颠倒之后的数字有前缀零-前缀零将会被忽略。例如n-100-颠倒之后是1\" class=\"headerlink\" title=\"为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.\"></a>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.</h3> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入例子<span class=\"number\">1</span>:</span><br><span class=\"line\"><span class=\"number\">1325</span></span><br><span class=\"line\">输出例子<span class=\"number\">1</span>:</span><br><span class=\"line\"><span class=\"number\">6556</span></span><br><span class=\"line\">输入例子<span class=\"number\">2</span>:</span><br><span class=\"line\"><span class=\"number\">100</span></span><br><span class=\"line\">输出例子<span class=\"number\">2</span>:</span><br><span class=\"line\"><span class=\"number\">101</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>参考：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(<span class=\"number\">1</span> &lt;= p &lt;= <span class=\"number\">10</span>^<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(p.toString().split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)) + p   </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> test(<span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"字符串反转，输入一串字符串，包括逗号和句号-，整体反转但单词不反转，包括空格，实现以下效果\"><a href=\"#字符串反转，输入一串字符串，包括逗号和句号-，整体反转但单词不反转，包括空格，实现以下效果\" class=\"headerlink\" title=\"字符串反转，输入一串字符串，包括逗号和句号(, .)，整体反转但单词不反转，包括空格，实现以下效果\"></a>字符串反转，输入一串字符串，包括逗号和句号(, .)，整体反转但单词不反转，包括空格，实现以下效果</h3> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入 <span class=\"string\">'   hello,world...   '</span>  </span><br><span class=\"line\">输出 <span class=\"string\">'    ...world,   hello'</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>参考：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">str</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> arr = []; </span><br><span class=\"line\">    <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i&lt;str.split(<span class=\"string\">','</span>).length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> subStr = str.split(<span class=\"string\">','</span>)[i];</span><br><span class=\"line\">        <span class=\"keyword\">var</span> length = subStr.lastIndexOf(<span class=\"string\">'.'</span>)-subStr.indexOf(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(length&gt;<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> first = subStr.indexOf(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">            <span class=\"keyword\">var</span> last = subStr.lastIndexOf(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">            subStr = subStr.slice(last+<span class=\"number\">1</span>)+ subStr.slice(first, first+length+<span class=\"number\">1</span>) + subStr.slice(<span class=\"number\">0</span>, first)</span><br><span class=\"line\">            arr.push(subStr)</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            arr.push(subStr);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> reStr =arr.reverse().join(<span class=\"string\">','</span>)</span><br><span class=\"line\">    retun restr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test(<span class=\"string\">'   hello,world...   '</span>)</span><br></pre></td></tr></table></figure></p>\n<p><br><br><br></p>\n<h3 id=\"为了得到一个数的”相反数”-我们将这个数的数字顺序颠倒-然后再加上原先的数得到”相反数”。例如-为了得到1325的”相反数”-首先我们将该数的数字顺序颠倒-我们得到5231-之后再加上原先的数-我们得到5231-1325-6556-如果颠倒之后的数字有前缀零-前缀零将会被忽略。例如n-100-颠倒之后是1\"><a href=\"#为了得到一个数的”相反数”-我们将这个数的数字顺序颠倒-然后再加上原先的数得到”相反数”。例如-为了得到1325的”相反数”-首先我们将该数的数字顺序颠倒-我们得到5231-之后再加上原先的数-我们得到5231-1325-6556-如果颠倒之后的数字有前缀零-前缀零将会被忽略。例如n-100-颠倒之后是1\" class=\"headerlink\" title=\"为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.\"></a>为了得到一个数的”相反数”,我们将这个数的数字顺序颠倒,然后再加上原先的数得到”相反数”。例如,为了得到1325的”相反数”,首先我们将该数的数字顺序颠倒,我们得到5231,之后再加上原先的数,我们得到5231+1325=6556.如果颠倒之后的数字有前缀零,前缀零将会被忽略。例如n = 100, 颠倒之后是1.</h3> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">输入例子<span class=\"number\">1</span>:</span><br><span class=\"line\"><span class=\"number\">1325</span></span><br><span class=\"line\">输出例子<span class=\"number\">1</span>:</span><br><span class=\"line\"><span class=\"number\">6556</span></span><br><span class=\"line\">输入例子<span class=\"number\">2</span>:</span><br><span class=\"line\"><span class=\"number\">100</span></span><br><span class=\"line\">输出例子<span class=\"number\">2</span>:</span><br><span class=\"line\"><span class=\"number\">101</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>参考：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">test</span>(<span class=\"params\">p</span>) </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span>(<span class=\"number\">1</span> &lt;= p &lt;= <span class=\"number\">10</span>^<span class=\"number\">5</span>) &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"built_in\">parseInt</span>(p.toString().split(<span class=\"string\">''</span>).reverse().join(<span class=\"string\">''</span>)) + p   </span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"> test(<span class=\"number\">100</span>)</span><br></pre></td></tr></table></figure></p>\n"},{"title":"图片延迟加载","_content":"\n## js实现图片延迟加载\n\n###  图片延迟加载的目的\n> 延迟加载图片，解决首屏快速加载的问题，网页打开的速度是第一要素,加载html时会去解析img的src,http请求下载图片，会阻塞页面加载。主要目的是作为服务器前端的优化，减少请求数或延迟请求数，对服务器缓压\n\n###  延迟加载的实现\n\nWeb图片的懒加载就是通过读取img元素，然后获得img元素的origin-src（也可以约定为其他属性名）属性的值，并赋予img的src，从而实现动态加载图片的机制\n\n#### HTML约定\n```javascript\n <div class=\"container\">\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img1.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img2.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img3.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img4.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img5.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img6.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img7.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img8.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img9.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img10.png\"></div>\n    </div>\n```\n\n\n### javascript实现\n> data-src\n```javascript\n    window.onload = checkImgs\n    window.onscroll = throttle(checkImgs)\n    // 页面加载完成 检查一下图片，如果图片在第一屏，显示出来\n    function checkImgs () {\n        console.log(Array.from(imgs).entries())\n        for (let [i,img] of Array.from(imgs).entries()) {\n            // console.log(i)\n            \n            if (isInSight(img)) {\n                loadImg(img)\n            }\n        }\n    }\n\n    // 滚动 浏览器是个窗口 viewport 对应的网页内容发生变化 scrollTop\n    // 检测， 我们滚过的那块区域  是否有还未显示的图片\n    function isInSight (el) {\n        const bound = el.getBoundingClientRect()\n        const clientHeight = window.innerHeight\n        console.log(bound, clientHeight)\n        // alert(bound.top);\n        // alert(clientHeight);\n        return bound.top <= clientHeight + 100\n    }\n\n     function loadImg (el) {\n        const src = el.dataset.src\n        if (src !== el.src) {\n            const source = src\n            // alert(source)\n            let img = document.createElement('img')\n            img.onload = function() {\n                el.src = source\n            }\n            img.src = source\n            \n        }\n    }\n\n    // throttle 节流,不要执行的太频繁\n    // 高阶函数的应用场景 增强了函数的功能\n    function throttle (fn, mustRun = 500) {\n        const timer = null\n        let previous = null\n        return function () {\n            const now = new Date()\n            const that = this\n            const args = arguments\n            if(!previous) {\n                previous = now\n            }\n            const remaining = now - previous\n            if (mustRun && remaining >= mustRun) {\n                fn.apply(that, args)\n                previous = now\n            }\n        }\n    }\n\n```\n### jquery实现\n> data-original\n```javascript\n    <script src=\"http://cdn.bootcss.com/jquery/2.1.0/jquery.min.js\"></script>\n    <script src=\"http://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js\"></script> //顺序不可颠倒\n    $(function() { \n        $(\".lazyimg\").lazyload({ \n            placeholder: '',\n            effect : \"fadeIn\",\n            threshold: 200\n        }); \n    }); \n```","source":"_posts/lazy_img.md","raw":"---\ntitle: 图片延迟加载\ncategories:  js\ntags: \n- js\n---\n\n## js实现图片延迟加载\n\n###  图片延迟加载的目的\n> 延迟加载图片，解决首屏快速加载的问题，网页打开的速度是第一要素,加载html时会去解析img的src,http请求下载图片，会阻塞页面加载。主要目的是作为服务器前端的优化，减少请求数或延迟请求数，对服务器缓压\n\n###  延迟加载的实现\n\nWeb图片的懒加载就是通过读取img元素，然后获得img元素的origin-src（也可以约定为其他属性名）属性的值，并赋予img的src，从而实现动态加载图片的机制\n\n#### HTML约定\n```javascript\n <div class=\"container\">\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img1.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img2.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img3.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img4.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img5.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img6.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img7.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img8.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img9.png\"></div>\n        <div class=\"img-area\"><img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img10.png\"></div>\n    </div>\n```\n\n\n### javascript实现\n> data-src\n```javascript\n    window.onload = checkImgs\n    window.onscroll = throttle(checkImgs)\n    // 页面加载完成 检查一下图片，如果图片在第一屏，显示出来\n    function checkImgs () {\n        console.log(Array.from(imgs).entries())\n        for (let [i,img] of Array.from(imgs).entries()) {\n            // console.log(i)\n            \n            if (isInSight(img)) {\n                loadImg(img)\n            }\n        }\n    }\n\n    // 滚动 浏览器是个窗口 viewport 对应的网页内容发生变化 scrollTop\n    // 检测， 我们滚过的那块区域  是否有还未显示的图片\n    function isInSight (el) {\n        const bound = el.getBoundingClientRect()\n        const clientHeight = window.innerHeight\n        console.log(bound, clientHeight)\n        // alert(bound.top);\n        // alert(clientHeight);\n        return bound.top <= clientHeight + 100\n    }\n\n     function loadImg (el) {\n        const src = el.dataset.src\n        if (src !== el.src) {\n            const source = src\n            // alert(source)\n            let img = document.createElement('img')\n            img.onload = function() {\n                el.src = source\n            }\n            img.src = source\n            \n        }\n    }\n\n    // throttle 节流,不要执行的太频繁\n    // 高阶函数的应用场景 增强了函数的功能\n    function throttle (fn, mustRun = 500) {\n        const timer = null\n        let previous = null\n        return function () {\n            const now = new Date()\n            const that = this\n            const args = arguments\n            if(!previous) {\n                previous = now\n            }\n            const remaining = now - previous\n            if (mustRun && remaining >= mustRun) {\n                fn.apply(that, args)\n                previous = now\n            }\n        }\n    }\n\n```\n### jquery实现\n> data-original\n```javascript\n    <script src=\"http://cdn.bootcss.com/jquery/2.1.0/jquery.min.js\"></script>\n    <script src=\"http://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js\"></script> //顺序不可颠倒\n    $(function() { \n        $(\".lazyimg\").lazyload({ \n            placeholder: '',\n            effect : \"fadeIn\",\n            threshold: 200\n        }); \n    }); \n```","slug":"lazy_img","published":1,"date":"2017-08-22T13:18:48.000Z","updated":"2017-08-22T13:18:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4acg0007gvk9667kz5iu","content":"<h2 id=\"js实现图片延迟加载\"><a href=\"#js实现图片延迟加载\" class=\"headerlink\" title=\"js实现图片延迟加载\"></a>js实现图片延迟加载</h2><h3 id=\"图片延迟加载的目的\"><a href=\"#图片延迟加载的目的\" class=\"headerlink\" title=\"图片延迟加载的目的\"></a>图片延迟加载的目的</h3><blockquote>\n<p>延迟加载图片，解决首屏快速加载的问题，网页打开的速度是第一要素,加载html时会去解析img的src,http请求下载图片，会阻塞页面加载。主要目的是作为服务器前端的优化，减少请求数或延迟请求数，对服务器缓压</p>\n</blockquote>\n<h3 id=\"延迟加载的实现\"><a href=\"#延迟加载的实现\" class=\"headerlink\" title=\"延迟加载的实现\"></a>延迟加载的实现</h3><p>Web图片的懒加载就是通过读取img元素，然后获得img元素的origin-src（也可以约定为其他属性名）属性的值，并赋予img的src，从而实现动态加载图片的机制</p>\n<h4 id=\"HTML约定\"><a href=\"#HTML约定\" class=\"headerlink\" title=\"HTML约定\"></a>HTML约定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img1.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img2.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img3.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img4.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img5.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img6.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img7.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img8.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img9.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img10.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">   &lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"javascript实现\"><a href=\"#javascript实现\" class=\"headerlink\" title=\"javascript实现\"></a>javascript实现</h3><blockquote>\n<p>data-src<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = checkImgs</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = throttle(checkImgs)</span><br><span class=\"line\"><span class=\"comment\">// 页面加载完成 检查一下图片，如果图片在第一屏，显示出来</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkImgs</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(imgs).entries())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [i,img] <span class=\"keyword\">of</span> <span class=\"built_in\">Array</span>.from(imgs).entries()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// console.log(i)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isInSight(img)) &#123;</span><br><span class=\"line\">            loadImg(img)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 滚动 浏览器是个窗口 viewport 对应的网页内容发生变化 scrollTop</span></span><br><span class=\"line\"><span class=\"comment\">// 检测， 我们滚过的那块区域  是否有还未显示的图片</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isInSight</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> bound = el.getBoundingClientRect()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> clientHeight = <span class=\"built_in\">window</span>.innerHeight</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(bound, clientHeight)</span><br><span class=\"line\">    <span class=\"comment\">// alert(bound.top);</span></span><br><span class=\"line\">    <span class=\"comment\">// alert(clientHeight);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bound.top &lt;= clientHeight + <span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadImg</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> src = el.dataset.src</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (src !== el.src) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> source = src</span><br><span class=\"line\">        <span class=\"comment\">// alert(source)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> img = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'img'</span>)</span><br><span class=\"line\">        img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            el.src = source</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        img.src = source</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// throttle 节流,不要执行的太频繁</span></span><br><span class=\"line\"><span class=\"comment\">// 高阶函数的应用场景 增强了函数的功能</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span> (<span class=\"params\">fn, mustRun = <span class=\"number\">500</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> previous = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">        <span class=\"keyword\">const</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!previous) &#123;</span><br><span class=\"line\">            previous = now</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> remaining = now - previous</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mustRun &amp;&amp; remaining &gt;= mustRun) &#123;</span><br><span class=\"line\">            fn.apply(that, args)</span><br><span class=\"line\">            previous = now</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"jquery实现\"><a href=\"#jquery实现\" class=\"headerlink\" title=\"jquery实现\"></a>jquery实现</h3><blockquote>\n<p>data-original<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"http://cdn.bootcss.com/jquery/2.1.0/jquery.min.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"http://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js\"</span>&gt;&lt;/script&gt; <span class=\"comment\">//顺序不可颠倒</span></span><br><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    $(<span class=\"string\">\".lazyimg\"</span>).lazyload(&#123; </span><br><span class=\"line\">        placeholder: <span class=\"string\">''</span>,</span><br><span class=\"line\">        effect : <span class=\"string\">\"fadeIn\"</span>,</span><br><span class=\"line\">        threshold: <span class=\"number\">200</span></span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"js实现图片延迟加载\"><a href=\"#js实现图片延迟加载\" class=\"headerlink\" title=\"js实现图片延迟加载\"></a>js实现图片延迟加载</h2><h3 id=\"图片延迟加载的目的\"><a href=\"#图片延迟加载的目的\" class=\"headerlink\" title=\"图片延迟加载的目的\"></a>图片延迟加载的目的</h3><blockquote>\n<p>延迟加载图片，解决首屏快速加载的问题，网页打开的速度是第一要素,加载html时会去解析img的src,http请求下载图片，会阻塞页面加载。主要目的是作为服务器前端的优化，减少请求数或延迟请求数，对服务器缓压</p>\n</blockquote>\n<h3 id=\"延迟加载的实现\"><a href=\"#延迟加载的实现\" class=\"headerlink\" title=\"延迟加载的实现\"></a>延迟加载的实现</h3><p>Web图片的懒加载就是通过读取img元素，然后获得img元素的origin-src（也可以约定为其他属性名）属性的值，并赋予img的src，从而实现动态加载图片的机制</p>\n<h4 id=\"HTML约定\"><a href=\"#HTML约定\" class=\"headerlink\" title=\"HTML约定\"></a>HTML约定</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"container\"</span>&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img1.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img2.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img3.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img4.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img5.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img6.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img7.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img8.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img9.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">       &lt;div <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"img-area\"</span>&gt;&lt;img src=\"\" alt=\"loading\" class=\"my-photo lazyimg\" data-original=\"http://axuebin.com/lazyload/img/img10.png\"&gt;&lt;/div&gt;</span><br><span class=\"line\">   &lt;<span class=\"regexp\">/div&gt;</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"javascript实现\"><a href=\"#javascript实现\" class=\"headerlink\" title=\"javascript实现\"></a>javascript实现</h3><blockquote>\n<p>data-src<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.onload = checkImgs</span><br><span class=\"line\"><span class=\"built_in\">window</span>.onscroll = throttle(checkImgs)</span><br><span class=\"line\"><span class=\"comment\">// 页面加载完成 检查一下图片，如果图片在第一屏，显示出来</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">checkImgs</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(imgs).entries())</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> [i,img] <span class=\"keyword\">of</span> <span class=\"built_in\">Array</span>.from(imgs).entries()) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// console.log(i)</span></span><br><span class=\"line\">        </span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isInSight(img)) &#123;</span><br><span class=\"line\">            loadImg(img)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 滚动 浏览器是个窗口 viewport 对应的网页内容发生变化 scrollTop</span></span><br><span class=\"line\"><span class=\"comment\">// 检测， 我们滚过的那块区域  是否有还未显示的图片</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isInSight</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> bound = el.getBoundingClientRect()</span><br><span class=\"line\">    <span class=\"keyword\">const</span> clientHeight = <span class=\"built_in\">window</span>.innerHeight</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(bound, clientHeight)</span><br><span class=\"line\">    <span class=\"comment\">// alert(bound.top);</span></span><br><span class=\"line\">    <span class=\"comment\">// alert(clientHeight);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> bound.top &lt;= clientHeight + <span class=\"number\">100</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">loadImg</span> (<span class=\"params\">el</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> src = el.dataset.src</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (src !== el.src) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> source = src</span><br><span class=\"line\">        <span class=\"comment\">// alert(source)</span></span><br><span class=\"line\">        <span class=\"keyword\">let</span> img = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'img'</span>)</span><br><span class=\"line\">        img.onload = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">            el.src = source</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        img.src = source</span><br><span class=\"line\">        </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// throttle 节流,不要执行的太频繁</span></span><br><span class=\"line\"><span class=\"comment\">// 高阶函数的应用场景 增强了函数的功能</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">throttle</span> (<span class=\"params\">fn, mustRun = <span class=\"number\">500</span></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> timer = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">let</span> previous = <span class=\"literal\">null</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> now = <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()</span><br><span class=\"line\">        <span class=\"keyword\">const</span> that = <span class=\"keyword\">this</span></span><br><span class=\"line\">        <span class=\"keyword\">const</span> args = <span class=\"built_in\">arguments</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!previous) &#123;</span><br><span class=\"line\">            previous = now</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> remaining = now - previous</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mustRun &amp;&amp; remaining &gt;= mustRun) &#123;</span><br><span class=\"line\">            fn.apply(that, args)</span><br><span class=\"line\">            previous = now</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"jquery实现\"><a href=\"#jquery实现\" class=\"headerlink\" title=\"jquery实现\"></a>jquery实现</h3><blockquote>\n<p>data-original<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">\"http://cdn.bootcss.com/jquery/2.1.0/jquery.min.js\"</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script src=<span class=\"string\">\"http://cdn.bootcss.com/jquery_lazyload/1.9.7/jquery.lazyload.min.js\"</span>&gt;&lt;/script&gt; <span class=\"comment\">//顺序不可颠倒</span></span><br><span class=\"line\">$(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123; </span><br><span class=\"line\">    $(<span class=\"string\">\".lazyimg\"</span>).lazyload(&#123; </span><br><span class=\"line\">        placeholder: <span class=\"string\">''</span>,</span><br><span class=\"line\">        effect : <span class=\"string\">\"fadeIn\"</span>,</span><br><span class=\"line\">        threshold: <span class=\"number\">200</span></span><br><span class=\"line\">    &#125;); </span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n"},{"title":"移动端开发-页面样式重置","_content":"\n\n### -webkit-tap-highlight-color:rgba(255,0,0,0.5);\n透明度alpha设置为0，去掉点击链接和文本框对象时默认的灰色半透明覆盖层(iOS)或者虚(Android)\n利用此属性，设置touch时链接区域高亮为50%的透明红，\n只在ios上起作用 android上只要使用了此属性就表现为边框。在body上加此属性，这样就保证body的点击区域效果一致了\n\n###  outline：none\n(1)在pc端为a标签定义这个样式的目的是为了取消ie浏览器下点击a标签时出现的虚线。ie7及以下浏览器还不识别此属性，需要在a标签上添加hidefocus=”true”\n(2)input，textarea{outline:none} 取消chrome下默认的文本框聚焦样式\n(3)在移动端是不起作用的，想要去除文本框的默认样式可以使用-webkit-appearance，聚焦时候默认样式的取消是-webkit-tap-highlight-color。看到一些移动端reset文件加了此属性，其实是多余。\n\n### -webkit-appearance\n -webkit-appearance: none;  //消除输入框和按钮的原生外观，在iOS上加上这个属性才能给按钮和输入框自定义样式 。 注意：不同type的input使用这个属性之后表现不一。text、button无样式，radio、checkbox直接消失\n\n### -webkit-user-select \n-webkit-user-select: none;   // 禁止页面文字选择 ，此属性不继承，一般加在body上规定整个body的文字都不会自动调整\n\n###  -webkit-text-size-adjust \n-webkit-text-size-adjust: none;  //禁止文字自动调整大小(默认情况下旋转设备的时候文字大小会发生变化)，此属性也不继承，一般加在body上规定整个body的文字都不会自动调整\n\n###  -webkit-touch-callout \n-webkit-touch-callout:none;   // 禁用长按页面时的弹出菜单(iOS下有效) ,img和a标签都要加\n\n###  -webkit-overflow-scrolling \n-webkit-overflow-scrolling:touch;    // 局部滚动(仅iOS 5以上支持)","source":"_posts/mobile- optimization.md","raw":"---\ntitle: 移动端开发-页面样式重置\ncategories:  css\ntags: \n- css\n---\n\n\n### -webkit-tap-highlight-color:rgba(255,0,0,0.5);\n透明度alpha设置为0，去掉点击链接和文本框对象时默认的灰色半透明覆盖层(iOS)或者虚(Android)\n利用此属性，设置touch时链接区域高亮为50%的透明红，\n只在ios上起作用 android上只要使用了此属性就表现为边框。在body上加此属性，这样就保证body的点击区域效果一致了\n\n###  outline：none\n(1)在pc端为a标签定义这个样式的目的是为了取消ie浏览器下点击a标签时出现的虚线。ie7及以下浏览器还不识别此属性，需要在a标签上添加hidefocus=”true”\n(2)input，textarea{outline:none} 取消chrome下默认的文本框聚焦样式\n(3)在移动端是不起作用的，想要去除文本框的默认样式可以使用-webkit-appearance，聚焦时候默认样式的取消是-webkit-tap-highlight-color。看到一些移动端reset文件加了此属性，其实是多余。\n\n### -webkit-appearance\n -webkit-appearance: none;  //消除输入框和按钮的原生外观，在iOS上加上这个属性才能给按钮和输入框自定义样式 。 注意：不同type的input使用这个属性之后表现不一。text、button无样式，radio、checkbox直接消失\n\n### -webkit-user-select \n-webkit-user-select: none;   // 禁止页面文字选择 ，此属性不继承，一般加在body上规定整个body的文字都不会自动调整\n\n###  -webkit-text-size-adjust \n-webkit-text-size-adjust: none;  //禁止文字自动调整大小(默认情况下旋转设备的时候文字大小会发生变化)，此属性也不继承，一般加在body上规定整个body的文字都不会自动调整\n\n###  -webkit-touch-callout \n-webkit-touch-callout:none;   // 禁用长按页面时的弹出菜单(iOS下有效) ,img和a标签都要加\n\n###  -webkit-overflow-scrolling \n-webkit-overflow-scrolling:touch;    // 局部滚动(仅iOS 5以上支持)","slug":"mobile- optimization","published":1,"date":"2017-09-25T07:17:32.000Z","updated":"2017-09-25T07:17:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4ack000bgvk9x52jm5u7","content":"<h3 id=\"webkit-tap-highlight-color-rgba-255-0-0-0-5\"><a href=\"#webkit-tap-highlight-color-rgba-255-0-0-0-5\" class=\"headerlink\" title=\"-webkit-tap-highlight-color:rgba(255,0,0,0.5);\"></a>-webkit-tap-highlight-color:rgba(255,0,0,0.5);</h3><p>透明度alpha设置为0，去掉点击链接和文本框对象时默认的灰色半透明覆盖层(iOS)或者虚(Android)<br>利用此属性，设置touch时链接区域高亮为50%的透明红，<br>只在ios上起作用 android上只要使用了此属性就表现为边框。在body上加此属性，这样就保证body的点击区域效果一致了</p>\n<h3 id=\"outline：none\"><a href=\"#outline：none\" class=\"headerlink\" title=\"outline：none\"></a>outline：none</h3><p>(1)在pc端为a标签定义这个样式的目的是为了取消ie浏览器下点击a标签时出现的虚线。ie7及以下浏览器还不识别此属性，需要在a标签上添加hidefocus=”true”<br>(2)input，textarea{outline:none} 取消chrome下默认的文本框聚焦样式<br>(3)在移动端是不起作用的，想要去除文本框的默认样式可以使用-webkit-appearance，聚焦时候默认样式的取消是-webkit-tap-highlight-color。看到一些移动端reset文件加了此属性，其实是多余。</p>\n<h3 id=\"webkit-appearance\"><a href=\"#webkit-appearance\" class=\"headerlink\" title=\"-webkit-appearance\"></a>-webkit-appearance</h3><p> -webkit-appearance: none;  //消除输入框和按钮的原生外观，在iOS上加上这个属性才能给按钮和输入框自定义样式 。 注意：不同type的input使用这个属性之后表现不一。text、button无样式，radio、checkbox直接消失</p>\n<h3 id=\"webkit-user-select\"><a href=\"#webkit-user-select\" class=\"headerlink\" title=\"-webkit-user-select\"></a>-webkit-user-select</h3><p>-webkit-user-select: none;   // 禁止页面文字选择 ，此属性不继承，一般加在body上规定整个body的文字都不会自动调整</p>\n<h3 id=\"webkit-text-size-adjust\"><a href=\"#webkit-text-size-adjust\" class=\"headerlink\" title=\"-webkit-text-size-adjust\"></a>-webkit-text-size-adjust</h3><p>-webkit-text-size-adjust: none;  //禁止文字自动调整大小(默认情况下旋转设备的时候文字大小会发生变化)，此属性也不继承，一般加在body上规定整个body的文字都不会自动调整</p>\n<h3 id=\"webkit-touch-callout\"><a href=\"#webkit-touch-callout\" class=\"headerlink\" title=\"-webkit-touch-callout\"></a>-webkit-touch-callout</h3><p>-webkit-touch-callout:none;   // 禁用长按页面时的弹出菜单(iOS下有效) ,img和a标签都要加</p>\n<h3 id=\"webkit-overflow-scrolling\"><a href=\"#webkit-overflow-scrolling\" class=\"headerlink\" title=\"-webkit-overflow-scrolling\"></a>-webkit-overflow-scrolling</h3><p>-webkit-overflow-scrolling:touch;    // 局部滚动(仅iOS 5以上支持)</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"webkit-tap-highlight-color-rgba-255-0-0-0-5\"><a href=\"#webkit-tap-highlight-color-rgba-255-0-0-0-5\" class=\"headerlink\" title=\"-webkit-tap-highlight-color:rgba(255,0,0,0.5);\"></a>-webkit-tap-highlight-color:rgba(255,0,0,0.5);</h3><p>透明度alpha设置为0，去掉点击链接和文本框对象时默认的灰色半透明覆盖层(iOS)或者虚(Android)<br>利用此属性，设置touch时链接区域高亮为50%的透明红，<br>只在ios上起作用 android上只要使用了此属性就表现为边框。在body上加此属性，这样就保证body的点击区域效果一致了</p>\n<h3 id=\"outline：none\"><a href=\"#outline：none\" class=\"headerlink\" title=\"outline：none\"></a>outline：none</h3><p>(1)在pc端为a标签定义这个样式的目的是为了取消ie浏览器下点击a标签时出现的虚线。ie7及以下浏览器还不识别此属性，需要在a标签上添加hidefocus=”true”<br>(2)input，textarea{outline:none} 取消chrome下默认的文本框聚焦样式<br>(3)在移动端是不起作用的，想要去除文本框的默认样式可以使用-webkit-appearance，聚焦时候默认样式的取消是-webkit-tap-highlight-color。看到一些移动端reset文件加了此属性，其实是多余。</p>\n<h3 id=\"webkit-appearance\"><a href=\"#webkit-appearance\" class=\"headerlink\" title=\"-webkit-appearance\"></a>-webkit-appearance</h3><p> -webkit-appearance: none;  //消除输入框和按钮的原生外观，在iOS上加上这个属性才能给按钮和输入框自定义样式 。 注意：不同type的input使用这个属性之后表现不一。text、button无样式，radio、checkbox直接消失</p>\n<h3 id=\"webkit-user-select\"><a href=\"#webkit-user-select\" class=\"headerlink\" title=\"-webkit-user-select\"></a>-webkit-user-select</h3><p>-webkit-user-select: none;   // 禁止页面文字选择 ，此属性不继承，一般加在body上规定整个body的文字都不会自动调整</p>\n<h3 id=\"webkit-text-size-adjust\"><a href=\"#webkit-text-size-adjust\" class=\"headerlink\" title=\"-webkit-text-size-adjust\"></a>-webkit-text-size-adjust</h3><p>-webkit-text-size-adjust: none;  //禁止文字自动调整大小(默认情况下旋转设备的时候文字大小会发生变化)，此属性也不继承，一般加在body上规定整个body的文字都不会自动调整</p>\n<h3 id=\"webkit-touch-callout\"><a href=\"#webkit-touch-callout\" class=\"headerlink\" title=\"-webkit-touch-callout\"></a>-webkit-touch-callout</h3><p>-webkit-touch-callout:none;   // 禁用长按页面时的弹出菜单(iOS下有效) ,img和a标签都要加</p>\n<h3 id=\"webkit-overflow-scrolling\"><a href=\"#webkit-overflow-scrolling\" class=\"headerlink\" title=\"-webkit-overflow-scrolling\"></a>-webkit-overflow-scrolling</h3><p>-webkit-overflow-scrolling:touch;    // 局部滚动(仅iOS 5以上支持)</p>\n"},{"title":"浅谈Promise","_content":"\n## Promise 简介\n> Promise 对象是用来处理异步操作的工具,解决开发者对异步回调的烦恼。可以说Promise是个代理对象，在设计模式来讲就是代理模式，它代理了一个值（通过resolve方法传递的值），并且设置了几个状态让用户知道当前代理值解析的结果。\n\n## Promise 状态\n\n按照规范，Promise有三种状态：\n\n* pending: 初始状态,未完成或拒绝，可改变状态。\n\n* fulfilled（resolved）: 操作成功完成,不可改变状态,拥有不可变的终值。\n\n* rejected: 操作失败,不可改变状态,拥有不可变的拒因。\n\n## Promise 术语\n\n* 解决（fulfill）：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。\n\n* 拒绝（reject）：指一个 promise 失败时进行的一系列操作。\n\n* 终值（eventual value）：所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。\n\n* 据因（reason）：也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。\n\n## 状态机制切换\n\n状态只能由pengding-->fulfilled，或者由pending-->rejected这样转变。\n\n只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n## 基本API\n>Promise.then()  <br/>\n语法：Promise.prototype.then(onFulfilled, onRejected)\n对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的resolve函数。\n>.catch() <br/>\n语法：Promise.prototype.catch(onRejected)\n该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数。\n>.all() <br/>\n语法：Promise.all(iterable)\n该方法用于将多个Promise实例，包装成一个新的Promise实例。\n\nvar p = Promise.all([p1, p2, p3]);\nPromise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。\n>.race()<br/>\n语法：Promise.race(iterable)\n该方法同样是将多个Promise实例，包装成一个新的Promise实例。\n例如：var p = Promise.race([p1, p2, p3]);\nPromise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。\n\n## Promise常见问题\n* 在异步回调中抛错，不会被catch到\n* promise状态变为resove或reject，就凝固了，不会再改变\n* 如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误\n* reject 和 catch 的区别:\npromise.then(onFulfilled, onRejected) //在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。\npromise.then(onFulfilled).catch(onRejected)  //.then中产生的异常能在.catch中捕获\n\n\n## 手写一个Promise\n\n```javascript\nfunction Promise(callback) {\n  var self = this\n  self.status = 'pending' // Promise当前的状态\n  self.data = undefined  // Promise的值\n  self.onResolvedCallback = [] // Promise resolve时的回调函数集\n  self.onRejectedCallback = [] // Promise reject时的回调函数集\n  callback(resolve, reject) // 执行callback并传入相应的参数\n\n  function resolve(value){\n      if(self.status=='pending'){\n          self.status=='resolved';\n          self.data=value;\n          // 依次执行成功之后的函数栈\n          for(var i = 0; i < self.onResolvedCallback.length; i++) {\n            self.onResolvedCallback[i](value)\n          }\n      }\n  }\n\n  function rejecet(error){\n    if (self.status === 'pending') {\n       self.status = 'rejected'\n       self.data = error;\n       // 依次执行失败之后的函数栈\n       for(var i = 0; i < self.onRejectedCallback.length; i++) {\n           self.onRejectedCallback[i](error)\n        }\n    }\n  }\n}\n\n```\n\n<br/>\n\n接下来我们实现我们的then方法, then方法是Promise的核心, 一个promise的then接受两个参数,首先需要判断参数是否为函数，若不为函数忽略\n\n```javascript\nPromise.prototype.then = function(onResolved, onRejected) {\n  var self = this\n  var promise2\n\n  onResolved = typeof onResolved === 'function' ? onResolved : function(value) {}\n  onRejected = typeof onRejected === 'function' ? onRejected : function(reason) {}\n\n  if (self.status === 'resolved') {\n    return promise2 = new Promise(function(resolve, reject) {\n      try {\n        var x = onResolved(self.data)\n        if (x instanceof Promise) { \n          x.then(resolve, reject)\n        }\n        resolve(x) // 否则，以它的返回值做为promise2的结果\n      } catch (e) {\n        reject(e) // 如果出错，以捕获到的错误做为promise2的结果\n      }\n    })\n  }\n\n  // 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数，就不再做过多解释\n  if (self.status === 'rejected') {\n    return promise2 = new Promise(function(resolve, reject) {\n      try {\n        var x = onRejected(self.data)\n        if (x instanceof Promise) {\n          x.then(resolve, reject)\n        }\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n```\n\n<br/>\n\n\n如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，\n只能等到Promise的状态确定后，才能确实如何处理。\n所以我们需要把我们的两种情况的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里\n逻辑本身跟第一个if块内的几乎一致，此处不做过多解释\n\n<br/>\n\n```javascript\n  if (self.status === 'pending') {\n    return promise2 = new Promise(function(resolve, reject) {\n      self.onResolvedCallback.push(function(value) {\n        try {\n          var x = onResolved(self.data)\n          if (x instanceof Promise) {\n            x.then(resolve, reject)\n          }\n        } catch (e) {\n          reject(e)\n        }\n      })\n\n      self.onRejectedCallback.push(function(reason) {\n        try {\n          var x = onRejected(self.data)\n          if (x instanceof Promise) {\n            x.then(resolve, reject)\n          }\n        } catch (e) {\n          reject(e)\n        }\n      })\n    })\n  }\n}\n```\n\n我们顺便实现一个catch方法\n\n```javascript\nPromise.prototype.catch = function(onRejected) {\n  return this.then(null, onRejected)\n}\n\n```","source":"_posts/promise.md","raw":"---\ntitle: 浅谈Promise\ncategories:  ES6\ntags: \n- JS\n---\n\n## Promise 简介\n> Promise 对象是用来处理异步操作的工具,解决开发者对异步回调的烦恼。可以说Promise是个代理对象，在设计模式来讲就是代理模式，它代理了一个值（通过resolve方法传递的值），并且设置了几个状态让用户知道当前代理值解析的结果。\n\n## Promise 状态\n\n按照规范，Promise有三种状态：\n\n* pending: 初始状态,未完成或拒绝，可改变状态。\n\n* fulfilled（resolved）: 操作成功完成,不可改变状态,拥有不可变的终值。\n\n* rejected: 操作失败,不可改变状态,拥有不可变的拒因。\n\n## Promise 术语\n\n* 解决（fulfill）：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。\n\n* 拒绝（reject）：指一个 promise 失败时进行的一系列操作。\n\n* 终值（eventual value）：所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。\n\n* 据因（reason）：也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。\n\n## 状态机制切换\n\n状态只能由pengding-->fulfilled，或者由pending-->rejected这样转变。\n\n只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。\n\n## 基本API\n>Promise.then()  <br/>\n语法：Promise.prototype.then(onFulfilled, onRejected)\n对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的resolve函数。\n>.catch() <br/>\n语法：Promise.prototype.catch(onRejected)\n该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数。\n>.all() <br/>\n语法：Promise.all(iterable)\n该方法用于将多个Promise实例，包装成一个新的Promise实例。\n\nvar p = Promise.all([p1, p2, p3]);\nPromise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。\n>.race()<br/>\n语法：Promise.race(iterable)\n该方法同样是将多个Promise实例，包装成一个新的Promise实例。\n例如：var p = Promise.race([p1, p2, p3]);\nPromise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。\n\n## Promise常见问题\n* 在异步回调中抛错，不会被catch到\n* promise状态变为resove或reject，就凝固了，不会再改变\n* 如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误\n* reject 和 catch 的区别:\npromise.then(onFulfilled, onRejected) //在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。\npromise.then(onFulfilled).catch(onRejected)  //.then中产生的异常能在.catch中捕获\n\n\n## 手写一个Promise\n\n```javascript\nfunction Promise(callback) {\n  var self = this\n  self.status = 'pending' // Promise当前的状态\n  self.data = undefined  // Promise的值\n  self.onResolvedCallback = [] // Promise resolve时的回调函数集\n  self.onRejectedCallback = [] // Promise reject时的回调函数集\n  callback(resolve, reject) // 执行callback并传入相应的参数\n\n  function resolve(value){\n      if(self.status=='pending'){\n          self.status=='resolved';\n          self.data=value;\n          // 依次执行成功之后的函数栈\n          for(var i = 0; i < self.onResolvedCallback.length; i++) {\n            self.onResolvedCallback[i](value)\n          }\n      }\n  }\n\n  function rejecet(error){\n    if (self.status === 'pending') {\n       self.status = 'rejected'\n       self.data = error;\n       // 依次执行失败之后的函数栈\n       for(var i = 0; i < self.onRejectedCallback.length; i++) {\n           self.onRejectedCallback[i](error)\n        }\n    }\n  }\n}\n\n```\n\n<br/>\n\n接下来我们实现我们的then方法, then方法是Promise的核心, 一个promise的then接受两个参数,首先需要判断参数是否为函数，若不为函数忽略\n\n```javascript\nPromise.prototype.then = function(onResolved, onRejected) {\n  var self = this\n  var promise2\n\n  onResolved = typeof onResolved === 'function' ? onResolved : function(value) {}\n  onRejected = typeof onRejected === 'function' ? onRejected : function(reason) {}\n\n  if (self.status === 'resolved') {\n    return promise2 = new Promise(function(resolve, reject) {\n      try {\n        var x = onResolved(self.data)\n        if (x instanceof Promise) { \n          x.then(resolve, reject)\n        }\n        resolve(x) // 否则，以它的返回值做为promise2的结果\n      } catch (e) {\n        reject(e) // 如果出错，以捕获到的错误做为promise2的结果\n      }\n    })\n  }\n\n  // 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数，就不再做过多解释\n  if (self.status === 'rejected') {\n    return promise2 = new Promise(function(resolve, reject) {\n      try {\n        var x = onRejected(self.data)\n        if (x instanceof Promise) {\n          x.then(resolve, reject)\n        }\n      } catch (e) {\n        reject(e)\n      }\n    })\n  }\n```\n\n<br/>\n\n\n如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，\n只能等到Promise的状态确定后，才能确实如何处理。\n所以我们需要把我们的两种情况的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里\n逻辑本身跟第一个if块内的几乎一致，此处不做过多解释\n\n<br/>\n\n```javascript\n  if (self.status === 'pending') {\n    return promise2 = new Promise(function(resolve, reject) {\n      self.onResolvedCallback.push(function(value) {\n        try {\n          var x = onResolved(self.data)\n          if (x instanceof Promise) {\n            x.then(resolve, reject)\n          }\n        } catch (e) {\n          reject(e)\n        }\n      })\n\n      self.onRejectedCallback.push(function(reason) {\n        try {\n          var x = onRejected(self.data)\n          if (x instanceof Promise) {\n            x.then(resolve, reject)\n          }\n        } catch (e) {\n          reject(e)\n        }\n      })\n    })\n  }\n}\n```\n\n我们顺便实现一个catch方法\n\n```javascript\nPromise.prototype.catch = function(onRejected) {\n  return this.then(null, onRejected)\n}\n\n```","slug":"promise","published":1,"date":"2017-09-26T04:10:10.000Z","updated":"2017-09-26T04:10:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4acn000cgvk9z86q1z30","content":"<h2 id=\"Promise-简介\"><a href=\"#Promise-简介\" class=\"headerlink\" title=\"Promise 简介\"></a>Promise 简介</h2><blockquote>\n<p>Promise 对象是用来处理异步操作的工具,解决开发者对异步回调的烦恼。可以说Promise是个代理对象，在设计模式来讲就是代理模式，它代理了一个值（通过resolve方法传递的值），并且设置了几个状态让用户知道当前代理值解析的结果。</p>\n</blockquote>\n<h2 id=\"Promise-状态\"><a href=\"#Promise-状态\" class=\"headerlink\" title=\"Promise 状态\"></a>Promise 状态</h2><p>按照规范，Promise有三种状态：</p>\n<ul>\n<li><p>pending: 初始状态,未完成或拒绝，可改变状态。</p>\n</li>\n<li><p>fulfilled（resolved）: 操作成功完成,不可改变状态,拥有不可变的终值。</p>\n</li>\n<li><p>rejected: 操作失败,不可改变状态,拥有不可变的拒因。</p>\n</li>\n</ul>\n<h2 id=\"Promise-术语\"><a href=\"#Promise-术语\" class=\"headerlink\" title=\"Promise 术语\"></a>Promise 术语</h2><ul>\n<li><p>解决（fulfill）：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。</p>\n</li>\n<li><p>拒绝（reject）：指一个 promise 失败时进行的一系列操作。</p>\n</li>\n<li><p>终值（eventual value）：所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</p>\n</li>\n<li><p>据因（reason）：也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</p>\n</li>\n</ul>\n<h2 id=\"状态机制切换\"><a href=\"#状态机制切换\" class=\"headerlink\" title=\"状态机制切换\"></a>状态机制切换</h2><p>状态只能由pengding–&gt;fulfilled，或者由pending–&gt;rejected这样转变。</p>\n<p>只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<h2 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h2><blockquote>\n<p>Promise.then()  <br><br>语法：Promise.prototype.then(onFulfilled, onRejected)<br>对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的resolve函数。<br>.catch() <br><br>语法：Promise.prototype.catch(onRejected)<br>该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数。<br>.all() <br><br>语法：Promise.all(iterable)<br>该方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n</blockquote>\n<p>var p = Promise.all([p1, p2, p3]);<br>Promise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。</p>\n<blockquote>\n<p>.race()<br><br>语法：Promise.race(iterable)<br>该方法同样是将多个Promise实例，包装成一个新的Promise实例。<br>例如：var p = Promise.race([p1, p2, p3]);<br>Promise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。</p>\n</blockquote>\n<h2 id=\"Promise常见问题\"><a href=\"#Promise常见问题\" class=\"headerlink\" title=\"Promise常见问题\"></a>Promise常见问题</h2><ul>\n<li>在异步回调中抛错，不会被catch到</li>\n<li>promise状态变为resove或reject，就凝固了，不会再改变</li>\n<li>如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误</li>\n<li>reject 和 catch 的区别:<br>promise.then(onFulfilled, onRejected) //在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。<br>promise.then(onFulfilled).catch(onRejected)  //.then中产生的异常能在.catch中捕获</li>\n</ul>\n<h2 id=\"手写一个Promise\"><a href=\"#手写一个Promise\" class=\"headerlink\" title=\"手写一个Promise\"></a>手写一个Promise</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span> <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">  self.data = <span class=\"literal\">undefined</span>  <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">  self.onResolvedCallback = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">  self.onRejectedCallback = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">  callback(resolve, reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(self.status==<span class=\"string\">'pending'</span>)&#123;</span><br><span class=\"line\">          self.status==<span class=\"string\">'resolved'</span>;</span><br><span class=\"line\">          self.data=value;</span><br><span class=\"line\">          <span class=\"comment\">// 依次执行成功之后的函数栈</span></span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class=\"line\">            self.onResolvedCallback[i](value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rejecet</span>(<span class=\"params\">error</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">       self.status = <span class=\"string\">'rejected'</span></span><br><span class=\"line\">       self.data = error;</span><br><span class=\"line\">       <span class=\"comment\">// 依次执行失败之后的函数栈</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class=\"line\">           self.onRejectedCallback[i](error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>接下来我们实现我们的then方法, then方法是Promise的核心, 一个promise的then接受两个参数,首先需要判断参数是否为函数，若不为函数忽略</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> promise2</span><br><span class=\"line\"></span><br><span class=\"line\">  onResolved = <span class=\"keyword\">typeof</span> onResolved === <span class=\"string\">'function'</span> ? onResolved : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;&#125;</span><br><span class=\"line\">  onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (self.status === <span class=\"string\">'resolved'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = onResolved(self.data)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123; </span><br><span class=\"line\">          x.then(resolve, reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(x) <span class=\"comment\">// 否则，以它的返回值做为promise2的结果</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e) <span class=\"comment\">// 如果出错，以捕获到的错误做为promise2的结果</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数，就不再做过多解释</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = onRejected(self.data)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">          x.then(resolve, reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，<br>只能等到Promise的状态确定后，才能确实如何处理。<br>所以我们需要把我们的两种情况的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里<br>逻辑本身跟第一个if块内的几乎一致，此处不做过多解释</p>\n<p><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">if</span> (self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      self.onResolvedCallback.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> x = onResolved(self.data)</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">            x.then(resolve, reject)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      self.onRejectedCallback.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> x = onRejected(self.data)</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">            x.then(resolve, reject)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们顺便实现一个catch方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">null</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Promise-简介\"><a href=\"#Promise-简介\" class=\"headerlink\" title=\"Promise 简介\"></a>Promise 简介</h2><blockquote>\n<p>Promise 对象是用来处理异步操作的工具,解决开发者对异步回调的烦恼。可以说Promise是个代理对象，在设计模式来讲就是代理模式，它代理了一个值（通过resolve方法传递的值），并且设置了几个状态让用户知道当前代理值解析的结果。</p>\n</blockquote>\n<h2 id=\"Promise-状态\"><a href=\"#Promise-状态\" class=\"headerlink\" title=\"Promise 状态\"></a>Promise 状态</h2><p>按照规范，Promise有三种状态：</p>\n<ul>\n<li><p>pending: 初始状态,未完成或拒绝，可改变状态。</p>\n</li>\n<li><p>fulfilled（resolved）: 操作成功完成,不可改变状态,拥有不可变的终值。</p>\n</li>\n<li><p>rejected: 操作失败,不可改变状态,拥有不可变的拒因。</p>\n</li>\n</ul>\n<h2 id=\"Promise-术语\"><a href=\"#Promise-术语\" class=\"headerlink\" title=\"Promise 术语\"></a>Promise 术语</h2><ul>\n<li><p>解决（fulfill）：指一个 promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 promise 实现多以 resolve 来指代之。</p>\n</li>\n<li><p>拒绝（reject）：指一个 promise 失败时进行的一系列操作。</p>\n</li>\n<li><p>终值（eventual value）：所谓终值，指的是 promise 被解决时传递给解决回调的值，由于 promise 有一次性的特征，因此当这个值被传递时，标志着 promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</p>\n</li>\n<li><p>据因（reason）：也就是拒绝原因，指在 promise 被拒绝时传递给拒绝回调的值。</p>\n</li>\n</ul>\n<h2 id=\"状态机制切换\"><a href=\"#状态机制切换\" class=\"headerlink\" title=\"状态机制切换\"></a>状态机制切换</h2><p>状态只能由pengding–&gt;fulfilled，或者由pending–&gt;rejected这样转变。</p>\n<p>只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<h2 id=\"基本API\"><a href=\"#基本API\" class=\"headerlink\" title=\"基本API\"></a>基本API</h2><blockquote>\n<p>Promise.then()  <br><br>语法：Promise.prototype.then(onFulfilled, onRejected)<br>对promise添加onFulfilled和onRejected回调，并返回的是一个新的Promise实例（不是原来那个Promise实例），且返回值将作为参数传入这个新Promise的resolve函数。<br>.catch() <br><br>语法：Promise.prototype.catch(onRejected)<br>该方法是.then(undefined, onRejected)的别名，用于指定发生错误时的回调函数。<br>.all() <br><br>语法：Promise.all(iterable)<br>该方法用于将多个Promise实例，包装成一个新的Promise实例。</p>\n</blockquote>\n<p>var p = Promise.all([p1, p2, p3]);<br>Promise.all方法接受一个数组（或具有Iterator接口）作参数，数组中的对象（p1、p2、p3）均为promise实例（如果不是一个promise，该项会被用Promise.resolve转换为一个promise)。它的状态由这三个promise实例决定。</p>\n<blockquote>\n<p>.race()<br><br>语法：Promise.race(iterable)<br>该方法同样是将多个Promise实例，包装成一个新的Promise实例。<br>例如：var p = Promise.race([p1, p2, p3]);<br>Promise.race方法同样接受一个数组（或具有Iterator接口）作参数。当p1, p2, p3中有一个实例的状态发生改变（变为fulfilled或rejected），p的状态就跟着改变。并把第一个改变状态的promise的返回值，传给p的回调函数。</p>\n</blockquote>\n<h2 id=\"Promise常见问题\"><a href=\"#Promise常见问题\" class=\"headerlink\" title=\"Promise常见问题\"></a>Promise常见问题</h2><ul>\n<li>在异步回调中抛错，不会被catch到</li>\n<li>promise状态变为resove或reject，就凝固了，不会再改变</li>\n<li>如果在then中抛错，而没有对错误进行处理（即catch），那么会一直保持reject状态，直到catch了错误</li>\n<li>reject 和 catch 的区别:<br>promise.then(onFulfilled, onRejected) //在onFulfilled中发生异常的话，在onRejected中是捕获不到这个异常的。<br>promise.then(onFulfilled).catch(onRejected)  //.then中产生的异常能在.catch中捕获</li>\n</ul>\n<h2 id=\"手写一个Promise\"><a href=\"#手写一个Promise\" class=\"headerlink\" title=\"手写一个Promise\"></a>手写一个Promise</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Promise</span>(<span class=\"params\">callback</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  self.status = <span class=\"string\">'pending'</span> <span class=\"comment\">// Promise当前的状态</span></span><br><span class=\"line\">  self.data = <span class=\"literal\">undefined</span>  <span class=\"comment\">// Promise的值</span></span><br><span class=\"line\">  self.onResolvedCallback = [] <span class=\"comment\">// Promise resolve时的回调函数集</span></span><br><span class=\"line\">  self.onRejectedCallback = [] <span class=\"comment\">// Promise reject时的回调函数集</span></span><br><span class=\"line\">  callback(resolve, reject) <span class=\"comment\">// 执行callback并传入相应的参数</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">resolve</span>(<span class=\"params\">value</span>)</span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span>(self.status==<span class=\"string\">'pending'</span>)&#123;</span><br><span class=\"line\">          self.status==<span class=\"string\">'resolved'</span>;</span><br><span class=\"line\">          self.data=value;</span><br><span class=\"line\">          <span class=\"comment\">// 依次执行成功之后的函数栈</span></span><br><span class=\"line\">          <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; self.onResolvedCallback.length; i++) &#123;</span><br><span class=\"line\">            self.onResolvedCallback[i](value)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">rejecet</span>(<span class=\"params\">error</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">       self.status = <span class=\"string\">'rejected'</span></span><br><span class=\"line\">       self.data = error;</span><br><span class=\"line\">       <span class=\"comment\">// 依次执行失败之后的函数栈</span></span><br><span class=\"line\">       <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> i = <span class=\"number\">0</span>; i &lt; self.onRejectedCallback.length; i++) &#123;</span><br><span class=\"line\">           self.onRejectedCallback[i](error)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>接下来我们实现我们的then方法, then方法是Promise的核心, 一个promise的then接受两个参数,首先需要判断参数是否为函数，若不为函数忽略</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.then = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onResolved, onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> self = <span class=\"keyword\">this</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> promise2</span><br><span class=\"line\"></span><br><span class=\"line\">  onResolved = <span class=\"keyword\">typeof</span> onResolved === <span class=\"string\">'function'</span> ? onResolved : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;&#125;</span><br><span class=\"line\">  onRejected = <span class=\"keyword\">typeof</span> onRejected === <span class=\"string\">'function'</span> ? onRejected : <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>) </span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (self.status === <span class=\"string\">'resolved'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = onResolved(self.data)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123; </span><br><span class=\"line\">          x.then(resolve, reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        resolve(x) <span class=\"comment\">// 否则，以它的返回值做为promise2的结果</span></span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e) <span class=\"comment\">// 如果出错，以捕获到的错误做为promise2的结果</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 此处与前一个if块的逻辑几乎相同，区别在于所调用的是onRejected函数，就不再做过多解释</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (self.status === <span class=\"string\">'rejected'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> x = onRejected(self.data)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">          x.then(resolve, reject)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">        reject(e)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<p>如果当前的Promise还处于pending状态，我们并不能确定调用onResolved还是onRejected，<br>只能等到Promise的状态确定后，才能确实如何处理。<br>所以我们需要把我们的两种情况的处理逻辑做为callback放入promise1(此处即this/self)的回调数组里<br>逻辑本身跟第一个if块内的几乎一致，此处不做过多解释</p>\n<p><br></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">if</span> (self.status === <span class=\"string\">'pending'</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> promise2 = <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">resolve, reject</span>) </span>&#123;</span><br><span class=\"line\">      self.onResolvedCallback.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> x = onResolved(self.data)</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">            x.then(resolve, reject)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">      self.onRejectedCallback.push(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">reason</span>) </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">var</span> x = onRejected(self.data)</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (x <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Promise</span>) &#123;</span><br><span class=\"line\">            x.then(resolve, reject)</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">          reject(e)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>我们顺便实现一个catch方法</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Promise</span>.prototype.catch = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">onRejected</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.then(<span class=\"literal\">null</span>, onRejected)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"Vue.js全家桶仿哔哩哔哩动画 (移动端APP)","_content":"\n\n\n# 项目地址\n\n\n\n###    · 由于项目是移动端,电脑访问时可以切换成手机端\n\n###    · 播放页面其实没有根据B站移动端来, 比较粗糙 \n\n###    · [源码地址](http://github.com/youhonglian/vue-bilibili)\n\n###    · [在线预览](https://youhonglian.github.io/vue-bilibili-master/#/)\n\n\n\n# 项目描述\n\n## 前端部分\n\n   * 实现的Swiper, Toast,  Indicator组件 来自Mint-ui\n   * 使用了Vue.js做单页应用\n   * 使用了Vue Router处理路由请求\n   * 使用了Axios做ajax请求\n   * 使用了Vuex管理组件间的状态，实现非父子组件之间的通信\n   * 皮肤状态通过localstorage存储\n\n## 后端部分\n\n  * 开发环境下使用了express处理路由\n\n## 待更新的功能\n\n  * Video标签的优化\n  * 直播界面的优化\n  * 视频的弹幕加载\n  * 将Vuex管理优化\n  * 一些bug的解决\n\n### 小提示\n\n运行项目的时候注意一下网络, 一不小心会耗费一大波流量 (´･_･`)\n遇到在线预览显示不出来的情况，可以戳源码本地运行\n   \n## 实现的功能\n\n  * B站首页（轮播图、直播、推荐、番剧、排行榜、分区）\n  * 切换主题（黑色和粉色的主题）\n  * 搜索视频\n  * 播放页面（简介、评论显示、发表评论、点赞、番剧选集）\n\n## 详情\n  <img src=\"http://ww3.sinaimg.cn/large/006HJ39wgy1fgsxh2dc0vj30ag0ilgs5.jpg\" width=\"400\" height=\"627\">\n  <img src=\"http://ww1.sinaimg.cn/large/006HJ39wgy1fgsxh6dkarj30ah0iognv.jpg\" width=\"400\" height=\"627\">\n  <img src=\"http://ww2.sinaimg.cn/large/006HJ39wgy1fgsxgnrti1j30af0im46j.jpg\" width=\"400\" height=\"627\">\n  <img src=\"http://ww3.sinaimg.cn/large/006HJ39wgy1fgsxh9dj7nj30ae0ii40i.jpg\" width=\"400\" height=\"627\">\n  <img src=\"http://ww1.sinaimg.cn/large/006HJ39wgy1fgsxhch9qrj30a90imaee.jpg\" width=\"400\" height=\"627\">\n\n  <img src=\"http://storage1.imgchr.com/ki658.gif\" width=\"400\" height=\"627\">\n  \n  \n由于项目做的比较仓促，也比较粗糙. 项目中还有很多bug, 请见谅. 欢迎大家提issue，pr\n\n\n [友情链接](https://segmentfault.com/a/1190000009912978)\n\n\n ","source":"_posts/vue-bilibili.md","raw":"---\ntitle: Vue.js全家桶仿哔哩哔哩动画 (移动端APP)\ncategories:  vue.js\ntags: \n- vue\n---\n\n\n\n# 项目地址\n\n\n\n###    · 由于项目是移动端,电脑访问时可以切换成手机端\n\n###    · 播放页面其实没有根据B站移动端来, 比较粗糙 \n\n###    · [源码地址](http://github.com/youhonglian/vue-bilibili)\n\n###    · [在线预览](https://youhonglian.github.io/vue-bilibili-master/#/)\n\n\n\n# 项目描述\n\n## 前端部分\n\n   * 实现的Swiper, Toast,  Indicator组件 来自Mint-ui\n   * 使用了Vue.js做单页应用\n   * 使用了Vue Router处理路由请求\n   * 使用了Axios做ajax请求\n   * 使用了Vuex管理组件间的状态，实现非父子组件之间的通信\n   * 皮肤状态通过localstorage存储\n\n## 后端部分\n\n  * 开发环境下使用了express处理路由\n\n## 待更新的功能\n\n  * Video标签的优化\n  * 直播界面的优化\n  * 视频的弹幕加载\n  * 将Vuex管理优化\n  * 一些bug的解决\n\n### 小提示\n\n运行项目的时候注意一下网络, 一不小心会耗费一大波流量 (´･_･`)\n遇到在线预览显示不出来的情况，可以戳源码本地运行\n   \n## 实现的功能\n\n  * B站首页（轮播图、直播、推荐、番剧、排行榜、分区）\n  * 切换主题（黑色和粉色的主题）\n  * 搜索视频\n  * 播放页面（简介、评论显示、发表评论、点赞、番剧选集）\n\n## 详情\n  <img src=\"http://ww3.sinaimg.cn/large/006HJ39wgy1fgsxh2dc0vj30ag0ilgs5.jpg\" width=\"400\" height=\"627\">\n  <img src=\"http://ww1.sinaimg.cn/large/006HJ39wgy1fgsxh6dkarj30ah0iognv.jpg\" width=\"400\" height=\"627\">\n  <img src=\"http://ww2.sinaimg.cn/large/006HJ39wgy1fgsxgnrti1j30af0im46j.jpg\" width=\"400\" height=\"627\">\n  <img src=\"http://ww3.sinaimg.cn/large/006HJ39wgy1fgsxh9dj7nj30ae0ii40i.jpg\" width=\"400\" height=\"627\">\n  <img src=\"http://ww1.sinaimg.cn/large/006HJ39wgy1fgsxhch9qrj30a90imaee.jpg\" width=\"400\" height=\"627\">\n\n  <img src=\"http://storage1.imgchr.com/ki658.gif\" width=\"400\" height=\"627\">\n  \n  \n由于项目做的比较仓促，也比较粗糙. 项目中还有很多bug, 请见谅. 欢迎大家提issue，pr\n\n\n [友情链接](https://segmentfault.com/a/1190000009912978)\n\n\n ","slug":"vue-bilibili","published":1,"date":"2017-06-26T02:11:08.000Z","updated":"2017-06-26T02:11:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4acp000ggvk9etu7y170","content":"<h1 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h1><h3 id=\"·-由于项目是移动端-电脑访问时可以切换成手机端\"><a href=\"#·-由于项目是移动端-电脑访问时可以切换成手机端\" class=\"headerlink\" title=\"· 由于项目是移动端,电脑访问时可以切换成手机端\"></a>· 由于项目是移动端,电脑访问时可以切换成手机端</h3><h3 id=\"·-播放页面其实没有根据B站移动端来-比较粗糙\"><a href=\"#·-播放页面其实没有根据B站移动端来-比较粗糙\" class=\"headerlink\" title=\"· 播放页面其实没有根据B站移动端来, 比较粗糙\"></a>· 播放页面其实没有根据B站移动端来, 比较粗糙</h3><h3 id=\"·-源码地址\"><a href=\"#·-源码地址\" class=\"headerlink\" title=\"· 源码地址\"></a>· <a href=\"http://github.com/youhonglian/vue-bilibili\" target=\"_blank\" rel=\"noopener\">源码地址</a></h3><h3 id=\"·-在线预览\"><a href=\"#·-在线预览\" class=\"headerlink\" title=\"· 在线预览\"></a>· <a href=\"https://youhonglian.github.io/vue-bilibili-master/#/\">在线预览</a></h3><h1 id=\"项目描述\"><a href=\"#项目描述\" class=\"headerlink\" title=\"项目描述\"></a>项目描述</h1><h2 id=\"前端部分\"><a href=\"#前端部分\" class=\"headerlink\" title=\"前端部分\"></a>前端部分</h2><ul>\n<li>实现的Swiper, Toast,  Indicator组件 来自Mint-ui</li>\n<li>使用了Vue.js做单页应用</li>\n<li>使用了Vue Router处理路由请求</li>\n<li>使用了Axios做ajax请求</li>\n<li>使用了Vuex管理组件间的状态，实现非父子组件之间的通信</li>\n<li>皮肤状态通过localstorage存储</li>\n</ul>\n<h2 id=\"后端部分\"><a href=\"#后端部分\" class=\"headerlink\" title=\"后端部分\"></a>后端部分</h2><ul>\n<li>开发环境下使用了express处理路由</li>\n</ul>\n<h2 id=\"待更新的功能\"><a href=\"#待更新的功能\" class=\"headerlink\" title=\"待更新的功能\"></a>待更新的功能</h2><ul>\n<li>Video标签的优化</li>\n<li>直播界面的优化</li>\n<li>视频的弹幕加载</li>\n<li>将Vuex管理优化</li>\n<li>一些bug的解决</li>\n</ul>\n<h3 id=\"小提示\"><a href=\"#小提示\" class=\"headerlink\" title=\"小提示\"></a>小提示</h3><p>运行项目的时候注意一下网络, 一不小心会耗费一大波流量 (´･_･`)<br>遇到在线预览显示不出来的情况，可以戳源码本地运行</p>\n<h2 id=\"实现的功能\"><a href=\"#实现的功能\" class=\"headerlink\" title=\"实现的功能\"></a>实现的功能</h2><ul>\n<li>B站首页（轮播图、直播、推荐、番剧、排行榜、分区）</li>\n<li>切换主题（黑色和粉色的主题）</li>\n<li>搜索视频</li>\n<li>播放页面（简介、评论显示、发表评论、点赞、番剧选集）</li>\n</ul>\n<h2 id=\"详情\"><a href=\"#详情\" class=\"headerlink\" title=\"详情\"></a>详情</h2><p>  <img src=\"http://ww3.sinaimg.cn/large/006HJ39wgy1fgsxh2dc0vj30ag0ilgs5.jpg\" width=\"400\" height=\"627\"><br>  <img src=\"http://ww1.sinaimg.cn/large/006HJ39wgy1fgsxh6dkarj30ah0iognv.jpg\" width=\"400\" height=\"627\"><br>  <img src=\"http://ww2.sinaimg.cn/large/006HJ39wgy1fgsxgnrti1j30af0im46j.jpg\" width=\"400\" height=\"627\"><br>  <img src=\"http://ww3.sinaimg.cn/large/006HJ39wgy1fgsxh9dj7nj30ae0ii40i.jpg\" width=\"400\" height=\"627\"><br>  <img src=\"http://ww1.sinaimg.cn/large/006HJ39wgy1fgsxhch9qrj30a90imaee.jpg\" width=\"400\" height=\"627\"></p>\n<p>  <img src=\"http://storage1.imgchr.com/ki658.gif\" width=\"400\" height=\"627\"></p>\n<p>由于项目做的比较仓促，也比较粗糙. 项目中还有很多bug, 请见谅. 欢迎大家提issue，pr</p>\n<p> <a href=\"https://segmentfault.com/a/1190000009912978\" target=\"_blank\" rel=\"noopener\">友情链接</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"项目地址\"><a href=\"#项目地址\" class=\"headerlink\" title=\"项目地址\"></a>项目地址</h1><h3 id=\"·-由于项目是移动端-电脑访问时可以切换成手机端\"><a href=\"#·-由于项目是移动端-电脑访问时可以切换成手机端\" class=\"headerlink\" title=\"· 由于项目是移动端,电脑访问时可以切换成手机端\"></a>· 由于项目是移动端,电脑访问时可以切换成手机端</h3><h3 id=\"·-播放页面其实没有根据B站移动端来-比较粗糙\"><a href=\"#·-播放页面其实没有根据B站移动端来-比较粗糙\" class=\"headerlink\" title=\"· 播放页面其实没有根据B站移动端来, 比较粗糙\"></a>· 播放页面其实没有根据B站移动端来, 比较粗糙</h3><h3 id=\"·-源码地址\"><a href=\"#·-源码地址\" class=\"headerlink\" title=\"· 源码地址\"></a>· <a href=\"http://github.com/youhonglian/vue-bilibili\" target=\"_blank\" rel=\"noopener\">源码地址</a></h3><h3 id=\"·-在线预览\"><a href=\"#·-在线预览\" class=\"headerlink\" title=\"· 在线预览\"></a>· <a href=\"https://youhonglian.github.io/vue-bilibili-master/#/\">在线预览</a></h3><h1 id=\"项目描述\"><a href=\"#项目描述\" class=\"headerlink\" title=\"项目描述\"></a>项目描述</h1><h2 id=\"前端部分\"><a href=\"#前端部分\" class=\"headerlink\" title=\"前端部分\"></a>前端部分</h2><ul>\n<li>实现的Swiper, Toast,  Indicator组件 来自Mint-ui</li>\n<li>使用了Vue.js做单页应用</li>\n<li>使用了Vue Router处理路由请求</li>\n<li>使用了Axios做ajax请求</li>\n<li>使用了Vuex管理组件间的状态，实现非父子组件之间的通信</li>\n<li>皮肤状态通过localstorage存储</li>\n</ul>\n<h2 id=\"后端部分\"><a href=\"#后端部分\" class=\"headerlink\" title=\"后端部分\"></a>后端部分</h2><ul>\n<li>开发环境下使用了express处理路由</li>\n</ul>\n<h2 id=\"待更新的功能\"><a href=\"#待更新的功能\" class=\"headerlink\" title=\"待更新的功能\"></a>待更新的功能</h2><ul>\n<li>Video标签的优化</li>\n<li>直播界面的优化</li>\n<li>视频的弹幕加载</li>\n<li>将Vuex管理优化</li>\n<li>一些bug的解决</li>\n</ul>\n<h3 id=\"小提示\"><a href=\"#小提示\" class=\"headerlink\" title=\"小提示\"></a>小提示</h3><p>运行项目的时候注意一下网络, 一不小心会耗费一大波流量 (´･_･`)<br>遇到在线预览显示不出来的情况，可以戳源码本地运行</p>\n<h2 id=\"实现的功能\"><a href=\"#实现的功能\" class=\"headerlink\" title=\"实现的功能\"></a>实现的功能</h2><ul>\n<li>B站首页（轮播图、直播、推荐、番剧、排行榜、分区）</li>\n<li>切换主题（黑色和粉色的主题）</li>\n<li>搜索视频</li>\n<li>播放页面（简介、评论显示、发表评论、点赞、番剧选集）</li>\n</ul>\n<h2 id=\"详情\"><a href=\"#详情\" class=\"headerlink\" title=\"详情\"></a>详情</h2><p>  <img src=\"http://ww3.sinaimg.cn/large/006HJ39wgy1fgsxh2dc0vj30ag0ilgs5.jpg\" width=\"400\" height=\"627\"><br>  <img src=\"http://ww1.sinaimg.cn/large/006HJ39wgy1fgsxh6dkarj30ah0iognv.jpg\" width=\"400\" height=\"627\"><br>  <img src=\"http://ww2.sinaimg.cn/large/006HJ39wgy1fgsxgnrti1j30af0im46j.jpg\" width=\"400\" height=\"627\"><br>  <img src=\"http://ww3.sinaimg.cn/large/006HJ39wgy1fgsxh9dj7nj30ae0ii40i.jpg\" width=\"400\" height=\"627\"><br>  <img src=\"http://ww1.sinaimg.cn/large/006HJ39wgy1fgsxhch9qrj30a90imaee.jpg\" width=\"400\" height=\"627\"></p>\n<p>  <img src=\"http://storage1.imgchr.com/ki658.gif\" width=\"400\" height=\"627\"></p>\n<p>由于项目做的比较仓促，也比较粗糙. 项目中还有很多bug, 请见谅. 欢迎大家提issue，pr</p>\n<p> <a href=\"https://segmentfault.com/a/1190000009912978\" target=\"_blank\" rel=\"noopener\">友情链接</a></p>\n"},{"title":"对Vuex的基本理解","_content":"\n## Vuex\n> vuex是为vue.js开发的状态管理模式，存储应用中的所有数据状态，便于统一管理。它是应用中唯一的数据源，所以一个应用中只有一个store实例。\n\n\n### 安装和使用\n\n```JavaScript\nimport Vue from 'vue'\n\nimport Vuex from 'vuex'\n\n//Vuex用过store选项，提供了一种机制，将数据从跟组件注入到每个子组件中（需要调用Vue.use(Vuex)）:\n\nVue.use(Vuex)\n```\n\n\n\n### state\n\n通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中。且子组件能通过this.$store访问到\n\n```JavaScript \n const Counter = {\n      template: `<div>{{ count }}</div>`,\n      //从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：\n      computed: {\n          count () {\n          return this.$store.state.count\n          }\n      }\n  }\n \n```\n\n\n\n### mapState辅助函数\n\n当一个组件需要获取多个状态时，逐个声明计算属性会很麻烦，为此我们可以使用mapState辅助函数帮我们生成： // 在单独构建的版本中辅助函数为 Vuex.mapState\n\n```JavaScript\nimport { mapState } from 'vuex'\n\nexport default {\n  computed: mapState({\n         /*三种不同的方式*/\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n    // 传字符串参数 'count' 等同于 `state => state.count`\n        countAlias: 'count',\n        // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n        countPlusLocalState (state) {\n          return state.count + this.localCount\n        }\n  })\n}\n```\n\n上边我们给mapState传了一个对象，如果我们要生成的计算属性名称与state子节点名称相同时，也可以直接给mapState传入一个字符串数组：\n\n```JavaScript\n   computed: mapState([\n      // 映射 this.count 为 store.state.count\n      'count'\n    ])\n```\n\n### 对象展开运算符\n\nmapState函数返回的是一个对象，但是一个组件中的计算属性，不仅有来自store的，还有它局部的。那么如何混用呢？我们使用对象展开运算符：\n\n```JavaScript \n computed: {\n      //localComputed 是组件的局部计算属性\n      localComputed () { /* ... */ },\n      // 使用对象展开运算符将此对象混入到外部对象中\n      ...mapState({\n        // ...\n      })\n    }\n    \n```\n\n\n### Getters\n\n有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：\n\n```JavaScript\n     computed: {\n      doneTodosCount () {\n        return this.$store.state.todos.filter(todo => todo.done).length\n      }\n   }\n```\nVuex允许我们在store中定义getters（可以认为是store的计算属性）。getter接受state作为第一个参数：\n\n```JavaScript\n// 在'store/index.js'中\n    const store = new Vuex.Store({\n      state: {\n        todos: [\n          { id: 1, text: '...', done: true },\n           { id: 2, text: '...', done: false }\n            ]\n      },\n      getters: {\n            doneTodos: state => {\n          return state.todos.filter(todo => todo.done)\n        },\n    // getters也可以接受其他getters作为第二个参数\n        doneTodosCount: (state, getters) => {\n          return getters.doneTodos.length\n            }\n      }\n    })\n```\n\n### mapGetters辅助函数\n\nmapGetters辅助函数仅仅是将store中的getters映射到局部计算属性：\n```JavaScript\n    import { mapGetters } from 'vuex'\n\n    export default {\n    // ...\n    computed: {\n    // 使用对象展开运算符将 getters 混入 computed 对象中\n    ...mapGetters([\n    'doneTodosCount',\n    'anotherGetter',\n    // ...\n    ])\n    //如果想给getter属性领取一个名字，可以对象形式：\n    mapGetters({\n    // 映射 this.doneCount 为 store.getters.doneTodosCount\n    doneCount: 'doneTodosCount'\n    })\n    }\n    }\n```\n\n### Mutations\n\n更改Vuex的store中的状态的唯一方法是提交mutation。Vuex的mutataions非常类似于事件：每个mutation都有一个字符串的事件类型（type）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，他会接受state作为第一个参数：\n\n```JavaScript\n    const store = new Vuex.Store({\n    state: {\n            count: 1\n    },\n    mutations: {\n            increment (state) {\n        // 变更状态\n        state.count++\n            }\n    }\n    })\n```\n\n上边注册了一个类型为increment的mutation：“当触发一个类型为increment的mutation时，调用此函数。”实际使用时：store.commit('increment')\n\n### 使用常量替代Mutation事件类型\n\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```JavaScript \n  //mutation-types.js\n\n  export const SOME_MUTATION = 'SOME_MUTATION'\n```\n\n```JavaScript\n    //store.js\n    import Vuex from 'vuex'\n    import * as types from './mutation-types'\n\n    const store = new Vuex.Store({\n    state: { ... },\n    mutations: {\n      // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n      [types.SOME_MUTATION] (state) {\n      // mutate state\n      }\n     }\n    })\n```\n\nmutation必须是同步函数你可以在组件中使用this.store.commit('type')提交mutataion，或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用（需要在根节点注入store）。\n\n```JavaScript\n    import { mapMutations } from 'vuex'\n\n    export default {\n    // ...\n    methods: {\n      ...mapMutations([\n      'increment' // 映射 this.increment() 为 this.$store.commit('increment')\n    ]),\n    ...mapMutations({\n       add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')\n    })\n    }\n    }\n```\n\n### Actions\n\nAction类似于mutation，不同之处在于：\n\nAction提交的是mutataion，而不是直接变更状态。\nAction可以包含任意异步操作。\n注册一个简单的Action：\n\n```JavaScript\n    const store = new Vuex.Store({\n    state: {\n        count: 0\n    },\n    mutations: {\n        increment (state) {\n        state.count++\n        }\n    },\n    actions: {\n        increment (context) {\n        context.commit('increment')\n        }\n    }\n    })\n```\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n\n>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。\n\n```JavaScript\n    //例如：赋值  var [a,b,c] = [1,2,3]\n    //例如：交换变量 [x,y] = [y,x]\n    //例如：函数参数解构：\n    // function add([x, y]){\n    //   return x + y;\n    // }\n    //实践中我们常用到 参数解构 来简化代码，下边\n    //的 { commit } 就用到了解构。\n\n    actions: {\n    increment ({ commit }) {\n        commit('increment')\n    }\n}\n```\n这里解构的对象是context对象，也就是说context <==> { commit }，这样写就可以用commit替代context.commit，简化代码。\n\n### 分发Action\n\nAction通过store.dispatch方法触发：store.dispatch('increment') Actions 支持同样的载荷方式和对象方式进行分发：\n\n* 以载荷形式分发\n```JavaScript\n    store.dispatch('incrementAsync', {\n        amount: 10\n    })\n```\n* 以对象形式分发\n```JavaScript\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n我们可以在Action内部执行异步操作：\n```JavaScript\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\n* 在组件中分发Action\n\n你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：\n```JavaScript\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n       'increment' // 映射 this.increment() 为 this.$store.dispatch('increment')\n    ]),\n    ...mapActions({\n       add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment')\n    })\n  }\n}\n```\n\n### Modules\n使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。\n\n为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：\n\n```JavaScript\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n","source":"_posts/vuex.md","raw":"---\ntitle: 对Vuex的基本理解\ncategories:  vue.js\ntags: \n- vuex\n---\n\n## Vuex\n> vuex是为vue.js开发的状态管理模式，存储应用中的所有数据状态，便于统一管理。它是应用中唯一的数据源，所以一个应用中只有一个store实例。\n\n\n### 安装和使用\n\n```JavaScript\nimport Vue from 'vue'\n\nimport Vuex from 'vuex'\n\n//Vuex用过store选项，提供了一种机制，将数据从跟组件注入到每个子组件中（需要调用Vue.use(Vuex)）:\n\nVue.use(Vuex)\n```\n\n\n\n### state\n\n通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中。且子组件能通过this.$store访问到\n\n```JavaScript \n const Counter = {\n      template: `<div>{{ count }}</div>`,\n      //从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：\n      computed: {\n          count () {\n          return this.$store.state.count\n          }\n      }\n  }\n \n```\n\n\n\n### mapState辅助函数\n\n当一个组件需要获取多个状态时，逐个声明计算属性会很麻烦，为此我们可以使用mapState辅助函数帮我们生成： // 在单独构建的版本中辅助函数为 Vuex.mapState\n\n```JavaScript\nimport { mapState } from 'vuex'\n\nexport default {\n  computed: mapState({\n         /*三种不同的方式*/\n    // 箭头函数可使代码更简练\n    count: state => state.count,\n    // 传字符串参数 'count' 等同于 `state => state.count`\n        countAlias: 'count',\n        // 为了能够使用 `this` 获取局部状态，必须使用常规函数\n        countPlusLocalState (state) {\n          return state.count + this.localCount\n        }\n  })\n}\n```\n\n上边我们给mapState传了一个对象，如果我们要生成的计算属性名称与state子节点名称相同时，也可以直接给mapState传入一个字符串数组：\n\n```JavaScript\n   computed: mapState([\n      // 映射 this.count 为 store.state.count\n      'count'\n    ])\n```\n\n### 对象展开运算符\n\nmapState函数返回的是一个对象，但是一个组件中的计算属性，不仅有来自store的，还有它局部的。那么如何混用呢？我们使用对象展开运算符：\n\n```JavaScript \n computed: {\n      //localComputed 是组件的局部计算属性\n      localComputed () { /* ... */ },\n      // 使用对象展开运算符将此对象混入到外部对象中\n      ...mapState({\n        // ...\n      })\n    }\n    \n```\n\n\n### Getters\n\n有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：\n\n```JavaScript\n     computed: {\n      doneTodosCount () {\n        return this.$store.state.todos.filter(todo => todo.done).length\n      }\n   }\n```\nVuex允许我们在store中定义getters（可以认为是store的计算属性）。getter接受state作为第一个参数：\n\n```JavaScript\n// 在'store/index.js'中\n    const store = new Vuex.Store({\n      state: {\n        todos: [\n          { id: 1, text: '...', done: true },\n           { id: 2, text: '...', done: false }\n            ]\n      },\n      getters: {\n            doneTodos: state => {\n          return state.todos.filter(todo => todo.done)\n        },\n    // getters也可以接受其他getters作为第二个参数\n        doneTodosCount: (state, getters) => {\n          return getters.doneTodos.length\n            }\n      }\n    })\n```\n\n### mapGetters辅助函数\n\nmapGetters辅助函数仅仅是将store中的getters映射到局部计算属性：\n```JavaScript\n    import { mapGetters } from 'vuex'\n\n    export default {\n    // ...\n    computed: {\n    // 使用对象展开运算符将 getters 混入 computed 对象中\n    ...mapGetters([\n    'doneTodosCount',\n    'anotherGetter',\n    // ...\n    ])\n    //如果想给getter属性领取一个名字，可以对象形式：\n    mapGetters({\n    // 映射 this.doneCount 为 store.getters.doneTodosCount\n    doneCount: 'doneTodosCount'\n    })\n    }\n    }\n```\n\n### Mutations\n\n更改Vuex的store中的状态的唯一方法是提交mutation。Vuex的mutataions非常类似于事件：每个mutation都有一个字符串的事件类型（type）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，他会接受state作为第一个参数：\n\n```JavaScript\n    const store = new Vuex.Store({\n    state: {\n            count: 1\n    },\n    mutations: {\n            increment (state) {\n        // 变更状态\n        state.count++\n            }\n    }\n    })\n```\n\n上边注册了一个类型为increment的mutation：“当触发一个类型为increment的mutation时，调用此函数。”实际使用时：store.commit('increment')\n\n### 使用常量替代Mutation事件类型\n\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```JavaScript \n  //mutation-types.js\n\n  export const SOME_MUTATION = 'SOME_MUTATION'\n```\n\n```JavaScript\n    //store.js\n    import Vuex from 'vuex'\n    import * as types from './mutation-types'\n\n    const store = new Vuex.Store({\n    state: { ... },\n    mutations: {\n      // 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名\n      [types.SOME_MUTATION] (state) {\n      // mutate state\n      }\n     }\n    })\n```\n\nmutation必须是同步函数你可以在组件中使用this.store.commit('type')提交mutataion，或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用（需要在根节点注入store）。\n\n```JavaScript\n    import { mapMutations } from 'vuex'\n\n    export default {\n    // ...\n    methods: {\n      ...mapMutations([\n      'increment' // 映射 this.increment() 为 this.$store.commit('increment')\n    ]),\n    ...mapMutations({\n       add: 'increment' // 映射 this.add() 为 this.$store.commit('increment')\n    })\n    }\n    }\n```\n\n### Actions\n\nAction类似于mutation，不同之处在于：\n\nAction提交的是mutataion，而不是直接变更状态。\nAction可以包含任意异步操作。\n注册一个简单的Action：\n\n```JavaScript\n    const store = new Vuex.Store({\n    state: {\n        count: 0\n    },\n    mutations: {\n        increment (state) {\n        state.count++\n        }\n    },\n    actions: {\n        increment (context) {\n        context.commit('increment')\n        }\n    }\n    })\n```\n\nAction 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。\n\n>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。\n\n```JavaScript\n    //例如：赋值  var [a,b,c] = [1,2,3]\n    //例如：交换变量 [x,y] = [y,x]\n    //例如：函数参数解构：\n    // function add([x, y]){\n    //   return x + y;\n    // }\n    //实践中我们常用到 参数解构 来简化代码，下边\n    //的 { commit } 就用到了解构。\n\n    actions: {\n    increment ({ commit }) {\n        commit('increment')\n    }\n}\n```\n这里解构的对象是context对象，也就是说context <==> { commit }，这样写就可以用commit替代context.commit，简化代码。\n\n### 分发Action\n\nAction通过store.dispatch方法触发：store.dispatch('increment') Actions 支持同样的载荷方式和对象方式进行分发：\n\n* 以载荷形式分发\n```JavaScript\n    store.dispatch('incrementAsync', {\n        amount: 10\n    })\n```\n* 以对象形式分发\n```JavaScript\nstore.dispatch({\n  type: 'incrementAsync',\n  amount: 10\n})\n```\n我们可以在Action内部执行异步操作：\n```JavaScript\nactions: {\n  incrementAsync ({ commit }) {\n    setTimeout(() => {\n      commit('increment')\n    }, 1000)\n  }\n}\n```\n* 在组件中分发Action\n\n你在组件中使用 this.$store.dispatch('xxx') 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：\n```JavaScript\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n       'increment' // 映射 this.increment() 为 this.$store.dispatch('increment')\n    ]),\n    ...mapActions({\n       add: 'increment' // 映射 this.add() 为 this.$store.dispatch('increment')\n    })\n  }\n}\n```\n\n### Modules\n使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。\n\n为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：\n\n```JavaScript\nconst moduleA = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... },\n  getters: { ... }\n}\n\nconst moduleB = {\n  state: { ... },\n  mutations: { ... },\n  actions: { ... }\n}\n\nconst store = new Vuex.Store({\n  modules: {\n    a: moduleA,\n    b: moduleB\n  }\n})\n\nstore.state.a // -> moduleA 的状态\nstore.state.b // -> moduleB 的状态\n```\n","slug":"vuex","published":1,"date":"2017-06-16T08:26:36.000Z","updated":"2017-06-16T08:26:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4ai00015gvk9607xs91m","content":"<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><blockquote>\n<p>vuex是为vue.js开发的状态管理模式，存储应用中的所有数据状态，便于统一管理。它是应用中唯一的数据源，所以一个应用中只有一个store实例。</p>\n</blockquote>\n<h3 id=\"安装和使用\"><a href=\"#安装和使用\" class=\"headerlink\" title=\"安装和使用\"></a>安装和使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Vuex用过store选项，提供了一种机制，将数据从跟组件注入到每个子组件中（需要调用Vue.use(Vuex)）:</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>\n<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p>通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中。且子组件能通过this.$store访问到</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Counter = &#123;</span><br><span class=\"line\">     template: <span class=\"string\">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class=\"line\">     <span class=\"comment\">//从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：</span></span><br><span class=\"line\">     computed: &#123;</span><br><span class=\"line\">         count () &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapState辅助函数\"><a href=\"#mapState辅助函数\" class=\"headerlink\" title=\"mapState辅助函数\"></a>mapState辅助函数</h3><p>当一个组件需要获取多个状态时，逐个声明计算属性会很麻烦，为此我们可以使用mapState辅助函数帮我们生成： // 在单独构建的版本中辅助函数为 Vuex.mapState</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*三种不同的方式*/</span></span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可使代码更简练</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">        countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class=\"line\">        countPlusLocalState (state) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上边我们给mapState传了一个对象，如果我们要生成的计算属性名称与state子节点名称相同时，也可以直接给mapState传入一个字符串数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">   <span class=\"comment\">// 映射 this.count 为 store.state.count</span></span><br><span class=\"line\">   <span class=\"string\">'count'</span></span><br><span class=\"line\"> ])</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象展开运算符\"><a href=\"#对象展开运算符\" class=\"headerlink\" title=\"对象展开运算符\"></a>对象展开运算符</h3><p>mapState函数返回的是一个对象，但是一个组件中的计算属性，不仅有来自store的，还有它局部的。那么如何混用呢？我们使用对象展开运算符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">     <span class=\"comment\">//localComputed 是组件的局部计算属性</span></span><br><span class=\"line\">     localComputed () &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">     <span class=\"comment\">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class=\"line\">     ...mapState(&#123;</span><br><span class=\"line\">       <span class=\"comment\">// ...</span></span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h3><p>有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">   doneTodosCount () &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done).length</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vuex允许我们在store中定义getters（可以认为是store的计算属性）。getter接受state作为第一个参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在'store/index.js'中</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">      state: &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">text</span>: <span class=\"string\">'...'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">           &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">text</span>: <span class=\"string\">'...'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      getters: &#123;</span><br><span class=\"line\">            doneTodos: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// getters也可以接受其他getters作为第二个参数</span></span><br><span class=\"line\">        doneTodosCount: <span class=\"function\">(<span class=\"params\">state, getters</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> getters.doneTodos.length</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapGetters辅助函数\"><a href=\"#mapGetters辅助函数\" class=\"headerlink\" title=\"mapGetters辅助函数\"></a>mapGetters辅助函数</h3><p>mapGetters辅助函数仅仅是将store中的getters映射到局部计算属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\"><span class=\"comment\">// 使用对象展开运算符将 getters 混入 computed 对象中</span></span><br><span class=\"line\">...mapGetters([</span><br><span class=\"line\"><span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\"><span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"comment\">//如果想给getter属性领取一个名字，可以对象形式：</span></span><br><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\"><span class=\"comment\">// 映射 this.doneCount 为 store.getters.doneTodosCount</span></span><br><span class=\"line\">doneCount: <span class=\"string\">'doneTodosCount'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mutations\"><a href=\"#Mutations\" class=\"headerlink\" title=\"Mutations\"></a>Mutations</h3><p>更改Vuex的store中的状态的唯一方法是提交mutation。Vuex的mutataions非常类似于事件：每个mutation都有一个字符串的事件类型（type）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，他会接受state作为第一个参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">        count: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">        increment (state) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 变更状态</span></span><br><span class=\"line\">    state.count++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上边注册了一个类型为increment的mutation：“当触发一个类型为increment的mutation时，调用此函数。”实际使用时：store.commit(‘increment’)</p>\n<h3 id=\"使用常量替代Mutation事件类型\"><a href=\"#使用常量替代Mutation事件类型\" class=\"headerlink\" title=\"使用常量替代Mutation事件类型\"></a>使用常量替代Mutation事件类型</h3><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mutation-types.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SOME_MUTATION = <span class=\"string\">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//store.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'./mutation-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123; ... &#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class=\"line\">  [types.SOME_MUTATION] (state) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// mutate state</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>mutation必须是同步函数你可以在组件中使用this.store.commit(‘type’)提交mutataion，或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用（需要在根节点注入store）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapMutations([</span><br><span class=\"line\">  <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 为 this.$store.commit('increment')</span></span><br><span class=\"line\">]),</span><br><span class=\"line\">...mapMutations(&#123;</span><br><span class=\"line\">   add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 为 this.$store.commit('increment')</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>Action类似于mutation，不同之处在于：</p>\n<p>Action提交的是mutataion，而不是直接变更状态。<br>Action可以包含任意异步操作。<br>注册一个简单的Action：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">    state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    increment (context) &#123;</span><br><span class=\"line\">    context.commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。</p>\n<blockquote>\n<p>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//例如：赋值  var [a,b,c] = [1,2,3]</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：交换变量 [x,y] = [y,x]</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：函数参数解构：</span></span><br><span class=\"line\">    <span class=\"comment\">// function add([x, y])&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   return x + y;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//实践中我们常用到 参数解构 来简化代码，下边</span></span><br><span class=\"line\">    <span class=\"comment\">//的 &#123; commit &#125; 就用到了解构。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">    increment (&#123; commit &#125;) &#123;</span><br><span class=\"line\">        commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里解构的对象是context对象，也就是说context &lt;==&gt; { commit }，这样写就可以用commit替代context.commit，简化代码。</p>\n<h3 id=\"分发Action\"><a href=\"#分发Action\" class=\"headerlink\" title=\"分发Action\"></a>分发Action</h3><p>Action通过store.dispatch方法触发：store.dispatch(‘increment’) Actions 支持同样的载荷方式和对象方式进行分发：</p>\n<ul>\n<li><p>以载荷形式分发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(<span class=\"string\">'incrementAsync'</span>, &#123;</span><br><span class=\"line\">    amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以对象形式分发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'incrementAsync'</span>,</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们可以在Action内部执行异步操作：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>在组件中分发Action</li>\n</ul>\n<p>你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">       <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 为 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">       add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 为 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Vuex\"><a href=\"#Vuex\" class=\"headerlink\" title=\"Vuex\"></a>Vuex</h2><blockquote>\n<p>vuex是为vue.js开发的状态管理模式，存储应用中的所有数据状态，便于统一管理。它是应用中唯一的数据源，所以一个应用中只有一个store实例。</p>\n</blockquote>\n<h3 id=\"安装和使用\"><a href=\"#安装和使用\" class=\"headerlink\" title=\"安装和使用\"></a>安装和使用</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> Vue <span class=\"keyword\">from</span> <span class=\"string\">'vue'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//Vuex用过store选项，提供了一种机制，将数据从跟组件注入到每个子组件中（需要调用Vue.use(Vuex)）:</span></span><br><span class=\"line\"></span><br><span class=\"line\">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>\n<h3 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h3><p>通过在根实例中注册store选项，该store实例会注入到根组件下的所有子组件中。且子组件能通过this.$store访问到</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> Counter = &#123;</span><br><span class=\"line\">     template: <span class=\"string\">`&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`</span>,</span><br><span class=\"line\">     <span class=\"comment\">//从 store 实例中读取状态最简单的方法就是在计算属性中返回某个状态：</span></span><br><span class=\"line\">     computed: &#123;</span><br><span class=\"line\">         count () &#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.count</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapState辅助函数\"><a href=\"#mapState辅助函数\" class=\"headerlink\" title=\"mapState辅助函数\"></a>mapState辅助函数</h3><p>当一个组件需要获取多个状态时，逐个声明计算属性会很麻烦，为此我们可以使用mapState辅助函数帮我们生成： // 在单独构建的版本中辅助函数为 Vuex.mapState</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapState &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  computed: mapState(&#123;</span><br><span class=\"line\">         <span class=\"comment\">/*三种不同的方式*/</span></span><br><span class=\"line\">    <span class=\"comment\">// 箭头函数可使代码更简练</span></span><br><span class=\"line\">    count: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> state.count,</span><br><span class=\"line\">    <span class=\"comment\">// 传字符串参数 'count' 等同于 `state =&gt; state.count`</span></span><br><span class=\"line\">        countAlias: <span class=\"string\">'count'</span>,</span><br><span class=\"line\">        <span class=\"comment\">// 为了能够使用 `this` 获取局部状态，必须使用常规函数</span></span><br><span class=\"line\">        countPlusLocalState (state) &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state.count + <span class=\"keyword\">this</span>.localCount</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上边我们给mapState传了一个对象，如果我们要生成的计算属性名称与state子节点名称相同时，也可以直接给mapState传入一个字符串数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: mapState([</span><br><span class=\"line\">   <span class=\"comment\">// 映射 this.count 为 store.state.count</span></span><br><span class=\"line\">   <span class=\"string\">'count'</span></span><br><span class=\"line\"> ])</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象展开运算符\"><a href=\"#对象展开运算符\" class=\"headerlink\" title=\"对象展开运算符\"></a>对象展开运算符</h3><p>mapState函数返回的是一个对象，但是一个组件中的计算属性，不仅有来自store的，还有它局部的。那么如何混用呢？我们使用对象展开运算符：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">     <span class=\"comment\">//localComputed 是组件的局部计算属性</span></span><br><span class=\"line\">     localComputed () &#123; <span class=\"comment\">/* ... */</span> &#125;,</span><br><span class=\"line\">     <span class=\"comment\">// 使用对象展开运算符将此对象混入到外部对象中</span></span><br><span class=\"line\">     ...mapState(&#123;</span><br><span class=\"line\">       <span class=\"comment\">// ...</span></span><br><span class=\"line\">     &#125;)</span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Getters\"><a href=\"#Getters\" class=\"headerlink\" title=\"Getters\"></a>Getters</h3><p>有时候我们需要从store中的state中派生出一些状态，例如对列表进行过滤并计数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">   doneTodosCount () &#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.$store.state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done).length</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>Vuex允许我们在store中定义getters（可以认为是store的计算属性）。getter接受state作为第一个参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 在'store/index.js'中</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">      state: &#123;</span><br><span class=\"line\">        todos: [</span><br><span class=\"line\">          &#123; <span class=\"attr\">id</span>: <span class=\"number\">1</span>, <span class=\"attr\">text</span>: <span class=\"string\">'...'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">true</span> &#125;,</span><br><span class=\"line\">           &#123; <span class=\"attr\">id</span>: <span class=\"number\">2</span>, <span class=\"attr\">text</span>: <span class=\"string\">'...'</span>, <span class=\"attr\">done</span>: <span class=\"literal\">false</span> &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      getters: &#123;</span><br><span class=\"line\">            doneTodos: <span class=\"function\"><span class=\"params\">state</span> =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> state.todos.filter(<span class=\"function\"><span class=\"params\">todo</span> =&gt;</span> todo.done)</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// getters也可以接受其他getters作为第二个参数</span></span><br><span class=\"line\">        doneTodosCount: <span class=\"function\">(<span class=\"params\">state, getters</span>) =&gt;</span> &#123;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> getters.doneTodos.length</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"mapGetters辅助函数\"><a href=\"#mapGetters辅助函数\" class=\"headerlink\" title=\"mapGetters辅助函数\"></a>mapGetters辅助函数</h3><p>mapGetters辅助函数仅仅是将store中的getters映射到局部计算属性：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapGetters &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">computed: &#123;</span><br><span class=\"line\"><span class=\"comment\">// 使用对象展开运算符将 getters 混入 computed 对象中</span></span><br><span class=\"line\">...mapGetters([</span><br><span class=\"line\"><span class=\"string\">'doneTodosCount'</span>,</span><br><span class=\"line\"><span class=\"string\">'anotherGetter'</span>,</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">])</span><br><span class=\"line\"><span class=\"comment\">//如果想给getter属性领取一个名字，可以对象形式：</span></span><br><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\"><span class=\"comment\">// 映射 this.doneCount 为 store.getters.doneTodosCount</span></span><br><span class=\"line\">doneCount: <span class=\"string\">'doneTodosCount'</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mutations\"><a href=\"#Mutations\" class=\"headerlink\" title=\"Mutations\"></a>Mutations</h3><p>更改Vuex的store中的状态的唯一方法是提交mutation。Vuex的mutataions非常类似于事件：每个mutation都有一个字符串的事件类型（type）和一个回调函数（handler）。这个回调函数就是我们实际进行状态更改的地方，他会接受state作为第一个参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">        count: <span class=\"number\">1</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">        increment (state) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 变更状态</span></span><br><span class=\"line\">    state.count++</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>上边注册了一个类型为increment的mutation：“当触发一个类型为increment的mutation时，调用此函数。”实际使用时：store.commit(‘increment’)</p>\n<h3 id=\"使用常量替代Mutation事件类型\"><a href=\"#使用常量替代Mutation事件类型\" class=\"headerlink\" title=\"使用常量替代Mutation事件类型\"></a>使用常量替代Mutation事件类型</h3><p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//mutation-types.js</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">const</span> SOME_MUTATION = <span class=\"string\">'SOME_MUTATION'</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//store.js</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> Vuex <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> * <span class=\"keyword\">as</span> types <span class=\"keyword\">from</span> <span class=\"string\">'./mutation-types'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123; ... &#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class=\"line\">  [types.SOME_MUTATION] (state) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// mutate state</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>mutation必须是同步函数你可以在组件中使用this.store.commit(‘type’)提交mutataion，或者使用mapMutations辅助函数将组件中的methods映射为store.commit调用（需要在根节点注入store）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapMutations &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">methods: &#123;</span><br><span class=\"line\">  ...mapMutations([</span><br><span class=\"line\">  <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 为 this.$store.commit('increment')</span></span><br><span class=\"line\">]),</span><br><span class=\"line\">...mapMutations(&#123;</span><br><span class=\"line\">   add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 为 this.$store.commit('increment')</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Actions\"><a href=\"#Actions\" class=\"headerlink\" title=\"Actions\"></a>Actions</h3><p>Action类似于mutation，不同之处在于：</p>\n<p>Action提交的是mutataion，而不是直接变更状态。<br>Action可以包含任意异步操作。<br>注册一个简单的Action：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">state: &#123;</span><br><span class=\"line\">    count: <span class=\"number\">0</span></span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">mutations: &#123;</span><br><span class=\"line\">    increment (state) &#123;</span><br><span class=\"line\">    state.count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">actions: &#123;</span><br><span class=\"line\">    increment (context) &#123;</span><br><span class=\"line\">    context.commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。当我们在之后介绍到 Modules 时，你就知道 context 对象为什么不是 store 实例本身了。</p>\n<blockquote>\n<p>解构：ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值。</p>\n</blockquote>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">    <span class=\"comment\">//例如：赋值  var [a,b,c] = [1,2,3]</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：交换变量 [x,y] = [y,x]</span></span><br><span class=\"line\">    <span class=\"comment\">//例如：函数参数解构：</span></span><br><span class=\"line\">    <span class=\"comment\">// function add([x, y])&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//   return x + y;</span></span><br><span class=\"line\">    <span class=\"comment\">// &#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//实践中我们常用到 参数解构 来简化代码，下边</span></span><br><span class=\"line\">    <span class=\"comment\">//的 &#123; commit &#125; 就用到了解构。</span></span><br><span class=\"line\"></span><br><span class=\"line\">    actions: &#123;</span><br><span class=\"line\">    increment (&#123; commit &#125;) &#123;</span><br><span class=\"line\">        commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这里解构的对象是context对象，也就是说context &lt;==&gt; { commit }，这样写就可以用commit替代context.commit，简化代码。</p>\n<h3 id=\"分发Action\"><a href=\"#分发Action\" class=\"headerlink\" title=\"分发Action\"></a>分发Action</h3><p>Action通过store.dispatch方法触发：store.dispatch(‘increment’) Actions 支持同样的载荷方式和对象方式进行分发：</p>\n<ul>\n<li><p>以载荷形式分发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(<span class=\"string\">'incrementAsync'</span>, &#123;</span><br><span class=\"line\">    amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>以对象形式分发</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">store.dispatch(&#123;</span><br><span class=\"line\">  type: <span class=\"string\">'incrementAsync'</span>,</span><br><span class=\"line\">  amount: <span class=\"number\">10</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>我们可以在Action内部执行异步操作：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">actions: &#123;</span><br><span class=\"line\">  incrementAsync (&#123; commit &#125;) &#123;</span><br><span class=\"line\">    setTimeout(<span class=\"function\"><span class=\"params\">()</span> =&gt;</span> &#123;</span><br><span class=\"line\">      commit(<span class=\"string\">'increment'</span>)</span><br><span class=\"line\">    &#125;, <span class=\"number\">1000</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>在组件中分发Action</li>\n</ul>\n<p>你在组件中使用 this.$store.dispatch(‘xxx’) 分发 action，或者使用 mapActions 辅助函数将组件的 methods 映射为 store.dispatch 调用（需要先在根节点注入 store）：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> &#123; mapActions &#125; <span class=\"keyword\">from</span> <span class=\"string\">'vuex'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">  methods: &#123;</span><br><span class=\"line\">    ...mapActions([</span><br><span class=\"line\">       <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.increment() 为 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    ]),</span><br><span class=\"line\">    ...mapActions(&#123;</span><br><span class=\"line\">       add: <span class=\"string\">'increment'</span> <span class=\"comment\">// 映射 this.add() 为 this.$store.dispatch('increment')</span></span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Modules\"><a href=\"#Modules\" class=\"headerlink\" title=\"Modules\"></a>Modules</h3><p>使用单一状态树，导致应用的所有状态集中到一个很大的对象。但是，当应用变得很大时，store 对象会变得臃肿不堪。</p>\n<p>为了解决以上问题，Vuex 允许我们将 store 分割到模块（module）。每个模块拥有自己的 state、mutation、action、getters、甚至是嵌套子模块——从上至下进行类似的分割：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> moduleA = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;,</span><br><span class=\"line\">  getters: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> moduleB = &#123;</span><br><span class=\"line\">  state: &#123; ... &#125;,</span><br><span class=\"line\">  mutations: &#123; ... &#125;,</span><br><span class=\"line\">  actions: &#123; ... &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> store = <span class=\"keyword\">new</span> Vuex.Store(&#123;</span><br><span class=\"line\">  modules: &#123;</span><br><span class=\"line\">    a: moduleA,</span><br><span class=\"line\">    b: moduleB</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">store.state.a <span class=\"comment\">// -&gt; moduleA 的状态</span></span><br><span class=\"line\">store.state.b <span class=\"comment\">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>\n"},{"title":"http协议及浏览器原理","_content":"\n> HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议，用于浏览器和服务器的通信。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示等。默认HTTP的端口号为80.\n\n### 常用的请求方式\n\n常用的请求方式是GET和POST.\n\n* GET方式：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。\n\n* POST方式：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能：\n\n1：对现有资源的解释;\n2：向电子公告栏、新闻组、邮件列表或类似讨论组发信息;\n3：提交数据块;\n4：通过附加操作来扩展数据库 。\n\n从上面描述可以看出，Get是向服务器发索取数据的一种请求;而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。\n\nGET与POST方法有以下区别：\n\n(1) 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到;POST方式，数据放置在HTML HEADER内提交。\n(2) GET方式提交的数据最多只能有1024字节，而POST则没有此限制。\n(3) 安全性问题。正如在(1)中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get;如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好.\n(4) 安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了(比方说文章下面出现一条注解)。\n\n</br>\n###  请求头\nHTTP最常见的请求头如下：\n\n* Accept：浏览器可接受的MIME类型;\n\n* Accept-Charset：浏览器可接受的字符集;\n\n* Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间;\n\n* Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到;\n\n* Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中;\n\n* Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1(HTTP 1.1默认进行持久连接)，它就可以利用持久连接的优点，当页面包含多个元素时(例如Applet，图片)，显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小;\n\n* Content-Length：表示请求消息正文的长度;\n\n* Cookie：这是最重要的请求头信息之一;\n\n* From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它;\n\n* Host：初始URL中的主机和端口;\n\n* If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答;\n\n* Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝;\n\n* Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。\n\n* User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用;\n\n* UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。\n\n</br>\n\n###  响应头\nHTTP最常见的响应头如下所示：\n* Allow：服务器支持哪些请求方法(如GET、POST等);\n\n* Content-Encoding：文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头(即request.getHeader(\"Accept-Encoding\"))检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面;\n\n* Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容;\n\n* Content-Type： 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系;\n\n* Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦;\n\n* Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。\n\n* Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。Last-Modified也可用setDateHeader方法来设置;\n\n* Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302;\n\n* Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=http://host/path\")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的 实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是 。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但 Netscape和IE都支持它。\n\n</br>\n\n### 实体头\n\n> 实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。\n\n* Allow：GET,POST\n* Content-Encoding：文档的编码(Encode)方法，例如：gzip，见“2.5 响应头”;\n* Content-Language：内容的语言类型，例如：zh-cn;\n* Content-Length：表示内容长度，eg：80，可参考“2.5响应头”;\n* Content-Location：表示客户应当到哪里去提取文档，例如：http://www.dfdf.org/dfdf.html，可参考“2.5响应头”;\n\n* Content-MD5：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5:  。Eg2：dfdfdfdfdfdfdff==;\n\n* Content-Range：随部分实体一同发送;标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898\n\n* Content-Type：标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312 主类型/子类型;\n\n* Expires：为0证明不缓存;\n\n* Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT.\n\n</br>\n\n### 扩展头\n\n> 在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。\n> 现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。\n\n* Refresh：1;url=http://www.dfdf.org //过1秒跳转到指定位置;\n\n* Content-Disposition：头字段,可参考“2.5响应头”;\n\n* Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型。\n\n* eg1：Content-Type：application/xml ;\n\n* eg2：applicaiton/octet-stream;\n\n* Content-Disposition：attachment; filename=aaa.zip。\n\n\n\n\n</br>\n\n### HTTP协议通信过程\n> 当我们在浏览器的地址栏输入“www.baidu.com”然后按回车，我们直接看到的是打开了对应的网页，内部客户端和服务端的通信：\n \n1、URL自动解析\n        HTTP URL包含了用于查找某个资源的足够信息，基本格式如下：HTTP://host[“:”port][abs_path]，其中HTTP表示桶盖HTTP协议来定位网络资源；host表示合法的主机域名或IP地址，port指定一个端口号，缺省80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。\n例如：输入www.163.com;浏览器会自动转换成：HTTP://www.163.com/\n2、获取IP，建立TCP连接\n       浏览器地址栏中输入\"HTTP://www.xxx.com/\"并提交之后，首先它会在DNS本地缓存表中查找，如果有则直接告诉IP地址。如果没有则要求网关DNS进行查找，如此下去，找到对应的IP后，则返回会给浏览器。\n当获取IP之后，就开始与所请求的Tcp建立三次握手连接，连接建立后，就向服务器发出HTTP请求。\n \n3、客户端浏览器向服务器发出HTTP请求\n      一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令，接着以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n \n4、Web服务器应答，并向浏览器发送数据\n       客户机向服务器发出请求后，服务器会客户机回送应答，HTTP/1.1 200 OK\n      应答的第一部分是协议的版本号和应答状态码，正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n       Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据\n \n5、Web服务器关闭TCP连接\n      一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive， TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n\n\n</br>\n\n### http状态码有那些？分别代表是什么意思？\n```javascript\n      [\n          100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n          200  OK         正常返回信息\n          201  Created      请求成功并且服务器创建了新的资源\n          202  Accepted     服务器已接受请求，但尚未处理\n          301  Moved Permanently  请求的网页已永久移动到新位置。\n          302 Found          临时性重定向。\n          303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。\n          304  Not Modified 自从上次请求后，请求的网页未修改过。\n\n          400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n          401 Unauthorized 请求未授权。\n          403 Forbidden      禁止访问。\n          404 Not Found      找不到如何与 URI 相匹配的资源。\n\n          500 Internal Server Error  最常见的服务器端错误。\n          503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n      ]\n\n    完整版\n    1**(信息类)：表示接收到请求并且继续处理\n      100——客户必须继续发出请求\n      101——客户要求服务器根据请求转换HTTP协议版本\n\n    2**(响应成功)：表示动作被成功接收、理解和接受\n      200——表明该请求被成功地完成，所请求的资源发送回客户端\n      201——提示知道新文件的URL\n      202——接受和处理、但处理未完成\n      203——返回信息不确定或不完整\n      204——请求收到，但返回信息为空\n      205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n      206——服务器已经完成了部分用户的GET请求\n\n    3**(重定向类)：为了完成指定的动作，必须接受进一步处理\n      300——请求的资源可在多处得到\n      301——本网页被永久性转移到另一个URL\n      302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。\n      303——建议客户访问其他URL或访问方式\n      304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用\n      305——请求的资源必须从服务器指定的地址得到\n      306——前一版本HTTP中使用的代码，现行版本中不再使用\n      307——申明请求的资源临时性删除\n\n    4**(客户端错误类)：请求包含错误语法或不能正确执行\n      400——客户端请求有语法错误，不能被服务器所理解\n      401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n      HTTP 401.1 - 未授权：登录失败\n      　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败\n      　　HTTP 401.3 - ACL 禁止访问资源\n      　　HTTP 401.4 - 未授权：授权被筛选器拒绝\n      HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败\n      402——保留有效ChargeTo头响应\n      403——禁止访问，服务器收到请求，但是拒绝提供服务\n      HTTP 403.1 禁止访问：禁止可执行访问\n      　　HTTP 403.2 - 禁止访问：禁止读访问\n      　　HTTP 403.3 - 禁止访问：禁止写访问\n      　　HTTP 403.4 - 禁止访问：要求 SSL\n      　　HTTP 403.5 - 禁止访问：要求 SSL 128\n      　　HTTP 403.6 - 禁止访问：IP 地址被拒绝\n      　　HTTP 403.7 - 禁止访问：要求客户证书\n      　　HTTP 403.8 - 禁止访问：禁止站点访问\n      　　HTTP 403.9 - 禁止访问：连接的用户过多\n      　　HTTP 403.10 - 禁止访问：配置无效\n      　　HTTP 403.11 - 禁止访问：密码更改\n      　　HTTP 403.12 - 禁止访问：映射器拒绝访问\n      　　HTTP 403.13 - 禁止访问：客户证书已被吊销\n      　　HTTP 403.15 - 禁止访问：客户访问许可过多\n      　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效\n      HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效\n      404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL\n      405——用户在Request-Line字段定义的方法不允许\n      406——根据用户发送的Accept拖，请求资源不可访问\n      407——类似401，用户必须首先在代理服务器上得到授权\n      408——客户端没有在用户指定的饿时间内完成请求\n      409——对当前资源状态，请求不能完成\n      410——服务器上不再有此资源且无进一步的参考地址\n      411——服务器拒绝用户定义的Content-Length属性请求\n      412——一个或多个请求头字段在当前请求中错误\n      413——请求的资源大于服务器允许的大小\n      414——请求的资源URL长于服务器允许的长度\n      415——请求资源不支持请求项目格式\n      416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n      417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。\n\n    5**(服务端错误类)：服务器不能正确执行一个正确的请求\n      HTTP 500 - 服务器遇到错误，无法完成请求\n      　　HTTP 500.100 - 内部服务器错误 - ASP 错误\n      　　HTTP 500-11 服务器关闭\n      　　HTTP 500-12 应用程序重新启动\n      　　HTTP 500-13 - 服务器太忙\n      　　HTTP 500-14 - 应用程序无效\n      　　HTTP 500-15 - 不允许请求 global.asa\n      　　Error 501 - 未实现\n    HTTP 502 - 网关错误\n    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常\n```\n</br>\n### https\n\n> HTTPS(全称：Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，https所用的端口号是443。\n\n### https的实现原理\n有两种基本的加解密算法类型：\n\n1)对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等;\n\n2)非对称加密：密钥成对出现(且根据公钥无法推知私钥，根据私钥也无法推知公钥)，加密解密使用不同密钥(公钥加密需要私钥解密，私钥加密需要公钥解密)，相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。\n\n### https通信的优点：\n1)客户端产生的密钥只有客户端和服务器端能得到;\n2)加密的数据只有客户端和服务器端才能得到明文;\n3)客户端到服务端的通信是安全的。\n\n\n\n### 浏览器的渲染过程\n\n1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。\n2、CSS文件下载完成，开始构建CSSOM\n3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。\n4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。\n5、最后一步，按照算出来的规则，把内容渲染到屏幕上。\n\n以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。","source":"_posts/http.md","raw":"---\ntitle: http协议及浏览器原理\ncategories:  http\ntags: \n- http\n---\n\n> HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议，用于浏览器和服务器的通信。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示等。默认HTTP的端口号为80.\n\n### 常用的请求方式\n\n常用的请求方式是GET和POST.\n\n* GET方式：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。\n\n* POST方式：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能：\n\n1：对现有资源的解释;\n2：向电子公告栏、新闻组、邮件列表或类似讨论组发信息;\n3：提交数据块;\n4：通过附加操作来扩展数据库 。\n\n从上面描述可以看出，Get是向服务器发索取数据的一种请求;而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。\n\nGET与POST方法有以下区别：\n\n(1) 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到;POST方式，数据放置在HTML HEADER内提交。\n(2) GET方式提交的数据最多只能有1024字节，而POST则没有此限制。\n(3) 安全性问题。正如在(1)中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get;如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好.\n(4) 安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了(比方说文章下面出现一条注解)。\n\n</br>\n###  请求头\nHTTP最常见的请求头如下：\n\n* Accept：浏览器可接受的MIME类型;\n\n* Accept-Charset：浏览器可接受的字符集;\n\n* Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间;\n\n* Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到;\n\n* Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中;\n\n* Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1(HTTP 1.1默认进行持久连接)，它就可以利用持久连接的优点，当页面包含多个元素时(例如Applet，图片)，显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小;\n\n* Content-Length：表示请求消息正文的长度;\n\n* Cookie：这是最重要的请求头信息之一;\n\n* From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它;\n\n* Host：初始URL中的主机和端口;\n\n* If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答;\n\n* Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝;\n\n* Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。\n\n* User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用;\n\n* UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。\n\n</br>\n\n###  响应头\nHTTP最常见的响应头如下所示：\n* Allow：服务器支持哪些请求方法(如GET、POST等);\n\n* Content-Encoding：文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头(即request.getHeader(\"Accept-Encoding\"))检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面;\n\n* Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容;\n\n* Content-Type： 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系;\n\n* Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦;\n\n* Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。\n\n* Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。Last-Modified也可用setDateHeader方法来设置;\n\n* Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302;\n\n* Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(\"Refresh\", \"5; URL=http://host/path\")让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的 实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是 。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但 Netscape和IE都支持它。\n\n</br>\n\n### 实体头\n\n> 实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。\n\n* Allow：GET,POST\n* Content-Encoding：文档的编码(Encode)方法，例如：gzip，见“2.5 响应头”;\n* Content-Language：内容的语言类型，例如：zh-cn;\n* Content-Length：表示内容长度，eg：80，可参考“2.5响应头”;\n* Content-Location：表示客户应当到哪里去提取文档，例如：http://www.dfdf.org/dfdf.html，可参考“2.5响应头”;\n\n* Content-MD5：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5:  。Eg2：dfdfdfdfdfdfdff==;\n\n* Content-Range：随部分实体一同发送;标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898\n\n* Content-Type：标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312 主类型/子类型;\n\n* Expires：为0证明不缓存;\n\n* Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT.\n\n</br>\n\n### 扩展头\n\n> 在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。\n> 现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。\n\n* Refresh：1;url=http://www.dfdf.org //过1秒跳转到指定位置;\n\n* Content-Disposition：头字段,可参考“2.5响应头”;\n\n* Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型。\n\n* eg1：Content-Type：application/xml ;\n\n* eg2：applicaiton/octet-stream;\n\n* Content-Disposition：attachment; filename=aaa.zip。\n\n\n\n\n</br>\n\n### HTTP协议通信过程\n> 当我们在浏览器的地址栏输入“www.baidu.com”然后按回车，我们直接看到的是打开了对应的网页，内部客户端和服务端的通信：\n \n1、URL自动解析\n        HTTP URL包含了用于查找某个资源的足够信息，基本格式如下：HTTP://host[“:”port][abs_path]，其中HTTP表示桶盖HTTP协议来定位网络资源；host表示合法的主机域名或IP地址，port指定一个端口号，缺省80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。\n例如：输入www.163.com;浏览器会自动转换成：HTTP://www.163.com/\n2、获取IP，建立TCP连接\n       浏览器地址栏中输入\"HTTP://www.xxx.com/\"并提交之后，首先它会在DNS本地缓存表中查找，如果有则直接告诉IP地址。如果没有则要求网关DNS进行查找，如此下去，找到对应的IP后，则返回会给浏览器。\n当获取IP之后，就开始与所请求的Tcp建立三次握手连接，连接建立后，就向服务器发出HTTP请求。\n \n3、客户端浏览器向服务器发出HTTP请求\n      一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令，接着以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。\n \n4、Web服务器应答，并向浏览器发送数据\n       客户机向服务器发出请求后，服务器会客户机回送应答，HTTP/1.1 200 OK\n      应答的第一部分是协议的版本号和应答状态码，正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。\n       Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据\n \n5、Web服务器关闭TCP连接\n      一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive， TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。\n\n\n\n</br>\n\n### http状态码有那些？分别代表是什么意思？\n```javascript\n      [\n          100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n          200  OK         正常返回信息\n          201  Created      请求成功并且服务器创建了新的资源\n          202  Accepted     服务器已接受请求，但尚未处理\n          301  Moved Permanently  请求的网页已永久移动到新位置。\n          302 Found          临时性重定向。\n          303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。\n          304  Not Modified 自从上次请求后，请求的网页未修改过。\n\n          400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n          401 Unauthorized 请求未授权。\n          403 Forbidden      禁止访问。\n          404 Not Found      找不到如何与 URI 相匹配的资源。\n\n          500 Internal Server Error  最常见的服务器端错误。\n          503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n      ]\n\n    完整版\n    1**(信息类)：表示接收到请求并且继续处理\n      100——客户必须继续发出请求\n      101——客户要求服务器根据请求转换HTTP协议版本\n\n    2**(响应成功)：表示动作被成功接收、理解和接受\n      200——表明该请求被成功地完成，所请求的资源发送回客户端\n      201——提示知道新文件的URL\n      202——接受和处理、但处理未完成\n      203——返回信息不确定或不完整\n      204——请求收到，但返回信息为空\n      205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n      206——服务器已经完成了部分用户的GET请求\n\n    3**(重定向类)：为了完成指定的动作，必须接受进一步处理\n      300——请求的资源可在多处得到\n      301——本网页被永久性转移到另一个URL\n      302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。\n      303——建议客户访问其他URL或访问方式\n      304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用\n      305——请求的资源必须从服务器指定的地址得到\n      306——前一版本HTTP中使用的代码，现行版本中不再使用\n      307——申明请求的资源临时性删除\n\n    4**(客户端错误类)：请求包含错误语法或不能正确执行\n      400——客户端请求有语法错误，不能被服务器所理解\n      401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n      HTTP 401.1 - 未授权：登录失败\n      　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败\n      　　HTTP 401.3 - ACL 禁止访问资源\n      　　HTTP 401.4 - 未授权：授权被筛选器拒绝\n      HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败\n      402——保留有效ChargeTo头响应\n      403——禁止访问，服务器收到请求，但是拒绝提供服务\n      HTTP 403.1 禁止访问：禁止可执行访问\n      　　HTTP 403.2 - 禁止访问：禁止读访问\n      　　HTTP 403.3 - 禁止访问：禁止写访问\n      　　HTTP 403.4 - 禁止访问：要求 SSL\n      　　HTTP 403.5 - 禁止访问：要求 SSL 128\n      　　HTTP 403.6 - 禁止访问：IP 地址被拒绝\n      　　HTTP 403.7 - 禁止访问：要求客户证书\n      　　HTTP 403.8 - 禁止访问：禁止站点访问\n      　　HTTP 403.9 - 禁止访问：连接的用户过多\n      　　HTTP 403.10 - 禁止访问：配置无效\n      　　HTTP 403.11 - 禁止访问：密码更改\n      　　HTTP 403.12 - 禁止访问：映射器拒绝访问\n      　　HTTP 403.13 - 禁止访问：客户证书已被吊销\n      　　HTTP 403.15 - 禁止访问：客户访问许可过多\n      　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效\n      HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效\n      404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL\n      405——用户在Request-Line字段定义的方法不允许\n      406——根据用户发送的Accept拖，请求资源不可访问\n      407——类似401，用户必须首先在代理服务器上得到授权\n      408——客户端没有在用户指定的饿时间内完成请求\n      409——对当前资源状态，请求不能完成\n      410——服务器上不再有此资源且无进一步的参考地址\n      411——服务器拒绝用户定义的Content-Length属性请求\n      412——一个或多个请求头字段在当前请求中错误\n      413——请求的资源大于服务器允许的大小\n      414——请求的资源URL长于服务器允许的长度\n      415——请求资源不支持请求项目格式\n      416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n      417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。\n\n    5**(服务端错误类)：服务器不能正确执行一个正确的请求\n      HTTP 500 - 服务器遇到错误，无法完成请求\n      　　HTTP 500.100 - 内部服务器错误 - ASP 错误\n      　　HTTP 500-11 服务器关闭\n      　　HTTP 500-12 应用程序重新启动\n      　　HTTP 500-13 - 服务器太忙\n      　　HTTP 500-14 - 应用程序无效\n      　　HTTP 500-15 - 不允许请求 global.asa\n      　　Error 501 - 未实现\n    HTTP 502 - 网关错误\n    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常\n```\n</br>\n### https\n\n> HTTPS(全称：Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，https所用的端口号是443。\n\n### https的实现原理\n有两种基本的加解密算法类型：\n\n1)对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等;\n\n2)非对称加密：密钥成对出现(且根据公钥无法推知私钥，根据私钥也无法推知公钥)，加密解密使用不同密钥(公钥加密需要私钥解密，私钥加密需要公钥解密)，相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。\n\n### https通信的优点：\n1)客户端产生的密钥只有客户端和服务器端能得到;\n2)加密的数据只有客户端和服务器端才能得到明文;\n3)客户端到服务端的通信是安全的。\n\n\n\n### 浏览器的渲染过程\n\n1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。\n2、CSS文件下载完成，开始构建CSSOM\n3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。\n4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。\n5、最后一步，按照算出来的规则，把内容渲染到屏幕上。\n\n以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。","slug":"http","published":1,"date":"2017-09-08T13:14:08.000Z","updated":"2017-09-08T13:14:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4aia0019gvk921rab0ge","content":"<blockquote>\n<p>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议，用于浏览器和服务器的通信。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示等。默认HTTP的端口号为80.</p>\n</blockquote>\n<h3 id=\"常用的请求方式\"><a href=\"#常用的请求方式\" class=\"headerlink\" title=\"常用的请求方式\"></a>常用的请求方式</h3><p>常用的请求方式是GET和POST.</p>\n<ul>\n<li><p>GET方式：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。</p>\n</li>\n<li><p>POST方式：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能：</p>\n</li>\n</ul>\n<p>1：对现有资源的解释;<br>2：向电子公告栏、新闻组、邮件列表或类似讨论组发信息;<br>3：提交数据块;<br>4：通过附加操作来扩展数据库 。</p>\n<p>从上面描述可以看出，Get是向服务器发索取数据的一种请求;而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。</p>\n<p>GET与POST方法有以下区别：</p>\n<p>(1) 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到;POST方式，数据放置在HTML HEADER内提交。<br>(2) GET方式提交的数据最多只能有1024字节，而POST则没有此限制。<br>(3) 安全性问题。正如在(1)中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get;如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好.<br>(4) 安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了(比方说文章下面出现一条注解)。</p>\n<p><br></p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p>HTTP最常见的请求头如下：</p>\n<ul>\n<li><p>Accept：浏览器可接受的MIME类型;</p>\n</li>\n<li><p>Accept-Charset：浏览器可接受的字符集;</p>\n</li>\n<li><p>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间;</p>\n</li>\n<li><p>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到;</p>\n</li>\n<li><p>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中;</p>\n</li>\n<li><p>Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1(HTTP 1.1默认进行持久连接)，它就可以利用持久连接的优点，当页面包含多个元素时(例如Applet，图片)，显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小;</p>\n</li>\n<li><p>Content-Length：表示请求消息正文的长度;</p>\n</li>\n<li><p>Cookie：这是最重要的请求头信息之一;</p>\n</li>\n<li><p>From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它;</p>\n</li>\n<li><p>Host：初始URL中的主机和端口;</p>\n</li>\n<li><p>If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答;</p>\n</li>\n<li><p>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝;</p>\n</li>\n<li><p>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p>\n</li>\n<li><p>User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用;</p>\n</li>\n<li><p>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><p>HTTP最常见的响应头如下所示：</p>\n<ul>\n<li><p>Allow：服务器支持哪些请求方法(如GET、POST等);</p>\n</li>\n<li><p>Content-Encoding：文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头(即request.getHeader(“Accept-Encoding”))检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面;</p>\n</li>\n<li><p>Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容;</p>\n</li>\n<li><p>Content-Type： 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系;</p>\n</li>\n<li><p>Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦;</p>\n</li>\n<li><p>Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。</p>\n</li>\n<li><p>Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。Last-Modified也可用setDateHeader方法来设置;</p>\n</li>\n<li><p>Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302;</p>\n</li>\n<li><p>Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href=\"http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的\" target=\"_blank\" rel=\"noopener\">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的</a> 实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是 。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但 Netscape和IE都支持它。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"实体头\"><a href=\"#实体头\" class=\"headerlink\" title=\"实体头\"></a>实体头</h3><blockquote>\n<p>实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。</p>\n</blockquote>\n<ul>\n<li>Allow：GET,POST</li>\n<li>Content-Encoding：文档的编码(Encode)方法，例如：gzip，见“2.5 响应头”;</li>\n<li>Content-Language：内容的语言类型，例如：zh-cn;</li>\n<li>Content-Length：表示内容长度，eg：80，可参考“2.5响应头”;</li>\n<li><p>Content-Location：表示客户应当到哪里去提取文档，例如：<a href=\"http://www.dfdf.org/dfdf.html，可参考“2.5响应头”\" target=\"_blank\" rel=\"noopener\">http://www.dfdf.org/dfdf.html，可参考“2.5响应头”</a>;</p>\n</li>\n<li><p>Content-MD5：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5:  。Eg2：dfdfdfdfdfdfdff==;</p>\n</li>\n<li><p>Content-Range：随部分实体一同发送;标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898</p>\n</li>\n<li><p>Content-Type：标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312 主类型/子类型;</p>\n</li>\n<li><p>Expires：为0证明不缓存;</p>\n</li>\n<li><p>Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT.</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"扩展头\"><a href=\"#扩展头\" class=\"headerlink\" title=\"扩展头\"></a>扩展头</h3><blockquote>\n<p>在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。<br>现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。</p>\n</blockquote>\n<ul>\n<li><p>Refresh：1;url=<a href=\"http://www.dfdf.org\" target=\"_blank\" rel=\"noopener\">http://www.dfdf.org</a> //过1秒跳转到指定位置;</p>\n</li>\n<li><p>Content-Disposition：头字段,可参考“2.5响应头”;</p>\n</li>\n<li><p>Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型。</p>\n</li>\n<li><p>eg1：Content-Type：application/xml ;</p>\n</li>\n<li><p>eg2：applicaiton/octet-stream;</p>\n</li>\n<li><p>Content-Disposition：attachment; filename=aaa.zip。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"HTTP协议通信过程\"><a href=\"#HTTP协议通信过程\" class=\"headerlink\" title=\"HTTP协议通信过程\"></a>HTTP协议通信过程</h3><blockquote>\n<p>当我们在浏览器的地址栏输入“<a href=\"http://www.baidu.com”然后按回车，我们直接看到的是打开了对应的网页，内部客户端和服务端的通信：\" target=\"_blank\" rel=\"noopener\">www.baidu.com”然后按回车，我们直接看到的是打开了对应的网页，内部客户端和服务端的通信：</a></p>\n</blockquote>\n<p>1、URL自动解析<br>        HTTP URL包含了用于查找某个资源的足够信息，基本格式如下：HTTP://host[“:”port][abs_path]，其中HTTP表示桶盖HTTP协议来定位网络资源；host表示合法的主机域名或IP地址，port指定一个端口号，缺省80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。<br>例如：输入<a href=\"http://www.163.com;浏览器会自动转换成：HTTP://www.163.com/\" target=\"_blank\" rel=\"noopener\">www.163.com;浏览器会自动转换成：HTTP://www.163.com/</a><br>2、获取IP，建立TCP连接<br>       浏览器地址栏中输入”HTTP://<a href=\"http://www.xxx.com/&quot;并提交之后，首先它会在DNS本地缓存表中查找，如果有则直接告诉IP地址。如果没有则要求网关DNS进行查找，如此下去，找到对应的IP后，则返回会给浏览器。\" target=\"_blank\" rel=\"noopener\">www.xxx.com/&quot;并提交之后，首先它会在DNS本地缓存表中查找，如果有则直接告诉IP地址。如果没有则要求网关DNS进行查找，如此下去，找到对应的IP后，则返回会给浏览器。</a><br>当获取IP之后，就开始与所请求的Tcp建立三次握手连接，连接建立后，就向服务器发出HTTP请求。</p>\n<p>3、客户端浏览器向服务器发出HTTP请求<br>      一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令，接着以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<p>4、Web服务器应答，并向浏览器发送数据<br>       客户机向服务器发出请求后，服务器会客户机回送应答，HTTP/1.1 200 OK<br>      应答的第一部分是协议的版本号和应答状态码，正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。<br>       Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</p>\n<p>5、Web服务器关闭TCP连接<br>      一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive， TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<p><br></p>\n<h3 id=\"http状态码有那些？分别代表是什么意思？\"><a href=\"#http状态码有那些？分别代表是什么意思？\" class=\"headerlink\" title=\"http状态码有那些？分别代表是什么意思？\"></a>http状态码有那些？分别代表是什么意思？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  [</span><br><span class=\"line\">      <span class=\"number\">100</span>  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class=\"line\">      <span class=\"number\">200</span>  OK         正常返回信息</span><br><span class=\"line\">      <span class=\"number\">201</span>  Created      请求成功并且服务器创建了新的资源</span><br><span class=\"line\">      <span class=\"number\">202</span>  Accepted     服务器已接受请求，但尚未处理</span><br><span class=\"line\">      <span class=\"number\">301</span>  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class=\"line\">      <span class=\"number\">302</span> Found          临时性重定向。</span><br><span class=\"line\">      <span class=\"number\">303</span> See Other      临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class=\"line\">      <span class=\"number\">304</span>  Not Modified 自从上次请求后，请求的网页未修改过。</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"number\">400</span> Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class=\"line\">      <span class=\"number\">401</span> Unauthorized 请求未授权。</span><br><span class=\"line\">      <span class=\"number\">403</span> Forbidden      禁止访问。</span><br><span class=\"line\">      <span class=\"number\">404</span> Not Found      找不到如何与 URI 相匹配的资源。</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"number\">500</span> Internal Server <span class=\"built_in\">Error</span>  最常见的服务器端错误。</span><br><span class=\"line\">      <span class=\"number\">503</span> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">完整版</span><br><span class=\"line\"><span class=\"number\">1</span>**(信息类)：表示接收到请求并且继续处理</span><br><span class=\"line\">  <span class=\"number\">100</span>——客户必须继续发出请求</span><br><span class=\"line\">  <span class=\"number\">101</span>——客户要求服务器根据请求转换HTTP协议版本</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>**(响应成功)：表示动作被成功接收、理解和接受</span><br><span class=\"line\">  <span class=\"number\">200</span>——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class=\"line\">  <span class=\"number\">201</span>——提示知道新文件的URL</span><br><span class=\"line\">  <span class=\"number\">202</span>——接受和处理、但处理未完成</span><br><span class=\"line\">  <span class=\"number\">203</span>——返回信息不确定或不完整</span><br><span class=\"line\">  <span class=\"number\">204</span>——请求收到，但返回信息为空</span><br><span class=\"line\">  <span class=\"number\">205</span>——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class=\"line\">  <span class=\"number\">206</span>——服务器已经完成了部分用户的GET请求</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>**(重定向类)：为了完成指定的动作，必须接受进一步处理</span><br><span class=\"line\">  <span class=\"number\">300</span>——请求的资源可在多处得到</span><br><span class=\"line\">  <span class=\"number\">301</span>——本网页被永久性转移到另一个URL</span><br><span class=\"line\">  <span class=\"number\">302</span>——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</span><br><span class=\"line\">  <span class=\"number\">303</span>——建议客户访问其他URL或访问方式</span><br><span class=\"line\">  <span class=\"number\">304</span>——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</span><br><span class=\"line\">  <span class=\"number\">305</span>——请求的资源必须从服务器指定的地址得到</span><br><span class=\"line\">  <span class=\"number\">306</span>——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class=\"line\">  <span class=\"number\">307</span>——申明请求的资源临时性删除</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>**(客户端错误类)：请求包含错误语法或不能正确执行</span><br><span class=\"line\">  <span class=\"number\">400</span>——客户端请求有语法错误，不能被服务器所理解</span><br><span class=\"line\">  <span class=\"number\">401</span>——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class=\"line\">  HTTP <span class=\"number\">401.1</span> - 未授权：登录失败</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.2</span> - 未授权：服务器配置问题导致登录失败</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.3</span> - ACL 禁止访问资源</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.4</span> - 未授权：授权被筛选器拒绝</span><br><span class=\"line\">  HTTP <span class=\"number\">401.5</span> - 未授权：ISAPI 或 CGI 授权失败</span><br><span class=\"line\">  <span class=\"number\">402</span>——保留有效ChargeTo头响应</span><br><span class=\"line\">  <span class=\"number\">403</span>——禁止访问，服务器收到请求，但是拒绝提供服务</span><br><span class=\"line\">  HTTP <span class=\"number\">403.1</span> 禁止访问：禁止可执行访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.2</span> - 禁止访问：禁止读访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.3</span> - 禁止访问：禁止写访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.4</span> - 禁止访问：要求 SSL</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.5</span> - 禁止访问：要求 SSL <span class=\"number\">128</span></span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.6</span> - 禁止访问：IP 地址被拒绝</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.7</span> - 禁止访问：要求客户证书</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.8</span> - 禁止访问：禁止站点访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.9</span> - 禁止访问：连接的用户过多</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.10</span> - 禁止访问：配置无效</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.11</span> - 禁止访问：密码更改</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.12</span> - 禁止访问：映射器拒绝访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.13</span> - 禁止访问：客户证书已被吊销</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.15</span> - 禁止访问：客户访问许可过多</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.16</span> - 禁止访问：客户证书不可信或者无效</span><br><span class=\"line\">  HTTP <span class=\"number\">403.17</span> - 禁止访问：客户证书已经到期或者尚未生效</span><br><span class=\"line\">  <span class=\"number\">404</span>——一个<span class=\"number\">404</span>错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</span><br><span class=\"line\">  <span class=\"number\">405</span>——用户在Request-Line字段定义的方法不允许</span><br><span class=\"line\">  <span class=\"number\">406</span>——根据用户发送的Accept拖，请求资源不可访问</span><br><span class=\"line\">  <span class=\"number\">407</span>——类似<span class=\"number\">401</span>，用户必须首先在代理服务器上得到授权</span><br><span class=\"line\">  <span class=\"number\">408</span>——客户端没有在用户指定的饿时间内完成请求</span><br><span class=\"line\">  <span class=\"number\">409</span>——对当前资源状态，请求不能完成</span><br><span class=\"line\">  <span class=\"number\">410</span>——服务器上不再有此资源且无进一步的参考地址</span><br><span class=\"line\">  <span class=\"number\">411</span>——服务器拒绝用户定义的Content-Length属性请求</span><br><span class=\"line\">  <span class=\"number\">412</span>——一个或多个请求头字段在当前请求中错误</span><br><span class=\"line\">  <span class=\"number\">413</span>——请求的资源大于服务器允许的大小</span><br><span class=\"line\">  <span class=\"number\">414</span>——请求的资源URL长于服务器允许的长度</span><br><span class=\"line\">  <span class=\"number\">415</span>——请求资源不支持请求项目格式</span><br><span class=\"line\">  <span class=\"number\">416</span>——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class=\"line\">  <span class=\"number\">417</span>——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5</span>**(服务端错误类)：服务器不能正确执行一个正确的请求</span><br><span class=\"line\">  HTTP <span class=\"number\">500</span> - 服务器遇到错误，无法完成请求</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500.100</span> - 内部服务器错误 - ASP 错误</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-11</span> 服务器关闭</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-12</span> 应用程序重新启动</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-13</span> - 服务器太忙</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-14</span> - 应用程序无效</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-15</span> - 不允许请求 global.asa</span><br><span class=\"line\">  　　<span class=\"built_in\">Error</span> <span class=\"number\">501</span> - 未实现</span><br><span class=\"line\">HTTP <span class=\"number\">502</span> - 网关错误</span><br><span class=\"line\">HTTP <span class=\"number\">503</span>：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h3><blockquote>\n<p>HTTPS(全称：Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，https所用的端口号是443。</p>\n</blockquote>\n<h3 id=\"https的实现原理\"><a href=\"#https的实现原理\" class=\"headerlink\" title=\"https的实现原理\"></a>https的实现原理</h3><p>有两种基本的加解密算法类型：</p>\n<p>1)对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等;</p>\n<p>2)非对称加密：密钥成对出现(且根据公钥无法推知私钥，根据私钥也无法推知公钥)，加密解密使用不同密钥(公钥加密需要私钥解密，私钥加密需要公钥解密)，相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p>\n<h3 id=\"https通信的优点：\"><a href=\"#https通信的优点：\" class=\"headerlink\" title=\"https通信的优点：\"></a>https通信的优点：</h3><p>1)客户端产生的密钥只有客户端和服务器端能得到;<br>2)加密的数据只有客户端和服务器端才能得到明文;<br>3)客户端到服务端的通信是安全的。</p>\n<h3 id=\"浏览器的渲染过程\"><a href=\"#浏览器的渲染过程\" class=\"headerlink\" title=\"浏览器的渲染过程\"></a>浏览器的渲染过程</h3><p>1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。<br>2、CSS文件下载完成，开始构建CSSOM<br>3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。<br>4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。<br>5、最后一步，按照算出来的规则，把内容渲染到屏幕上。</p>\n<p>以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>HTTP协议是用于从WWW服务器传输超文本到本地浏览器的传送协议，用于浏览器和服务器的通信。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示等。默认HTTP的端口号为80.</p>\n</blockquote>\n<h3 id=\"常用的请求方式\"><a href=\"#常用的请求方式\" class=\"headerlink\" title=\"常用的请求方式\"></a>常用的请求方式</h3><p>常用的请求方式是GET和POST.</p>\n<ul>\n<li><p>GET方式：是以实体的方式得到由请求URI所指定资源的信息，如果请求URI只是一个数据产生过程，那么最终要在响应实体中返回的是处理过程的结果所指向的资源，而不是处理过程的描述。</p>\n</li>\n<li><p>POST方式：用来向目的服务器发出请求，要求它接受被附在请求后的实体，并把它当作请求队列中请求URI所指定资源的附加新子项，Post被设计成用统一的方法实现下列功能：</p>\n</li>\n</ul>\n<p>1：对现有资源的解释;<br>2：向电子公告栏、新闻组、邮件列表或类似讨论组发信息;<br>3：提交数据块;<br>4：通过附加操作来扩展数据库 。</p>\n<p>从上面描述可以看出，Get是向服务器发索取数据的一种请求;而Post是向服务器提交数据的一种请求，要提交的数据位于信息头后面的实体中。</p>\n<p>GET与POST方法有以下区别：</p>\n<p>(1) 在客户端，Get方式在通过URL提交数据，数据在URL中可以看到;POST方式，数据放置在HTML HEADER内提交。<br>(2) GET方式提交的数据最多只能有1024字节，而POST则没有此限制。<br>(3) 安全性问题。正如在(1)中提到，使用 Get 的时候，参数会显示在地址栏上，而 Post 不会。所以，如果这些数据是中文数据而且是非敏感数据，那么使用 get;如果用户输入的数据不是中文字符而且包含敏感数据，那么还是使用 post为好.<br>(4) 安全的和幂等的。所谓安全的意味着该操作用于获取信息而非修改信息。幂等的意味着对同一 URL 的多个请求应该返回同样的结果。完整的定义并不像看起来那样严格。换句话说，GET 请求一般不应产生副作用。从根本上讲，其目标是当用户打开一个链接时，她可以确信从自身的角度来看没有改变资源。比如，新闻站点的头版不断更新。虽然第二次请求会返回不同的一批新闻，该操作仍然被认为是安全的和幂等的，因为它总是返回当前的新闻。反之亦然。POST 请求就不那么轻松了。POST 表示可能改变服务器上的资源的请求。仍然以新闻站点为例，读者对文章的注解应该通过 POST 请求实现，因为在注解提交之后站点已经不同了(比方说文章下面出现一条注解)。</p>\n<p><br></p>\n<h3 id=\"请求头\"><a href=\"#请求头\" class=\"headerlink\" title=\"请求头\"></a>请求头</h3><p>HTTP最常见的请求头如下：</p>\n<ul>\n<li><p>Accept：浏览器可接受的MIME类型;</p>\n</li>\n<li><p>Accept-Charset：浏览器可接受的字符集;</p>\n</li>\n<li><p>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间;</p>\n</li>\n<li><p>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到;</p>\n</li>\n<li><p>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中;</p>\n</li>\n<li><p>Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1(HTTP 1.1默认进行持久连接)，它就可以利用持久连接的优点，当页面包含多个元素时(例如Applet，图片)，显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小;</p>\n</li>\n<li><p>Content-Length：表示请求消息正文的长度;</p>\n</li>\n<li><p>Cookie：这是最重要的请求头信息之一;</p>\n</li>\n<li><p>From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它;</p>\n</li>\n<li><p>Host：初始URL中的主机和端口;</p>\n</li>\n<li><p>If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答;</p>\n</li>\n<li><p>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝;</p>\n</li>\n<li><p>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</p>\n</li>\n<li><p>User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用;</p>\n</li>\n<li><p>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"响应头\"><a href=\"#响应头\" class=\"headerlink\" title=\"响应头\"></a>响应头</h3><p>HTTP最常见的响应头如下所示：</p>\n<ul>\n<li><p>Allow：服务器支持哪些请求方法(如GET、POST等);</p>\n</li>\n<li><p>Content-Encoding：文档的编码(Encode)方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头(即request.getHeader(“Accept-Encoding”))检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面;</p>\n</li>\n<li><p>Content-Length：表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容;</p>\n</li>\n<li><p>Content-Type： 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentTyep。 可在web.xml文件中配置扩展名和MIME类型的对应关系;</p>\n</li>\n<li><p>Date：当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦;</p>\n</li>\n<li><p>Expires：指明应该在什么时候认为文档已经过期，从而不再缓存它。</p>\n</li>\n<li><p>Last-Modified：文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304(Not Modified)状态。Last-Modified也可用setDateHeader方法来设置;</p>\n</li>\n<li><p>Location：表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302;</p>\n</li>\n<li><p>Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href=\"http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的\" target=\"_blank\" rel=\"noopener\">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的</a> 实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是 。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但 Netscape和IE都支持它。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"实体头\"><a href=\"#实体头\" class=\"headerlink\" title=\"实体头\"></a>实体头</h3><blockquote>\n<p>实体头用坐实体内容的元信息，描述了实体内容的属性，包括实体信息类型，长度，压缩方法，最后一次修改时间，数据有效性等。</p>\n</blockquote>\n<ul>\n<li>Allow：GET,POST</li>\n<li>Content-Encoding：文档的编码(Encode)方法，例如：gzip，见“2.5 响应头”;</li>\n<li>Content-Language：内容的语言类型，例如：zh-cn;</li>\n<li>Content-Length：表示内容长度，eg：80，可参考“2.5响应头”;</li>\n<li><p>Content-Location：表示客户应当到哪里去提取文档，例如：<a href=\"http://www.dfdf.org/dfdf.html，可参考“2.5响应头”\" target=\"_blank\" rel=\"noopener\">http://www.dfdf.org/dfdf.html，可参考“2.5响应头”</a>;</p>\n</li>\n<li><p>Content-MD5：MD5 实体的一种MD5摘要，用作校验和。发送方和接受方都计算MD5摘要，接受方将其计算的值与此头标中传递的值进行比较。Eg1：Content-MD5:  。Eg2：dfdfdfdfdfdfdff==;</p>\n</li>\n<li><p>Content-Range：随部分实体一同发送;标明被插入字节的低位与高位字节偏移，也标明此实体的总长度。Eg1：Content-Range: 1001-2000/5000，eg2：bytes 2543-4532/7898</p>\n</li>\n<li><p>Content-Type：标明发送或者接收的实体的MIME类型。Eg：text/html; charset=GB2312 主类型/子类型;</p>\n</li>\n<li><p>Expires：为0证明不缓存;</p>\n</li>\n<li><p>Last-Modified：WEB 服务器认为对象的最后修改时间，比如文件的最后修改时间，动态页面的最后产生时间等等。例如：Last-Modified：Tue, 06 May 2008 02:42:43 GMT.</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"扩展头\"><a href=\"#扩展头\" class=\"headerlink\" title=\"扩展头\"></a>扩展头</h3><blockquote>\n<p>在HTTP消息中，也可以使用一些再HTTP1.1正式规范里没有定义的头字段，这些头字段统称为自定义的HTTP头或者扩展头，他们通常被当作是一种实体头处理。<br>现在流行的浏览器实际上都支持Cookie,Set-Cookie,Refresh和Content-Disposition等几个常用的扩展头字段。</p>\n</blockquote>\n<ul>\n<li><p>Refresh：1;url=<a href=\"http://www.dfdf.org\" target=\"_blank\" rel=\"noopener\">http://www.dfdf.org</a> //过1秒跳转到指定位置;</p>\n</li>\n<li><p>Content-Disposition：头字段,可参考“2.5响应头”;</p>\n</li>\n<li><p>Content-Type：WEB 服务器告诉浏览器自己响应的对象的类型。</p>\n</li>\n<li><p>eg1：Content-Type：application/xml ;</p>\n</li>\n<li><p>eg2：applicaiton/octet-stream;</p>\n</li>\n<li><p>Content-Disposition：attachment; filename=aaa.zip。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"HTTP协议通信过程\"><a href=\"#HTTP协议通信过程\" class=\"headerlink\" title=\"HTTP协议通信过程\"></a>HTTP协议通信过程</h3><blockquote>\n<p>当我们在浏览器的地址栏输入“<a href=\"http://www.baidu.com”然后按回车，我们直接看到的是打开了对应的网页，内部客户端和服务端的通信：\" target=\"_blank\" rel=\"noopener\">www.baidu.com”然后按回车，我们直接看到的是打开了对应的网页，内部客户端和服务端的通信：</a></p>\n</blockquote>\n<p>1、URL自动解析<br>        HTTP URL包含了用于查找某个资源的足够信息，基本格式如下：HTTP://host[“:”port][abs_path]，其中HTTP表示桶盖HTTP协议来定位网络资源；host表示合法的主机域名或IP地址，port指定一个端口号，缺省80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。<br>例如：输入<a href=\"http://www.163.com;浏览器会自动转换成：HTTP://www.163.com/\" target=\"_blank\" rel=\"noopener\">www.163.com;浏览器会自动转换成：HTTP://www.163.com/</a><br>2、获取IP，建立TCP连接<br>       浏览器地址栏中输入”HTTP://<a href=\"http://www.xxx.com/&quot;并提交之后，首先它会在DNS本地缓存表中查找，如果有则直接告诉IP地址。如果没有则要求网关DNS进行查找，如此下去，找到对应的IP后，则返回会给浏览器。\" target=\"_blank\" rel=\"noopener\">www.xxx.com/&quot;并提交之后，首先它会在DNS本地缓存表中查找，如果有则直接告诉IP地址。如果没有则要求网关DNS进行查找，如此下去，找到对应的IP后，则返回会给浏览器。</a><br>当获取IP之后，就开始与所请求的Tcp建立三次握手连接，连接建立后，就向服务器发出HTTP请求。</p>\n<p>3、客户端浏览器向服务器发出HTTP请求<br>      一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令，接着以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。</p>\n<p>4、Web服务器应答，并向浏览器发送数据<br>       客户机向服务器发出请求后，服务器会客户机回送应答，HTTP/1.1 200 OK<br>      应答的第一部分是协议的版本号和应答状态码，正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。<br>       Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</p>\n<p>5、Web服务器关闭TCP连接<br>      一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：Connection:keep-alive， TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</p>\n<p><br></p>\n<h3 id=\"http状态码有那些？分别代表是什么意思？\"><a href=\"#http状态码有那些？分别代表是什么意思？\" class=\"headerlink\" title=\"http状态码有那些？分别代表是什么意思？\"></a>http状态码有那些？分别代表是什么意思？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  [</span><br><span class=\"line\">      <span class=\"number\">100</span>  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class=\"line\">      <span class=\"number\">200</span>  OK         正常返回信息</span><br><span class=\"line\">      <span class=\"number\">201</span>  Created      请求成功并且服务器创建了新的资源</span><br><span class=\"line\">      <span class=\"number\">202</span>  Accepted     服务器已接受请求，但尚未处理</span><br><span class=\"line\">      <span class=\"number\">301</span>  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class=\"line\">      <span class=\"number\">302</span> Found          临时性重定向。</span><br><span class=\"line\">      <span class=\"number\">303</span> See Other      临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class=\"line\">      <span class=\"number\">304</span>  Not Modified 自从上次请求后，请求的网页未修改过。</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"number\">400</span> Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class=\"line\">      <span class=\"number\">401</span> Unauthorized 请求未授权。</span><br><span class=\"line\">      <span class=\"number\">403</span> Forbidden      禁止访问。</span><br><span class=\"line\">      <span class=\"number\">404</span> Not Found      找不到如何与 URI 相匹配的资源。</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"number\">500</span> Internal Server <span class=\"built_in\">Error</span>  最常见的服务器端错误。</span><br><span class=\"line\">      <span class=\"number\">503</span> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">完整版</span><br><span class=\"line\"><span class=\"number\">1</span>**(信息类)：表示接收到请求并且继续处理</span><br><span class=\"line\">  <span class=\"number\">100</span>——客户必须继续发出请求</span><br><span class=\"line\">  <span class=\"number\">101</span>——客户要求服务器根据请求转换HTTP协议版本</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>**(响应成功)：表示动作被成功接收、理解和接受</span><br><span class=\"line\">  <span class=\"number\">200</span>——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class=\"line\">  <span class=\"number\">201</span>——提示知道新文件的URL</span><br><span class=\"line\">  <span class=\"number\">202</span>——接受和处理、但处理未完成</span><br><span class=\"line\">  <span class=\"number\">203</span>——返回信息不确定或不完整</span><br><span class=\"line\">  <span class=\"number\">204</span>——请求收到，但返回信息为空</span><br><span class=\"line\">  <span class=\"number\">205</span>——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class=\"line\">  <span class=\"number\">206</span>——服务器已经完成了部分用户的GET请求</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>**(重定向类)：为了完成指定的动作，必须接受进一步处理</span><br><span class=\"line\">  <span class=\"number\">300</span>——请求的资源可在多处得到</span><br><span class=\"line\">  <span class=\"number\">301</span>——本网页被永久性转移到另一个URL</span><br><span class=\"line\">  <span class=\"number\">302</span>——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</span><br><span class=\"line\">  <span class=\"number\">303</span>——建议客户访问其他URL或访问方式</span><br><span class=\"line\">  <span class=\"number\">304</span>——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</span><br><span class=\"line\">  <span class=\"number\">305</span>——请求的资源必须从服务器指定的地址得到</span><br><span class=\"line\">  <span class=\"number\">306</span>——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class=\"line\">  <span class=\"number\">307</span>——申明请求的资源临时性删除</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>**(客户端错误类)：请求包含错误语法或不能正确执行</span><br><span class=\"line\">  <span class=\"number\">400</span>——客户端请求有语法错误，不能被服务器所理解</span><br><span class=\"line\">  <span class=\"number\">401</span>——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class=\"line\">  HTTP <span class=\"number\">401.1</span> - 未授权：登录失败</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.2</span> - 未授权：服务器配置问题导致登录失败</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.3</span> - ACL 禁止访问资源</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.4</span> - 未授权：授权被筛选器拒绝</span><br><span class=\"line\">  HTTP <span class=\"number\">401.5</span> - 未授权：ISAPI 或 CGI 授权失败</span><br><span class=\"line\">  <span class=\"number\">402</span>——保留有效ChargeTo头响应</span><br><span class=\"line\">  <span class=\"number\">403</span>——禁止访问，服务器收到请求，但是拒绝提供服务</span><br><span class=\"line\">  HTTP <span class=\"number\">403.1</span> 禁止访问：禁止可执行访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.2</span> - 禁止访问：禁止读访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.3</span> - 禁止访问：禁止写访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.4</span> - 禁止访问：要求 SSL</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.5</span> - 禁止访问：要求 SSL <span class=\"number\">128</span></span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.6</span> - 禁止访问：IP 地址被拒绝</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.7</span> - 禁止访问：要求客户证书</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.8</span> - 禁止访问：禁止站点访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.9</span> - 禁止访问：连接的用户过多</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.10</span> - 禁止访问：配置无效</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.11</span> - 禁止访问：密码更改</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.12</span> - 禁止访问：映射器拒绝访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.13</span> - 禁止访问：客户证书已被吊销</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.15</span> - 禁止访问：客户访问许可过多</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.16</span> - 禁止访问：客户证书不可信或者无效</span><br><span class=\"line\">  HTTP <span class=\"number\">403.17</span> - 禁止访问：客户证书已经到期或者尚未生效</span><br><span class=\"line\">  <span class=\"number\">404</span>——一个<span class=\"number\">404</span>错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</span><br><span class=\"line\">  <span class=\"number\">405</span>——用户在Request-Line字段定义的方法不允许</span><br><span class=\"line\">  <span class=\"number\">406</span>——根据用户发送的Accept拖，请求资源不可访问</span><br><span class=\"line\">  <span class=\"number\">407</span>——类似<span class=\"number\">401</span>，用户必须首先在代理服务器上得到授权</span><br><span class=\"line\">  <span class=\"number\">408</span>——客户端没有在用户指定的饿时间内完成请求</span><br><span class=\"line\">  <span class=\"number\">409</span>——对当前资源状态，请求不能完成</span><br><span class=\"line\">  <span class=\"number\">410</span>——服务器上不再有此资源且无进一步的参考地址</span><br><span class=\"line\">  <span class=\"number\">411</span>——服务器拒绝用户定义的Content-Length属性请求</span><br><span class=\"line\">  <span class=\"number\">412</span>——一个或多个请求头字段在当前请求中错误</span><br><span class=\"line\">  <span class=\"number\">413</span>——请求的资源大于服务器允许的大小</span><br><span class=\"line\">  <span class=\"number\">414</span>——请求的资源URL长于服务器允许的长度</span><br><span class=\"line\">  <span class=\"number\">415</span>——请求资源不支持请求项目格式</span><br><span class=\"line\">  <span class=\"number\">416</span>——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class=\"line\">  <span class=\"number\">417</span>——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5</span>**(服务端错误类)：服务器不能正确执行一个正确的请求</span><br><span class=\"line\">  HTTP <span class=\"number\">500</span> - 服务器遇到错误，无法完成请求</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500.100</span> - 内部服务器错误 - ASP 错误</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-11</span> 服务器关闭</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-12</span> 应用程序重新启动</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-13</span> - 服务器太忙</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-14</span> - 应用程序无效</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-15</span> - 不允许请求 global.asa</span><br><span class=\"line\">  　　<span class=\"built_in\">Error</span> <span class=\"number\">501</span> - 未实现</span><br><span class=\"line\">HTTP <span class=\"number\">502</span> - 网关错误</span><br><span class=\"line\">HTTP <span class=\"number\">503</span>：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"https\"><a href=\"#https\" class=\"headerlink\" title=\"https\"></a>https</h3><blockquote>\n<p>HTTPS(全称：Hypertext Transfer Protocol over Secure Socket Layer)，是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，https所用的端口号是443。</p>\n</blockquote>\n<h3 id=\"https的实现原理\"><a href=\"#https的实现原理\" class=\"headerlink\" title=\"https的实现原理\"></a>https的实现原理</h3><p>有两种基本的加解密算法类型：</p>\n<p>1)对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等;</p>\n<p>2)非对称加密：密钥成对出现(且根据公钥无法推知私钥，根据私钥也无法推知公钥)，加密解密使用不同密钥(公钥加密需要私钥解密，私钥加密需要公钥解密)，相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p>\n<h3 id=\"https通信的优点：\"><a href=\"#https通信的优点：\" class=\"headerlink\" title=\"https通信的优点：\"></a>https通信的优点：</h3><p>1)客户端产生的密钥只有客户端和服务器端能得到;<br>2)加密的数据只有客户端和服务器端才能得到明文;<br>3)客户端到服务端的通信是安全的。</p>\n<h3 id=\"浏览器的渲染过程\"><a href=\"#浏览器的渲染过程\" class=\"headerlink\" title=\"浏览器的渲染过程\"></a>浏览器的渲染过程</h3><p>1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。<br>2、CSS文件下载完成，开始构建CSSOM<br>3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。<br>4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。<br>5、最后一步，按照算出来的规则，把内容渲染到屏幕上。</p>\n<p>以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。</p>\n"},{"title":"常见的知识总结","_content":"\n\n\n###  vue中的MVVM模式 \n  MVVM即Model-View-ViewModel。\n  Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。  ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。 DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化\n\n<br/>\n\n### Vue提供的生命周期钩子\n\n  ①　beforeCreate\n  在实例初始化之后，数据观测(data observer，开始监控Data对象数据变化)和初始化事件(init event，Vue内部初始化事件)之前被调用。\n  ②　created\n  在实例已经创建完成之后被调用。实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，event事件回调。挂载阶段尚未开始，$el 属性不可见。\n  ③　beforeMount\n  在挂载开始之前被调用。相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。\n  ④　mounted\n  在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。此时模板中的html渲染到了html页面中，此时一般可以做一些Ajax操作。注意mounted只会执行一次。\n  ⑤　beforeUpdate\n  在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。\n  ⑥　updated\n  在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\n  ⑦　beforeDestroy\n  在实例销毁之前调用。实例仍然完全可用。\n  ⑧　destroyed\n  在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。\n\n<br/>\n\n ###  v-show指令，v-if的区别 \n  条件渲染指令，与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style值\n\n<br/>\n\n### 指令keep-alive  \n  在vue-router写着keep-alive，keep-alive的含义： 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令  \n ```javascript\n     <component :is='curremtView' keep-alive></component>\n ```\n  \n<br/>\n\n###  指令v-el的使用\n  有时候我们想就像使用jquery那样去访问一个元素，此时就可以使用v-el指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。\n  \n  HTML不区分大小写，所以v-el:someEl将转换为全小写。可以用v-el:some-el然后设置this.$el.someEl。 \n示例  \n``` javascript\n<span v-el:msg>hello</span> \n<span v-el:other-msg>world</span>  \nthis.$els.msg.textContent // ->\"hello\"  \nthis.$els.otherMsg.textContent // ->\"world\" \nthis.$els.msg //-><span>hello</span>\n```\n  \n<br/>\n\n### Vue.js特点 \n  简洁：页面由HTML模板+Json数据+Vue实例组成 \n  数据驱动：自动计算属性和追踪依赖的模板表达式 \n  组件化：用可复用、解耦的组件来构造页面 \n  轻量：代码量小，不依赖其他库 快速：精确有效批量DOM更新  \n  模板友好：可通过npm，bower等多种方式安装，很容易融入\n  \n<br/>\n\n### JS中的常量（基本数据类型）和内置对象\n  js中的基本数据类型：String 、number、null、boolean、undefined、object、symbol（ES6）\n* 1、 利用typeof运算符时其中只有null是异常的，typeof（null）=object，所以在判断变量类型是否为null时要注意。同时利用typeof时对于没有声明的变量是不会报错的，返回值为undefined。全局变量和函数变量在没有声明时使用是会报错的，但是在对象中使用没有定义的属性是不会报错同样返回的是undefined。Function变量是具有length属性的，其长度为传入的参数的个数。\n* 2、 变量时弱类型的，即其本身是没有类型的，其值才是具有类型的。\n* 3、 对于number类型，\n（1）其中要注意的是NAN非数字的数字，用全局的函数isNAN判断时会有问题，即对于非数字类型的变量其也会返回true，所以在使用时可以用以下方式判断NAN：\n①a!=a\n②利用ES6中的Number.isNAN;\n③typeof(a)==’number’&&isNAN(a)\n（2）还有一个要注意的是+0，-0这两者在使用时是相等的但是在浏览器引擎上还是会有区别，区分二者可以利用：typeof(a)==typeof(b)&&1/a==1/b，+0、-0作为分母时会得到infinite和-infinite。在ES6中有Object.is方法可用于判断两个变量是否相等。可用于上述情况。但是前者的方法的执行效率更好。\n（3）另外在JS中数字类型也是有最大和最小值的界定的安全范围的\n（4）判断变量是否为整数的方法：\n①Number.isInteger(a)，ES6中的方法\n②typeof（a）==’number’&&a%1==0\n③或者使用Math.ceil(a)==a等类似的方法\n* 4、变量在复制和作为参数传递时会有引用传递和值传递之分：\n（1）值传递即普通的变量类型\n（2）引用传递，如对象和数组等幅值或者作为参数传递传递的是复制的引用会相会影响：\n``` javascript\nVar a=[1,2,3];\nVar b=a;\nb.push(4);//a=[1,2,3,4];b=[1,2,3,4]\n但是当b重新赋值时：\nVar b=[4,5,6]//a=[1,2,3,4];b=[4,5,6]因为b的引用已经发生了改变不在是a数组的引用的复制。\n```\nJS中的内置函数: String、Number、Boolean、RegExp、Date、Error、Array、\nFunction、Object、symbol;类似于对象的构造函数\n* 1、这些内置函数构造的变量都是封装了基本类型值的对象如：\n``` javascript\nVar a=new String(‘abb’); //typeof(a)=object\n```\n除了利用Function构造的变量通过typeof输出为function外其他均为object\n\n* 2、为了知道构造的变量的真实类型可以利用：\n``` javascript\nObject.prototype.toString.call([1,2,3]);//”[object,array]”\n```\n后面的一个值即为传入参数的类型\n* 3、如果有常量形式（即利用基本数据类型）赋值给变量就不要用该方式来定义变量\n  \n<br/>\n  \n### js中判断一个对象的类型的种种方法\n\n#### javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。\n\n* typeof：typeof是一个一元运算符，返回结果是一个说明运算数类型的字符串。如：\"number\"，\"string\"，\"boolean\"，\"object\"，\"function\"，\"undefined\"（可用于判断变量是否存在）。 但 typeof 的能力有限，其对于Date、RegExp、Array类型返回的都是\"object\"。所以它只在区别对象和原始类型的时候才有用。要区一种对象类型和另一种对象类型，必须使用其他的方法。\n\n* instanceof 运算符：instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。instanceof方法可以判断变量是否是数组类型，但是只限同一全局环境之内，在一个页面有多个iframe的情况下，instanceof失效。\n\n* constructor 属性: JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。如给定一个求知的值 通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。\n\n* Object.prototype.toString.call()：该方法是目前为止发现的判断一个对象类型的最好的办法。\n\n  \n<br/>\n  \n### 事件冒泡与事件捕获\n#### 事件冒泡\n微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象，由内向外。\n### 事件捕获\n网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素，由外向内。\n\naddEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数：\n```javascript\nelement.addEventListener(event, function, useCapture)\n```\n第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。\n\n对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。\n##### IE浏览器\nIE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。\n```javascript\nele.attachEvent(\"onclick\", doSomething2);\n```\n附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。\n#### 事件的传播是可以阻止的：\n• 在W3c中，使用stopPropagation（）方法\n• 在IE下设置cancelBubble = true；\n在捕获的过程中stopPropagation（）；后，后面的冒泡过程也不会发生了~\n3.阻止事件的默认行为，例如click a 后的跳转~\n• 在W3c中，使用preventDefault（）方法；\n• 在IE下设置window.event.returnValue = false;\n  \n<br/>\n  \n### 浏览器的重绘与重排\n\n1.重排的概念\n浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM树和渲染树），DOM树表示页面结构，渲染树表示DOM节点如何显示。重排是DOM元素的几何属性变化，DOM树的结构变化，渲染树需要重新计算。\n\n2.重绘的概念\n重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。\n\n3.重绘和重排的关系\n重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。\n\n4.什么情况下会触发重排？\n(1)页面渲染初始化时；（这个无法避免）\n(2)浏览器窗口改变尺寸；\n(3)元素尺寸改变时；\n(4)元素位置改变时；\n(5)元素内容改变时；\n(6)添加或删除可见的DOM 元素时。\n\n6.无论是外链CSS还是内联CSS都会阻塞DOM渲染（Rendering），然而DOM解析（Parsing）会正常进行。 这意味着在CSS下载并解析结束之前，它后面的HTML都不会显示。 这也是为什么我们把样式放在HTML内容之前，以防止被呈现内容发生样式跳动。 当然代价就是显示延迟，所以性能攸关的站点都会内联所有CSS。\n  \n<br/>\n  \n### $.extend(obj);$.fn.extend(obj);\n\n$拓展的方法是静态方法，可以使用$直接调用，其拓展的方式有两种，一般使用$.extend({});而$.fn拓展的方法是实例方法，必须由“对象”$(\"\")来调用，其拓展的方式同样有两种，一般使用$.fn.extend({ })。\n\n$.extend(obj);是为了扩展jquery本身，为类添加新的方法\n\n$.fn.extend(obj);给JQUERY对象添加方法。\n\n$.fn 中的fn其实是prototype，即$.fn=$.prototype;\n\n```javascript\n$.extend({\nadd:function(a,b){\n  return a+b;\n  }\n})\n$.add(5,8) //return 13\n```\n这边的调用直接调用，前面不用任何对象。直接$.+方法名\n\n$.fn.extend(obj)；对prototype进行扩展，为jquery类添加成员函数， jquery类的实例可以使用这个成员函数。\n\n```javascript\n$.fn.extend({\nclickwhile:function(){\n  $(this).click(function(){\n  alert($(this).val()) \n  })\n}\n})\n$('input').clickwhile();//当点击输入框会弹出该对象的Value值\n```\n注意调用时候前面是有对象的。即$('input') 这么个东西。\n  \n<br/>\n  \n\n### CSS hack区分IE6,IE7,IE8,firefox\n\n#### CSS hack使用原理\n\n简单来讲，CSS hack就是浏览器解析CSS时的漏洞，因此不同的浏览器就有不同的CSS hack写法。 CSS hack使用原则: 尽力避免使用CSS hack，并寻找其它的应对方法。事实上，使用IE的条件注释来区分IE各个版本，是非常不错的选择。\n\n#### CSS hack使用后的弊端\n\nCSS Hack除了能迅速区分浏览器版本，并可能获得大概一直的效果，但从长远看，CSS Hack会引起许多新的错误。\n\n#### CSS hack的实现方式(针对IE6)\n\n* 1.利用浏览器对相同代码的解析和支持的不同实现的hack\n```javascript\n #test{\n    _width:80px;\n }\n```\n在IE7及以上版本的浏览器中会被当作错误特性而舍弃，但是在IE6中可以被正常的解析。这时候，可以把_width当作hack，专门针对IE6来设置元素的宽度。\n\n* 2.利用IE对标准的支持缺陷写的CSS hack\n!important只有IE7及以上版本的IE及其他浏览器支持，所以，可以用!important来针对IE6以外的浏览器写CSS代码；再如，head:first-child+bodyselector，:first-child不被IE6支持，所以可以用来针对IE6以外的浏览器编写CSS代码。IE6支持下划线，IE7和firefox均不支持下划线。\n\n>CSS hack区别IE6与Firefox：\n>background:orange;*background:blue;\n\n>CSS hack区别IE6与IE7：\n>background:green !important;background:blue;\n\n>CSS hack区别IE7与Firefox：\n>background:orange; *background:green;\n\n>CSS hack区别Firefox，IE7，IE6：\n>background:orange;*background:green !important;*background:blue;\n  \n<br/>\n  \n### 如何避免FOUC？\n如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.原因大致为：\n\n1，使用import方法导入样式表。\n2，将样式表放在页面底部\n3，有几个样式表，放在html结构的不同位置。其实原理很清楚：当样式表晚于 结构性html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂 的 花屏现象。解决方法：使用LINK标签将样式表放在文档HEAD中更多\n  \n<br/>\n  \n### DOM 中 Property 和 Attribute 的区别\n\n* Property：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型直接继承自Element并添加了一些属性，添加的这些属性分别对应于每个HTML元素都有下面的这5个标准特性: id,title,lang,dir,className。DOM节点是一个对象，因此，他可以和其他的JavaScript对象一样添加自定义的属性以及方法。property的值可以是任何的数据类型，对大小写敏感，自定义的property不会出现在html代码中，只存在js中。\n\n* Attribute：特性，区别于property，attribute只能是字符串，大小写不敏感，出现在innerHTML中，通过类数组attributes可以罗列所有的attribute。\n  \n<br/>\n  \n### document.onload和document.ready两个事件的区别\n\n* ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）\n* onload，指示页面包含图片等文件在内的所有元素都加载完成。\n  \n<br/>\n  \n### JavaScript的同源策略\n\n在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。\n  \n<br/>\n  \n### 给选择器一个上下文\n\njQuery选择器中有一个这样的选择器，它能指定上下文。jQuery(expression,context);通过它，能缩小选择器在DOM中搜索的范围，达到节省时间，提高效率。普通方式：$(‘.myDiv’)改进方式：$(‘.myDiv’,$(“#listItem”))。\n  \n<br/>\n  \n### 请解释JSONP的工作原理，以及它为什么不是真正的AJAX\n\nJSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。\n\nAJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！\n  \n<br/>\n  \n### 浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别\n\n特性检测：为特定浏览器的特性进行测试，并仅当特性存在时即可应用特性。\n\nUser-Agent检测：最早的浏览器嗅探即用户代理检测，服务端（以及后来的客户端）根据UA字符串屏蔽某些特定的浏览器查看网站内容。\n\n特性推断：尝试使用多个特性但仅验证了其中之一。根据一个特性的存在推断另一个特性是否存在。问题是，推断是假设并非事实，而且可能导致可维护性的问题\n  \n<br/>\n  \n### JavaScript宿主对象和原生对象的区别\n\n#### 原生对象\n\nECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。\n\n“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。\n\n由此可以看出，简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。\n\n#### 内置对象\n\nECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。\n\n同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。如此就可以理解了。内置对象是本地对象的一种。\n\n#### 宿主对象\n\n何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。\n\n所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的BOM和DOM都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。\n  \n<br/>\n  \n### AMD、CMD和CommonJS规范\n\n#### CommonJS规范\n\n CommonJS是在浏览器环境之外构建JavaScript生态系统为目标产生的项目，比如服务器和桌面环境中。CommonJS规范是为了解决JavaScript的作用域问题而定义的模块形式，\n可以使每个模块在它自身的命名空间中执行。该规范的主要内容是：模块必须通过  module.exports导出对外的变量或接口，通过require()来导入其他模块的输出到当前模块。\n```javascript\n// moduleA.js  \nmodule.exports = function( value ){  \n    return value * 2;  \n}  \n```\n```javascript\n// moduleB.js  \nvar multiplyBy2 = require('./moduleA');  \nvar result = multiplyBy2(4);  \n```\nCommonJS是同步加载模块，但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过id进行索引，这样就可以浏览器进行解析了\n\n服务器端的Node.js遵循CommonJS规范。核心思想是允许模块通过require 方法来同步加载所要依赖的其他模块，然后通过 exports或module.exports来导出需要暴露的接口。\n\n优点：\n服务器端便于重用\nNPM中已经将近20w个模块包\n简单并容易使用\n缺点：\n同步的模块方式不适合不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的\n不能非阻塞的并行加载多个模块\n\n#### AMD\n\nAMD规范其实只有一个主要接口 define(id,dependencies,factory)，它要在声明模块的时候指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置\n\n```javascript\ndefine(\"module\", [\"dep1\", \"dep2\"], function(d1, d2) {  \n  return someExportedValue;  \n});  \nrequire([\"module\", \"../file\"], function(module, file) { /* ... */ });  \\\n```\n\n优点：\n适合在浏览器环境异步加载\n并行加载多个模块\n缺点：\n提高开发成本，代码阅读和书写比较困难\n不符合通用的模块思维方式，是一种妥协的实现\n\n#### CMD\n\nCMD规范和AMD相似，尽量保持简单，并且与CommonJS和NodeJS的Modules规范保持了很大的兼容性。\n\n```javascript\ndefine(function(require, exports, module) {  \n  var $ = require('jquery');  \n  var Spinning = require('./spinning');  \n  exports.doSomething = ...  \n  module.exports = ...  \n})  \n```\n\n优点：\n依赖就近，延迟执行\n很容易在node中运行\n缺点：\n依赖SPM打包，模块的加载逻辑偏重\n  \n<br/>\n  \n### 事件代理\n\nJavaScript事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个父级元素上，这样就避免了把事件处理器添加到多个子级元素上。当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。事件代理用到了两个在JavaSciprt事件中常被忽略的特性：事件冒泡以及目标元素。\n  \n<br/>\n  \n### 如果设计中使用了非标准的字体，如何去实现\n\n所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。\n方法：\n* 用图片代替\n* web fonts在线字库，如Google Webfonts，Typekit等等；http://www.chinaz.com/free/2012/0815/269267.shtml；\n* @font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)\n  \n<br/>\n  \n### 使用CSS预处理器的优缺点\n\nLESS&SassLESS是受Sass启发而开发的工具，它列出了如下开发的理由：\n\n“为什么要开发一个Sass的替代品呢？原因很简单：首先是语法。Sass的一个关键特性是缩进式的语法，这种语法可以产生柱式外观的代码。但是你需要花费时间学习一门新的语法以及重新构建你现在的样式表。LESS给CSS带来了很多特性，使得LESS能够和CSS无缝地紧密结合在一起。因此，你可以平滑地由CSS迁移到LESS，如果你只是对使用变量或者操作感兴趣的话，你不需要学习一整门全新的语言。”\n\nStylus相对前两者较新，可以看官方文档介绍的功能。\n\n1.来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：http://learnboost.github.io/stylus/docs/js.html；\n2.支持Ruby之类等等框架；\n3.更多更强大的支持和功能总结：Sass看起来在提供的特性上占有优势，但是LESS能够让开发者平滑地从现存CSS文件过渡到LESS，而不需要像Sass那样需要将CSS文件转换成Sass格式。Stylus功能上更为强壮，和js联系更加紧密。\n  \n<br/>\n  \n### cookies，sessionStorage和localStorage的区别\n\ncookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。\n  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\n  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n\n存储大小：\n  cookie数据大小不能超过4k。\n  sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n\n有期时间：\n  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n  sessionStorage  数据在当前浏览器窗口关闭后自动删除。\n  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n  \n<br/>\n  \n### 浏览器标准模式和怪异模式之间的区别\n\nW3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。这样浏览器渲染上就产生了Quircks mode和Standars mode，两种渲染方法共存在一个浏览器上。IE盒子模型和标准W3C盒子模型：ie的width包括：padding\\border。标准的width不包括：padding\\border\n\n 在js中如何判断当前浏览器正在以何种方式解析？\n         document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。\n  \n<br/>\n  \n### doctype（文档类型）的作用，有多少种文档类型\n\n此标签可告知浏览器文档使用哪种HTML或XHTML规范。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。\n\nHTML 4.01规定了三种文档类型：Strict、Transitional以及Frameset。\n\nXHTML 1.0规定了三种XML文档类型：Strict、Transitional以及Frameset。\n\nStandards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。\n  \n<br/>\n  \n### 对语义化的理解\n\n1：去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如 h1 是粗体，字体大小2em，加粗；strong 是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。\n\n2.屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页。\n\n3.PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）。\n\n4.有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。\n\n5.便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。\n  \n<br/>\n  \n### 渐进增强和优雅降级\n\n优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.\n\n渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。\n  \n<br/>\n  \n### 浏览器同一时间可以从一个域名下载多少资源\n\n这个专业的说法叫“浏览器并发请求数”。意即，同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻止。所有浏览器的并发数目一般限制在10以内。\n\n <img src=\"https://pic4.zhimg.com/ea606d016e8ab77db9d8a8dfa5243a1b_r.jpg\" width=\"200\" height=\"200\">\n  \n<br/>\n  \n### Canvas 与 SVG \n#### Canvas\n* 依赖分辨率\n* 不支持事件处理器\n* 弱的文本渲染能力\n* 能够以 .png 或 .jpg 格式保存结果图像\n* 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n### SVG\n* 不依赖分辨率\n* 支持事件处理器\n* 最适合带有大型渲染区域的应用程序（比如谷歌地图）\n* 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n* 不适合游戏应用\n  \n<br/>\n  \n### 页面导入样式时，使用link和@import有什么区别\n\n（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;\n\n（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;\n\n（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问\n  \n<br/>\n  \n### 介绍一下你对浏览器内核的理解\n\n  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。\n  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\n  JS引擎则：解析和执行javascript来实现网页的动态效果。\n\n  最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n  \n<br/>\n  \n### 常见的浏览器内核有哪些？\n\n  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\n  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\n  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]\n  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]\n  \n<br/>\n  \n### html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和\nHTML5？\n\n * HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n          绘画 canvas;\n          用于媒介回放的 video 和 audio 元素;\n          本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\n          sessionStorage 的数据在浏览器关闭后自动删除;\n          语意化更好的内容元素，比如 article、footer、header、nav、section;\n          表单控件，calendar、date、time、email、url、search;\n          新的技术webworker, websocket, Geolocation;\n\n      移除的元素：\n          纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n          对可用性产生负面影响的元素：frame，frameset，noframes；\n\n    * 支持HTML5新标签：\n         IE8/IE7/IE6支持通过document.createElement方法产生的标签，\n           可以利用这一特性让这些浏览器支持HTML5新标签，\n           浏览器支持新标签后，还需要添加标签默认的样式。\n\n         当然也可以直接使用成熟的框架、比如html5shim;\n\n    * 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素\n  \n<br/>\n  \n### HTML5的离线储存怎么使用\n\n  在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。\n  \n<br/>\n  \n### 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\n\n  在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n  离线的情况下，浏览器就直接使用离线存储的资源。\n  \n<br/>\n  \n### iframe有那些缺点？\n\n  * iframe会阻塞主页面的Onload事件；\n  * 搜索引擎的检索程序无法解读这种页面，不利于SEO;\n\n  * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n\n  使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript\n  动态给iframe添加src属性值，这样可以绕开以上两个问题。\n  \n<br/>\n  \n### Label的作用是什么？是怎么用的?\n\n label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。\n```javascript\n  <label for=\"Name\">Number:</label>\n  <input type=“text“name=\"Name\" id=\"Name\"/>\n\n  <label>Date:<input type=\"text\" name=\"B\"/></label>\n```\n  \n<br/>\n  \n### HTML5的form如何关闭自动完成功能？\n\n  给不想要提示的 form 或某个 input 设置为 autocomplete=off。\n  \n<br/>\n  \n### 如何实现浏览器内多个标签页之间的通信?\n\n  WebSocket、SharedWorker；\n  也可以调用localstorge、cookies等本地存储方式；\n\n  localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，\n  我们通过监听事件，控制它的值来进行页面信息通信；\n  注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；\n  \n<br/>\n  \n### webSocket如何兼容低浏览器？\n\n * Adobe Flash Socket 、\n * ActiveX HTMLFile (IE) 、\n * 基于 multipart 编码发送 XHR 、\n * 基于长轮询的 XHR\n  \n<br/>\n  \n### 页面可见性（Page Visibility API） 可以有哪些用途？\n\n  通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;\n  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；\n  \n<br/>\n  \n### 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\n```javascript\n  <div style=\"height:1px;overflow:hidden;background:red\"></div>\n```\n  \n<br/>\n  \n### 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n\n  （1）有两种， IE 盒子模型、W3C 盒子模型；\n  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n  （3）区  别： IE的content部分把 border 和 padding计算了进去;\n  \n<br/>\n  \n### CSS优先级算法如何计算？\n\n  *   优先级就近原则，同权重情况下样式定义最近者为准;\n  *   载入样式以最后载入的定位为准;\n\n  优先级为:\n      同权重: 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。\n      !important >  id > class > tag\n      important 比 内联优先级高\n  \n<br/>\n  \n### CSS3新增伪类有那些？\n\n      举例：\n      p:first-of-type    选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n      p:last-of-type    选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n      p:only-of-type    选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n      p:only-child        选择属于其父元素的唯一子元素的每个 <p> 元素。\n      p:nth-child(2)    选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n      :after            在元素之前添加内容,也可以用来做清除浮动。\n      :before            在元素之后添加内容\n       :enabled          \n      :disabled         控制表单控件的禁用状态。\n      :checked        单选框或复选框被选中。\n  \n<br/>\n  \n### CSS3有哪些新特性？\n\n 新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）\n      圆角            （border-radius:8px）\n    多列布局        （multi-column layout）\n    阴影和反射    （Shadow\\Reflect）\n    文字特效        （text-shadow、）\n    文字渲染        （Text-decoration）\n    线性渐变        （gradient）\n    旋转             （transform）\n    缩放,定位,倾斜,动画,多背景\n    例如:transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:\n  \n<br/>\n  \n### 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景 \n\n  一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。\n   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。\n   采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。\n   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。\n   在布局上有了比以前更加灵活的空间。\n  \n<br/>\n  \n### li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\n\n 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。\n\n  \n<br/>\n  \n### 对BFC规范(块级格式化上下文：block formatting context)的理解？\n\n（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）\n   一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。\n   不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。\n  \n<br/>\n  \n### ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用\n\n单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）\n  双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，\n  比如:first-line、:first-letter、:before、:after等，\n  而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。\n\n  想让插入的内容出现在其它内容前，使用::before，否者，使用::after；\n  在代码顺序上，::after生成的内容也比::before生成的内容靠后。\n  如果按堆栈视角，::after生成的内容会在::before生成的内容之上\n  \n<br/>\n  \n### 让页面里的字体变清晰，变细用CSS怎么做？\n\n  -webkit-font-smoothing: antialiased;\n  \n<br/>\n  \n### position:fixed;在android下无效怎么处理？\n\n  fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，\n  原来的网页还好好的在那，fixed的内容也没有变过位置，\n  所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"/>\n  \n<br/>\n  \n### 如果需要手动写动画，你认为最小时间间隔是多久，为什么？\n\n多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms\n\ndisplay:inline-block 什么时候会显示间隙？\n\n移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing\n  \n<br/>\n  \n### 什么是CSS 预处理器 / 后处理器？   \n\n - 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，\n    还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。\n\n  - 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的\n    是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\n\n  \n<br/>\n  \n### JavaScript原型，原型链 ? 有什么特点？\n\n每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，\n 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，\n 于是就这样一直找下去，也就是我们平时所说的原型链的概念。\n 关系：instance.constructor.prototype = instance.__proto__\n\n 特点：\n JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。\n  \n<br/>\n  \n### 如何将字符串转化为数字，例如’12.3b’?\n\n * parseFloat('12.3b');\n * 正则表达式，'12.3b'.match(/(\\d)+(\\.)?(\\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。\n  \n<br/>\n  \n### 如何实现数组的随机排序？\n```javascript\n          var arr = [1,2,3,4,5,6,7,8,9,10];\n          arr.sort(function(){\n              return Math.random() - 0.5;\n           // return Math.random() ;   从大到小\n           // return Math.random() - 1;  从小到大\n          })\n          console.log(arr);\n```\n```javascript\n     function sortNumber(a, b)\n      {\n        return a - b\n      }\n\n      var arr = new Array(6)\n      arr = [6,5,8,3,12,1100]\n\n      document.write(arr.sort(sortNumber))  // 实现数组又大到小排序\n```\n<br/>\n\n  \n### Javascript如何实现继承？\n\n1、构造继承\n 2、原型继承\n 3、实例继承\n 4、拷贝继承\n\n 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。\n ```javascript\n         function Parent(){\n             this.name = 'wang';\n         }\n\n         function Child(){\n             this.age = 28;\n         }\n         Child.prototype = new Parent();//继承了Parent，通过原型\n\n         var demo = new Child();\n         alert(demo.age);\n         alert(demo.name);//得到被继承的属性\n\n ```\n  \n<br/>\n  \n ### javascript创建对象的几种方式？\n\n    1、对象字面量的方式\n    2、用function来模拟无参的构造函数\n    3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\n    4 、用原型方式来创建\n  \n<br/>\n  \n### Javascript作用链域?\n\n 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。\n 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，\n 直至全局函数，这种组织形式就是作用域链。\n  \n<br/>\n  \n### eval是做什么的？\n\n它的功能是把对应的字符串解析成JS代码并运行；\n 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。\n 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');\n\n什么是window对象? 什么是document对象?\n\n window对象是指浏览器打开的窗口。\n document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。\n  \n<br/>\n  \n### [“1”, “2”, “3”].map(parseInt) 答案是多少？\n\n parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，\n 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;\n 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。\n\n function parseInt(str, radix) {\n     return str+'-'+radix;\n };\n var a=[\"1\", \"2\", \"3\"];\n a.map(parseInt);  // [\"1-0\", \"2-1\", \"3-2\"] 不能大于radix\n\n 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN\n 所以[\"1\", \"2\", \"3\"].map(parseInt) 答案也就是：[1, NaN, NaN]\n\n  \n<br/>\n  \n ### 什么是闭包（closure），为什么要用它？\n\n  闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。\n\n 闭包的特性：\n\n 1.函数内再嵌套函数\n 2.内部函数可以引用外层的参数和变量\n 3.参数和变量不会被垃圾回收机制回收\n  \n<br/>\n  \n ### new操作符具体干了什么呢?\n\n    1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n    2、属性和方法被加入到 this 引用的对象中。\n    3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n  \n<br/>\n  \n### js延迟加载的方式有哪些？\n\n defer和async、动态创建DOM方式（用得最多）、按需异步载入js\n  \n<br/>\n  \n### Ajax 是什么? 如何创建一个Ajax？\n\najax的全称：Asynchronous Javascript And XML。\n 异步传输+js+xml。\n 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。\n\n (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象\n (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\n (3)设置响应HTTP请求状态变化的函数\n (4)发送HTTP请求\n (5)获取异步调用返回的数据\n (6)使用JavaScript和DOM实现局部刷新\n  \n<br/>\n  \n ### 如何判断当前脚本运行在浏览器还是node环境中？\n```javascript\n   this === window ? 'browser' : 'node';\n```\n  通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中\n  \n<br/>\n  \n### 那些操作会造成内存泄漏？\n\n 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。\n 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。\n\n setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n  \n<br/>\n  \n### 检测浏览器版本版本有哪些方式？\n\n  功能检测、userAgent特征检测\n\n  比如：navigator.userAgent\n  \n<br/>\n  \n### Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？\n\n 两等号判等，会在比较时进行类型转换；\n  三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；\n\n  Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，\n  但 Object.is(NaN, NaN) 会返回 true.\n\n   Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。\n  前端框架相关\n  \n<br/>\n  \n### 是否了解公钥加密和私钥加密。\n\n  一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;\n  HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。\n  \n<br/>\n  \n### 对Node的优点和缺点提出了自己的看法？\n\n    *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，\n      因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。\n      此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，\n      因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。\n\n    *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，\n      而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。\n  \n<br/>\n  \n### 你有用过哪些前端性能优化的方法？\n\n    （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\n\n    （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n\n    （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\n\n    （4） 当需要设置的样式很多时设置className而不是直接操作style。\n\n    （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。\n\n    （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。\n\n    （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。\n\n    （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。\n    对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。\n  \n<br/>\n  \n### http状态码有那些？分别代表是什么意思？\n```javascript\n      [\n          100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n          200  OK         正常返回信息\n          201  Created      请求成功并且服务器创建了新的资源\n          202  Accepted     服务器已接受请求，但尚未处理\n          301  Moved Permanently  请求的网页已永久移动到新位置。\n          302 Found          临时性重定向。\n          303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。\n          304  Not Modified 自从上次请求后，请求的网页未修改过。\n\n          400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n          401 Unauthorized 请求未授权。\n          403 Forbidden      禁止访问。\n          404 Not Found      找不到如何与 URI 相匹配的资源。\n\n          500 Internal Server Error  最常见的服务器端错误。\n          503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n      ]\n\n    完整版\n    1**(信息类)：表示接收到请求并且继续处理\n      100——客户必须继续发出请求\n      101——客户要求服务器根据请求转换HTTP协议版本\n\n    2**(响应成功)：表示动作被成功接收、理解和接受\n      200——表明该请求被成功地完成，所请求的资源发送回客户端\n      201——提示知道新文件的URL\n      202——接受和处理、但处理未完成\n      203——返回信息不确定或不完整\n      204——请求收到，但返回信息为空\n      205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n      206——服务器已经完成了部分用户的GET请求\n\n    3**(重定向类)：为了完成指定的动作，必须接受进一步处理\n      300——请求的资源可在多处得到\n      301——本网页被永久性转移到另一个URL\n      302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。\n      303——建议客户访问其他URL或访问方式\n      304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用\n      305——请求的资源必须从服务器指定的地址得到\n      306——前一版本HTTP中使用的代码，现行版本中不再使用\n      307——申明请求的资源临时性删除\n\n    4**(客户端错误类)：请求包含错误语法或不能正确执行\n      400——客户端请求有语法错误，不能被服务器所理解\n      401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n      HTTP 401.1 - 未授权：登录失败\n      　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败\n      　　HTTP 401.3 - ACL 禁止访问资源\n      　　HTTP 401.4 - 未授权：授权被筛选器拒绝\n      HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败\n      402——保留有效ChargeTo头响应\n      403——禁止访问，服务器收到请求，但是拒绝提供服务\n      HTTP 403.1 禁止访问：禁止可执行访问\n      　　HTTP 403.2 - 禁止访问：禁止读访问\n      　　HTTP 403.3 - 禁止访问：禁止写访问\n      　　HTTP 403.4 - 禁止访问：要求 SSL\n      　　HTTP 403.5 - 禁止访问：要求 SSL 128\n      　　HTTP 403.6 - 禁止访问：IP 地址被拒绝\n      　　HTTP 403.7 - 禁止访问：要求客户证书\n      　　HTTP 403.8 - 禁止访问：禁止站点访问\n      　　HTTP 403.9 - 禁止访问：连接的用户过多\n      　　HTTP 403.10 - 禁止访问：配置无效\n      　　HTTP 403.11 - 禁止访问：密码更改\n      　　HTTP 403.12 - 禁止访问：映射器拒绝访问\n      　　HTTP 403.13 - 禁止访问：客户证书已被吊销\n      　　HTTP 403.15 - 禁止访问：客户访问许可过多\n      　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效\n      HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效\n      404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL\n      405——用户在Request-Line字段定义的方法不允许\n      406——根据用户发送的Accept拖，请求资源不可访问\n      407——类似401，用户必须首先在代理服务器上得到授权\n      408——客户端没有在用户指定的饿时间内完成请求\n      409——对当前资源状态，请求不能完成\n      410——服务器上不再有此资源且无进一步的参考地址\n      411——服务器拒绝用户定义的Content-Length属性请求\n      412——一个或多个请求头字段在当前请求中错误\n      413——请求的资源大于服务器允许的大小\n      414——请求的资源URL长于服务器允许的长度\n      415——请求资源不支持请求项目格式\n      416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n      417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。\n\n    5**(服务端错误类)：服务器不能正确执行一个正确的请求\n      HTTP 500 - 服务器遇到错误，无法完成请求\n      　　HTTP 500.100 - 内部服务器错误 - ASP 错误\n      　　HTTP 500-11 服务器关闭\n      　　HTTP 500-12 应用程序重新启动\n      　　HTTP 500-13 - 服务器太忙\n      　　HTTP 500-14 - 应用程序无效\n      　　HTTP 500-15 - 不允许请求 global.asa\n      　　Error 501 - 未实现\n    HTTP 502 - 网关错误\n    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常\n```\n  \n<br/>\n  \n### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\n```javascript\n    详细版：\n      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;\n      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;\n      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;\n      4、进行HTTP协议会话，客户端发送报头(请求报头);\n      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;\n      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;\n      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;\n      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;\n      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;\n      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。\n\n    简洁版：\n      浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；\n      服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；\n      浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；\n      载入解析到的资源文件，渲染页面，完成。\n```\n  \n<br/>\n  \n### 移动端（Android IOS）怎么做好用户体验?\n\n  清晰的视觉纵线、\n  信息的分组、极致的减法、\n  利用选择代替输入、\n  标签及文字的排布方式、\n  依靠明文确认密码、\n  合理的键盘利用、\n\n  ### TCP传输的三次握手四次挥手策略\n\n第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。\n\n第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。\n\n第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。\n\n* 为什么要三次握手：\n为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源\nTCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！\n\n* 四次挥手\n\n1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段；\n2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段；\n3、服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接；\n4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；\n\n### TCP和UDP的区别\n\nTCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来\n\nUDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！\nUDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。\n\n###  HTTP和HTTPS\n\n1、HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS\n2、默认HTTP的端口号为80，HTTPS的端口号为443\n\nHTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。\n\n### 什么是Etag\n\n把Last-Modified和ETag请求的http报头一起使用，可利用客户端（例如浏览器）的缓存。ETag用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么ETag也随之发生变化。浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，\n假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。\n\n### 浏览器的渲染过程\n\n1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。\n2、CSS文件下载完成，开始构建CSSOM\n3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。\n4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。\n5、最后一步，按照算出来的规则，把内容渲染到屏幕上。\n\n以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。\n\n### 一个完整的URL包括以下几部分\n\n1、协议部分\n2、域名部分\n3、端口部分\n4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止\n5、文件名部分：从域名后的最后一个“/”开始到“？”为止\n6、参数部分：从“？”开始到“#”为止之间的部分\n7、锚部分：从“#”开始到最后\n\n### GET和POST的区别\n\nGET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在1024字节，Get是通过地址栏来传值。\n\nPOST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post是通过提交表单来传值。\n\n### 说说网络分层里七层模型是哪七层\n\n应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）\n\n传输层（TCP和UDP）\n\n网络层（IP）\n\n物理和数据链路层（以太网）\n\n### 讲讲304缓存的原理\n\n服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。\n\n304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件\n\n### http keep-alive与tcp keep-alive\n\nhttp keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。\n\n### 常见web安全及防护原理\n\n* sql注入原理\n就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。\n* XSS\n指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。\n* CSRF\nCSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤：1、登录受信任网站A，并在本地生成Cookie。2、在不登出A的情况下，访问危险网站B。\n\n### 对重构的理解\n\n在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。\n\n减少代码间的耦合\n让代码保持弹性\n严格按规范编写代码\n设计可扩展的API\n代替旧有的框架、语言(如VB)\n增强用户体验\n通常来说对于速度的优化也包含在重构中\n\n","source":"_posts/interview-test.md","raw":"---\ntitle: 常见的知识总结\ncategories:  面试\ntags:\n- interview\n---\n\n\n\n###  vue中的MVVM模式 \n  MVVM即Model-View-ViewModel。\n  Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。  ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。 DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化\n\n<br/>\n\n### Vue提供的生命周期钩子\n\n  ①　beforeCreate\n  在实例初始化之后，数据观测(data observer，开始监控Data对象数据变化)和初始化事件(init event，Vue内部初始化事件)之前被调用。\n  ②　created\n  在实例已经创建完成之后被调用。实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，event事件回调。挂载阶段尚未开始，$el 属性不可见。\n  ③　beforeMount\n  在挂载开始之前被调用。相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。\n  ④　mounted\n  在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。此时模板中的html渲染到了html页面中，此时一般可以做一些Ajax操作。注意mounted只会执行一次。\n  ⑤　beforeUpdate\n  在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。\n  ⑥　updated\n  在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。\n  ⑦　beforeDestroy\n  在实例销毁之前调用。实例仍然完全可用。\n  ⑧　destroyed\n  在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。\n\n<br/>\n\n ###  v-show指令，v-if的区别 \n  条件渲染指令，与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style值\n\n<br/>\n\n### 指令keep-alive  \n  在vue-router写着keep-alive，keep-alive的含义： 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令  \n ```javascript\n     <component :is='curremtView' keep-alive></component>\n ```\n  \n<br/>\n\n###  指令v-el的使用\n  有时候我们想就像使用jquery那样去访问一个元素，此时就可以使用v-el指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。\n  \n  HTML不区分大小写，所以v-el:someEl将转换为全小写。可以用v-el:some-el然后设置this.$el.someEl。 \n示例  \n``` javascript\n<span v-el:msg>hello</span> \n<span v-el:other-msg>world</span>  \nthis.$els.msg.textContent // ->\"hello\"  \nthis.$els.otherMsg.textContent // ->\"world\" \nthis.$els.msg //-><span>hello</span>\n```\n  \n<br/>\n\n### Vue.js特点 \n  简洁：页面由HTML模板+Json数据+Vue实例组成 \n  数据驱动：自动计算属性和追踪依赖的模板表达式 \n  组件化：用可复用、解耦的组件来构造页面 \n  轻量：代码量小，不依赖其他库 快速：精确有效批量DOM更新  \n  模板友好：可通过npm，bower等多种方式安装，很容易融入\n  \n<br/>\n\n### JS中的常量（基本数据类型）和内置对象\n  js中的基本数据类型：String 、number、null、boolean、undefined、object、symbol（ES6）\n* 1、 利用typeof运算符时其中只有null是异常的，typeof（null）=object，所以在判断变量类型是否为null时要注意。同时利用typeof时对于没有声明的变量是不会报错的，返回值为undefined。全局变量和函数变量在没有声明时使用是会报错的，但是在对象中使用没有定义的属性是不会报错同样返回的是undefined。Function变量是具有length属性的，其长度为传入的参数的个数。\n* 2、 变量时弱类型的，即其本身是没有类型的，其值才是具有类型的。\n* 3、 对于number类型，\n（1）其中要注意的是NAN非数字的数字，用全局的函数isNAN判断时会有问题，即对于非数字类型的变量其也会返回true，所以在使用时可以用以下方式判断NAN：\n①a!=a\n②利用ES6中的Number.isNAN;\n③typeof(a)==’number’&&isNAN(a)\n（2）还有一个要注意的是+0，-0这两者在使用时是相等的但是在浏览器引擎上还是会有区别，区分二者可以利用：typeof(a)==typeof(b)&&1/a==1/b，+0、-0作为分母时会得到infinite和-infinite。在ES6中有Object.is方法可用于判断两个变量是否相等。可用于上述情况。但是前者的方法的执行效率更好。\n（3）另外在JS中数字类型也是有最大和最小值的界定的安全范围的\n（4）判断变量是否为整数的方法：\n①Number.isInteger(a)，ES6中的方法\n②typeof（a）==’number’&&a%1==0\n③或者使用Math.ceil(a)==a等类似的方法\n* 4、变量在复制和作为参数传递时会有引用传递和值传递之分：\n（1）值传递即普通的变量类型\n（2）引用传递，如对象和数组等幅值或者作为参数传递传递的是复制的引用会相会影响：\n``` javascript\nVar a=[1,2,3];\nVar b=a;\nb.push(4);//a=[1,2,3,4];b=[1,2,3,4]\n但是当b重新赋值时：\nVar b=[4,5,6]//a=[1,2,3,4];b=[4,5,6]因为b的引用已经发生了改变不在是a数组的引用的复制。\n```\nJS中的内置函数: String、Number、Boolean、RegExp、Date、Error、Array、\nFunction、Object、symbol;类似于对象的构造函数\n* 1、这些内置函数构造的变量都是封装了基本类型值的对象如：\n``` javascript\nVar a=new String(‘abb’); //typeof(a)=object\n```\n除了利用Function构造的变量通过typeof输出为function外其他均为object\n\n* 2、为了知道构造的变量的真实类型可以利用：\n``` javascript\nObject.prototype.toString.call([1,2,3]);//”[object,array]”\n```\n后面的一个值即为传入参数的类型\n* 3、如果有常量形式（即利用基本数据类型）赋值给变量就不要用该方式来定义变量\n  \n<br/>\n  \n### js中判断一个对象的类型的种种方法\n\n#### javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。\n\n* typeof：typeof是一个一元运算符，返回结果是一个说明运算数类型的字符串。如：\"number\"，\"string\"，\"boolean\"，\"object\"，\"function\"，\"undefined\"（可用于判断变量是否存在）。 但 typeof 的能力有限，其对于Date、RegExp、Array类型返回的都是\"object\"。所以它只在区别对象和原始类型的时候才有用。要区一种对象类型和另一种对象类型，必须使用其他的方法。\n\n* instanceof 运算符：instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。instanceof方法可以判断变量是否是数组类型，但是只限同一全局环境之内，在一个页面有多个iframe的情况下，instanceof失效。\n\n* constructor 属性: JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。如给定一个求知的值 通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。\n\n* Object.prototype.toString.call()：该方法是目前为止发现的判断一个对象类型的最好的办法。\n\n  \n<br/>\n  \n### 事件冒泡与事件捕获\n#### 事件冒泡\n微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象，由内向外。\n### 事件捕获\n网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素，由外向内。\n\naddEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数：\n```javascript\nelement.addEventListener(event, function, useCapture)\n```\n第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。\n\n对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。\n##### IE浏览器\nIE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。\n```javascript\nele.attachEvent(\"onclick\", doSomething2);\n```\n附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。\n#### 事件的传播是可以阻止的：\n• 在W3c中，使用stopPropagation（）方法\n• 在IE下设置cancelBubble = true；\n在捕获的过程中stopPropagation（）；后，后面的冒泡过程也不会发生了~\n3.阻止事件的默认行为，例如click a 后的跳转~\n• 在W3c中，使用preventDefault（）方法；\n• 在IE下设置window.event.returnValue = false;\n  \n<br/>\n  \n### 浏览器的重绘与重排\n\n1.重排的概念\n浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM树和渲染树），DOM树表示页面结构，渲染树表示DOM节点如何显示。重排是DOM元素的几何属性变化，DOM树的结构变化，渲染树需要重新计算。\n\n2.重绘的概念\n重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。\n\n3.重绘和重排的关系\n重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。\n\n4.什么情况下会触发重排？\n(1)页面渲染初始化时；（这个无法避免）\n(2)浏览器窗口改变尺寸；\n(3)元素尺寸改变时；\n(4)元素位置改变时；\n(5)元素内容改变时；\n(6)添加或删除可见的DOM 元素时。\n\n6.无论是外链CSS还是内联CSS都会阻塞DOM渲染（Rendering），然而DOM解析（Parsing）会正常进行。 这意味着在CSS下载并解析结束之前，它后面的HTML都不会显示。 这也是为什么我们把样式放在HTML内容之前，以防止被呈现内容发生样式跳动。 当然代价就是显示延迟，所以性能攸关的站点都会内联所有CSS。\n  \n<br/>\n  \n### $.extend(obj);$.fn.extend(obj);\n\n$拓展的方法是静态方法，可以使用$直接调用，其拓展的方式有两种，一般使用$.extend({});而$.fn拓展的方法是实例方法，必须由“对象”$(\"\")来调用，其拓展的方式同样有两种，一般使用$.fn.extend({ })。\n\n$.extend(obj);是为了扩展jquery本身，为类添加新的方法\n\n$.fn.extend(obj);给JQUERY对象添加方法。\n\n$.fn 中的fn其实是prototype，即$.fn=$.prototype;\n\n```javascript\n$.extend({\nadd:function(a,b){\n  return a+b;\n  }\n})\n$.add(5,8) //return 13\n```\n这边的调用直接调用，前面不用任何对象。直接$.+方法名\n\n$.fn.extend(obj)；对prototype进行扩展，为jquery类添加成员函数， jquery类的实例可以使用这个成员函数。\n\n```javascript\n$.fn.extend({\nclickwhile:function(){\n  $(this).click(function(){\n  alert($(this).val()) \n  })\n}\n})\n$('input').clickwhile();//当点击输入框会弹出该对象的Value值\n```\n注意调用时候前面是有对象的。即$('input') 这么个东西。\n  \n<br/>\n  \n\n### CSS hack区分IE6,IE7,IE8,firefox\n\n#### CSS hack使用原理\n\n简单来讲，CSS hack就是浏览器解析CSS时的漏洞，因此不同的浏览器就有不同的CSS hack写法。 CSS hack使用原则: 尽力避免使用CSS hack，并寻找其它的应对方法。事实上，使用IE的条件注释来区分IE各个版本，是非常不错的选择。\n\n#### CSS hack使用后的弊端\n\nCSS Hack除了能迅速区分浏览器版本，并可能获得大概一直的效果，但从长远看，CSS Hack会引起许多新的错误。\n\n#### CSS hack的实现方式(针对IE6)\n\n* 1.利用浏览器对相同代码的解析和支持的不同实现的hack\n```javascript\n #test{\n    _width:80px;\n }\n```\n在IE7及以上版本的浏览器中会被当作错误特性而舍弃，但是在IE6中可以被正常的解析。这时候，可以把_width当作hack，专门针对IE6来设置元素的宽度。\n\n* 2.利用IE对标准的支持缺陷写的CSS hack\n!important只有IE7及以上版本的IE及其他浏览器支持，所以，可以用!important来针对IE6以外的浏览器写CSS代码；再如，head:first-child+bodyselector，:first-child不被IE6支持，所以可以用来针对IE6以外的浏览器编写CSS代码。IE6支持下划线，IE7和firefox均不支持下划线。\n\n>CSS hack区别IE6与Firefox：\n>background:orange;*background:blue;\n\n>CSS hack区别IE6与IE7：\n>background:green !important;background:blue;\n\n>CSS hack区别IE7与Firefox：\n>background:orange; *background:green;\n\n>CSS hack区别Firefox，IE7，IE6：\n>background:orange;*background:green !important;*background:blue;\n  \n<br/>\n  \n### 如何避免FOUC？\n如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.原因大致为：\n\n1，使用import方法导入样式表。\n2，将样式表放在页面底部\n3，有几个样式表，放在html结构的不同位置。其实原理很清楚：当样式表晚于 结构性html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂 的 花屏现象。解决方法：使用LINK标签将样式表放在文档HEAD中更多\n  \n<br/>\n  \n### DOM 中 Property 和 Attribute 的区别\n\n* Property：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型直接继承自Element并添加了一些属性，添加的这些属性分别对应于每个HTML元素都有下面的这5个标准特性: id,title,lang,dir,className。DOM节点是一个对象，因此，他可以和其他的JavaScript对象一样添加自定义的属性以及方法。property的值可以是任何的数据类型，对大小写敏感，自定义的property不会出现在html代码中，只存在js中。\n\n* Attribute：特性，区别于property，attribute只能是字符串，大小写不敏感，出现在innerHTML中，通过类数组attributes可以罗列所有的attribute。\n  \n<br/>\n  \n### document.onload和document.ready两个事件的区别\n\n* ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）\n* onload，指示页面包含图片等文件在内的所有元素都加载完成。\n  \n<br/>\n  \n### JavaScript的同源策略\n\n在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。\n  \n<br/>\n  \n### 给选择器一个上下文\n\njQuery选择器中有一个这样的选择器，它能指定上下文。jQuery(expression,context);通过它，能缩小选择器在DOM中搜索的范围，达到节省时间，提高效率。普通方式：$(‘.myDiv’)改进方式：$(‘.myDiv’,$(“#listItem”))。\n  \n<br/>\n  \n### 请解释JSONP的工作原理，以及它为什么不是真正的AJAX\n\nJSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。\n\nAJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！\n  \n<br/>\n  \n### 浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别\n\n特性检测：为特定浏览器的特性进行测试，并仅当特性存在时即可应用特性。\n\nUser-Agent检测：最早的浏览器嗅探即用户代理检测，服务端（以及后来的客户端）根据UA字符串屏蔽某些特定的浏览器查看网站内容。\n\n特性推断：尝试使用多个特性但仅验证了其中之一。根据一个特性的存在推断另一个特性是否存在。问题是，推断是假设并非事实，而且可能导致可维护性的问题\n  \n<br/>\n  \n### JavaScript宿主对象和原生对象的区别\n\n#### 原生对象\n\nECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。\n\n“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。\n\n由此可以看出，简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。\n\n#### 内置对象\n\nECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。\n\n同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。如此就可以理解了。内置对象是本地对象的一种。\n\n#### 宿主对象\n\n何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。\n\n所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的BOM和DOM都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。\n  \n<br/>\n  \n### AMD、CMD和CommonJS规范\n\n#### CommonJS规范\n\n CommonJS是在浏览器环境之外构建JavaScript生态系统为目标产生的项目，比如服务器和桌面环境中。CommonJS规范是为了解决JavaScript的作用域问题而定义的模块形式，\n可以使每个模块在它自身的命名空间中执行。该规范的主要内容是：模块必须通过  module.exports导出对外的变量或接口，通过require()来导入其他模块的输出到当前模块。\n```javascript\n// moduleA.js  \nmodule.exports = function( value ){  \n    return value * 2;  \n}  \n```\n```javascript\n// moduleB.js  \nvar multiplyBy2 = require('./moduleA');  \nvar result = multiplyBy2(4);  \n```\nCommonJS是同步加载模块，但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过id进行索引，这样就可以浏览器进行解析了\n\n服务器端的Node.js遵循CommonJS规范。核心思想是允许模块通过require 方法来同步加载所要依赖的其他模块，然后通过 exports或module.exports来导出需要暴露的接口。\n\n优点：\n服务器端便于重用\nNPM中已经将近20w个模块包\n简单并容易使用\n缺点：\n同步的模块方式不适合不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的\n不能非阻塞的并行加载多个模块\n\n#### AMD\n\nAMD规范其实只有一个主要接口 define(id,dependencies,factory)，它要在声明模块的时候指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置\n\n```javascript\ndefine(\"module\", [\"dep1\", \"dep2\"], function(d1, d2) {  \n  return someExportedValue;  \n});  \nrequire([\"module\", \"../file\"], function(module, file) { /* ... */ });  \\\n```\n\n优点：\n适合在浏览器环境异步加载\n并行加载多个模块\n缺点：\n提高开发成本，代码阅读和书写比较困难\n不符合通用的模块思维方式，是一种妥协的实现\n\n#### CMD\n\nCMD规范和AMD相似，尽量保持简单，并且与CommonJS和NodeJS的Modules规范保持了很大的兼容性。\n\n```javascript\ndefine(function(require, exports, module) {  \n  var $ = require('jquery');  \n  var Spinning = require('./spinning');  \n  exports.doSomething = ...  \n  module.exports = ...  \n})  \n```\n\n优点：\n依赖就近，延迟执行\n很容易在node中运行\n缺点：\n依赖SPM打包，模块的加载逻辑偏重\n  \n<br/>\n  \n### 事件代理\n\nJavaScript事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个父级元素上，这样就避免了把事件处理器添加到多个子级元素上。当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。事件代理用到了两个在JavaSciprt事件中常被忽略的特性：事件冒泡以及目标元素。\n  \n<br/>\n  \n### 如果设计中使用了非标准的字体，如何去实现\n\n所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。\n方法：\n* 用图片代替\n* web fonts在线字库，如Google Webfonts，Typekit等等；http://www.chinaz.com/free/2012/0815/269267.shtml；\n* @font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)\n  \n<br/>\n  \n### 使用CSS预处理器的优缺点\n\nLESS&SassLESS是受Sass启发而开发的工具，它列出了如下开发的理由：\n\n“为什么要开发一个Sass的替代品呢？原因很简单：首先是语法。Sass的一个关键特性是缩进式的语法，这种语法可以产生柱式外观的代码。但是你需要花费时间学习一门新的语法以及重新构建你现在的样式表。LESS给CSS带来了很多特性，使得LESS能够和CSS无缝地紧密结合在一起。因此，你可以平滑地由CSS迁移到LESS，如果你只是对使用变量或者操作感兴趣的话，你不需要学习一整门全新的语言。”\n\nStylus相对前两者较新，可以看官方文档介绍的功能。\n\n1.来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：http://learnboost.github.io/stylus/docs/js.html；\n2.支持Ruby之类等等框架；\n3.更多更强大的支持和功能总结：Sass看起来在提供的特性上占有优势，但是LESS能够让开发者平滑地从现存CSS文件过渡到LESS，而不需要像Sass那样需要将CSS文件转换成Sass格式。Stylus功能上更为强壮，和js联系更加紧密。\n  \n<br/>\n  \n### cookies，sessionStorage和localStorage的区别\n\ncookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。\n  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。\n  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。\n\n存储大小：\n  cookie数据大小不能超过4k。\n  sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。\n\n有期时间：\n  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；\n  sessionStorage  数据在当前浏览器窗口关闭后自动删除。\n  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭\n  \n<br/>\n  \n### 浏览器标准模式和怪异模式之间的区别\n\nW3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。这样浏览器渲染上就产生了Quircks mode和Standars mode，两种渲染方法共存在一个浏览器上。IE盒子模型和标准W3C盒子模型：ie的width包括：padding\\border。标准的width不包括：padding\\border\n\n 在js中如何判断当前浏览器正在以何种方式解析？\n         document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。\n  \n<br/>\n  \n### doctype（文档类型）的作用，有多少种文档类型\n\n此标签可告知浏览器文档使用哪种HTML或XHTML规范。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。\n\nHTML 4.01规定了三种文档类型：Strict、Transitional以及Frameset。\n\nXHTML 1.0规定了三种XML文档类型：Strict、Transitional以及Frameset。\n\nStandards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。\n  \n<br/>\n  \n### 对语义化的理解\n\n1：去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如 h1 是粗体，字体大小2em，加粗；strong 是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。\n\n2.屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页。\n\n3.PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）。\n\n4.有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。\n\n5.便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。\n  \n<br/>\n  \n### 渐进增强和优雅降级\n\n优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.\n\n渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。\n  \n<br/>\n  \n### 浏览器同一时间可以从一个域名下载多少资源\n\n这个专业的说法叫“浏览器并发请求数”。意即，同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻止。所有浏览器的并发数目一般限制在10以内。\n\n <img src=\"https://pic4.zhimg.com/ea606d016e8ab77db9d8a8dfa5243a1b_r.jpg\" width=\"200\" height=\"200\">\n  \n<br/>\n  \n### Canvas 与 SVG \n#### Canvas\n* 依赖分辨率\n* 不支持事件处理器\n* 弱的文本渲染能力\n* 能够以 .png 或 .jpg 格式保存结果图像\n* 最适合图像密集型的游戏，其中的许多对象会被频繁重绘\n### SVG\n* 不依赖分辨率\n* 支持事件处理器\n* 最适合带有大型渲染区域的应用程序（比如谷歌地图）\n* 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）\n* 不适合游戏应用\n  \n<br/>\n  \n### 页面导入样式时，使用link和@import有什么区别\n\n（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;\n\n（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;\n\n（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问\n  \n<br/>\n  \n### 介绍一下你对浏览器内核的理解\n\n  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。\n  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。\n\n  JS引擎则：解析和执行javascript来实现网页的动态效果。\n\n  最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。\n  \n<br/>\n  \n### 常见的浏览器内核有哪些？\n\n  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]\n  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等\n  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]\n  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]\n  \n<br/>\n  \n### html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和\nHTML5？\n\n * HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。\n          绘画 canvas;\n          用于媒介回放的 video 和 audio 元素;\n          本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\n          sessionStorage 的数据在浏览器关闭后自动删除;\n          语意化更好的内容元素，比如 article、footer、header、nav、section;\n          表单控件，calendar、date、time、email、url、search;\n          新的技术webworker, websocket, Geolocation;\n\n      移除的元素：\n          纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n          对可用性产生负面影响的元素：frame，frameset，noframes；\n\n    * 支持HTML5新标签：\n         IE8/IE7/IE6支持通过document.createElement方法产生的标签，\n           可以利用这一特性让这些浏览器支持HTML5新标签，\n           浏览器支持新标签后，还需要添加标签默认的样式。\n\n         当然也可以直接使用成熟的框架、比如html5shim;\n\n    * 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素\n  \n<br/>\n  \n### HTML5的离线储存怎么使用\n\n  在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。\n  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。\n  \n<br/>\n  \n### 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\n\n  在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。\n  离线的情况下，浏览器就直接使用离线存储的资源。\n  \n<br/>\n  \n### iframe有那些缺点？\n\n  * iframe会阻塞主页面的Onload事件；\n  * 搜索引擎的检索程序无法解读这种页面，不利于SEO;\n\n  * iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。\n\n  使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript\n  动态给iframe添加src属性值，这样可以绕开以上两个问题。\n  \n<br/>\n  \n### Label的作用是什么？是怎么用的?\n\n label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。\n```javascript\n  <label for=\"Name\">Number:</label>\n  <input type=“text“name=\"Name\" id=\"Name\"/>\n\n  <label>Date:<input type=\"text\" name=\"B\"/></label>\n```\n  \n<br/>\n  \n### HTML5的form如何关闭自动完成功能？\n\n  给不想要提示的 form 或某个 input 设置为 autocomplete=off。\n  \n<br/>\n  \n### 如何实现浏览器内多个标签页之间的通信?\n\n  WebSocket、SharedWorker；\n  也可以调用localstorge、cookies等本地存储方式；\n\n  localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，\n  我们通过监听事件，控制它的值来进行页面信息通信；\n  注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；\n  \n<br/>\n  \n### webSocket如何兼容低浏览器？\n\n * Adobe Flash Socket 、\n * ActiveX HTMLFile (IE) 、\n * 基于 multipart 编码发送 XHR 、\n * 基于长轮询的 XHR\n  \n<br/>\n  \n### 页面可见性（Page Visibility API） 可以有哪些用途？\n\n  通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;\n  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；\n  \n<br/>\n  \n### 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\n```javascript\n  <div style=\"height:1px;overflow:hidden;background:red\"></div>\n```\n  \n<br/>\n  \n### 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\n\n  （1）有两种， IE 盒子模型、W3C 盒子模型；\n  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；\n  （3）区  别： IE的content部分把 border 和 padding计算了进去;\n  \n<br/>\n  \n### CSS优先级算法如何计算？\n\n  *   优先级就近原则，同权重情况下样式定义最近者为准;\n  *   载入样式以最后载入的定位为准;\n\n  优先级为:\n      同权重: 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。\n      !important >  id > class > tag\n      important 比 内联优先级高\n  \n<br/>\n  \n### CSS3新增伪类有那些？\n\n      举例：\n      p:first-of-type    选择属于其父元素的首个 <p> 元素的每个 <p> 元素。\n      p:last-of-type    选择属于其父元素的最后 <p> 元素的每个 <p> 元素。\n      p:only-of-type    选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。\n      p:only-child        选择属于其父元素的唯一子元素的每个 <p> 元素。\n      p:nth-child(2)    选择属于其父元素的第二个子元素的每个 <p> 元素。\n\n      :after            在元素之前添加内容,也可以用来做清除浮动。\n      :before            在元素之后添加内容\n       :enabled          \n      :disabled         控制表单控件的禁用状态。\n      :checked        单选框或复选框被选中。\n  \n<br/>\n  \n### CSS3有哪些新特性？\n\n 新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）\n      圆角            （border-radius:8px）\n    多列布局        （multi-column layout）\n    阴影和反射    （Shadow\\Reflect）\n    文字特效        （text-shadow、）\n    文字渲染        （Text-decoration）\n    线性渐变        （gradient）\n    旋转             （transform）\n    缩放,定位,倾斜,动画,多背景\n    例如:transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:\n  \n<br/>\n  \n### 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景 \n\n  一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。\n   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。\n   采用Flex布局的元素，称为Flex容器（flex container），简称\"容器\"。\n   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称\"项目\"。\n   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。\n   在布局上有了比以前更加灵活的空间。\n  \n<br/>\n  \n### li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\n\n 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。\n\n  \n<br/>\n  \n### 对BFC规范(块级格式化上下文：block formatting context)的理解？\n\n（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）\n   一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。\n   不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。\n  \n<br/>\n  \n### ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用\n\n单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）\n  双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，\n  比如:first-line、:first-letter、:before、:after等，\n  而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。\n\n  想让插入的内容出现在其它内容前，使用::before，否者，使用::after；\n  在代码顺序上，::after生成的内容也比::before生成的内容靠后。\n  如果按堆栈视角，::after生成的内容会在::before生成的内容之上\n  \n<br/>\n  \n### 让页面里的字体变清晰，变细用CSS怎么做？\n\n  -webkit-font-smoothing: antialiased;\n  \n<br/>\n  \n### position:fixed;在android下无效怎么处理？\n\n  fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，\n  原来的网页还好好的在那，fixed的内容也没有变过位置，\n  所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"/>\n  \n<br/>\n  \n### 如果需要手动写动画，你认为最小时间间隔是多久，为什么？\n\n多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms\n\ndisplay:inline-block 什么时候会显示间隙？\n\n移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing\n  \n<br/>\n  \n### 什么是CSS 预处理器 / 后处理器？   \n\n - 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，\n    还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。\n\n  - 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的\n    是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。\n\n  \n<br/>\n  \n### JavaScript原型，原型链 ? 有什么特点？\n\n每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，\n 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，\n 于是就这样一直找下去，也就是我们平时所说的原型链的概念。\n 关系：instance.constructor.prototype = instance.__proto__\n\n 特点：\n JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。\n  \n<br/>\n  \n### 如何将字符串转化为数字，例如’12.3b’?\n\n * parseFloat('12.3b');\n * 正则表达式，'12.3b'.match(/(\\d)+(\\.)?(\\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。\n  \n<br/>\n  \n### 如何实现数组的随机排序？\n```javascript\n          var arr = [1,2,3,4,5,6,7,8,9,10];\n          arr.sort(function(){\n              return Math.random() - 0.5;\n           // return Math.random() ;   从大到小\n           // return Math.random() - 1;  从小到大\n          })\n          console.log(arr);\n```\n```javascript\n     function sortNumber(a, b)\n      {\n        return a - b\n      }\n\n      var arr = new Array(6)\n      arr = [6,5,8,3,12,1100]\n\n      document.write(arr.sort(sortNumber))  // 实现数组又大到小排序\n```\n<br/>\n\n  \n### Javascript如何实现继承？\n\n1、构造继承\n 2、原型继承\n 3、实例继承\n 4、拷贝继承\n\n 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。\n ```javascript\n         function Parent(){\n             this.name = 'wang';\n         }\n\n         function Child(){\n             this.age = 28;\n         }\n         Child.prototype = new Parent();//继承了Parent，通过原型\n\n         var demo = new Child();\n         alert(demo.age);\n         alert(demo.name);//得到被继承的属性\n\n ```\n  \n<br/>\n  \n ### javascript创建对象的几种方式？\n\n    1、对象字面量的方式\n    2、用function来模拟无参的构造函数\n    3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\n    4 、用原型方式来创建\n  \n<br/>\n  \n### Javascript作用链域?\n\n 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。\n 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，\n 直至全局函数，这种组织形式就是作用域链。\n  \n<br/>\n  \n### eval是做什么的？\n\n它的功能是把对应的字符串解析成JS代码并运行；\n 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。\n 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval('('+ str +')');\n\n什么是window对象? 什么是document对象?\n\n window对象是指浏览器打开的窗口。\n document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。\n  \n<br/>\n  \n### [“1”, “2”, “3”].map(parseInt) 答案是多少？\n\n parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，\n 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;\n 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。\n\n function parseInt(str, radix) {\n     return str+'-'+radix;\n };\n var a=[\"1\", \"2\", \"3\"];\n a.map(parseInt);  // [\"1-0\", \"2-1\", \"3-2\"] 不能大于radix\n\n 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN\n 所以[\"1\", \"2\", \"3\"].map(parseInt) 答案也就是：[1, NaN, NaN]\n\n  \n<br/>\n  \n ### 什么是闭包（closure），为什么要用它？\n\n  闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。\n\n 闭包的特性：\n\n 1.函数内再嵌套函数\n 2.内部函数可以引用外层的参数和变量\n 3.参数和变量不会被垃圾回收机制回收\n  \n<br/>\n  \n ### new操作符具体干了什么呢?\n\n    1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n    2、属性和方法被加入到 this 引用的对象中。\n    3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n  \n<br/>\n  \n### js延迟加载的方式有哪些？\n\n defer和async、动态创建DOM方式（用得最多）、按需异步载入js\n  \n<br/>\n  \n### Ajax 是什么? 如何创建一个Ajax？\n\najax的全称：Asynchronous Javascript And XML。\n 异步传输+js+xml。\n 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。\n\n (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象\n (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息\n (3)设置响应HTTP请求状态变化的函数\n (4)发送HTTP请求\n (5)获取异步调用返回的数据\n (6)使用JavaScript和DOM实现局部刷新\n  \n<br/>\n  \n ### 如何判断当前脚本运行在浏览器还是node环境中？\n```javascript\n   this === window ? 'browser' : 'node';\n```\n  通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中\n  \n<br/>\n  \n### 那些操作会造成内存泄漏？\n\n 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。\n 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。\n\n setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。\n 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）\n  \n<br/>\n  \n### 检测浏览器版本版本有哪些方式？\n\n  功能检测、userAgent特征检测\n\n  比如：navigator.userAgent\n  \n<br/>\n  \n### Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？\n\n 两等号判等，会在比较时进行类型转换；\n  三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；\n\n  Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，\n  但 Object.is(NaN, NaN) 会返回 true.\n\n   Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。\n  前端框架相关\n  \n<br/>\n  \n### 是否了解公钥加密和私钥加密。\n\n  一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;\n  HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。\n  \n<br/>\n  \n### 对Node的优点和缺点提出了自己的看法？\n\n    *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，\n      因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。\n      此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，\n      因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。\n\n    *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，\n      而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。\n  \n<br/>\n  \n### 你有用过哪些前端性能优化的方法？\n\n    （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\n\n    （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n\n    （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\n\n    （4） 当需要设置的样式很多时设置className而不是直接操作style。\n\n    （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。\n\n    （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。\n\n    （7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。\n\n    （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。\n    对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。\n  \n<br/>\n  \n### http状态码有那些？分别代表是什么意思？\n```javascript\n      [\n          100  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息\n          200  OK         正常返回信息\n          201  Created      请求成功并且服务器创建了新的资源\n          202  Accepted     服务器已接受请求，但尚未处理\n          301  Moved Permanently  请求的网页已永久移动到新位置。\n          302 Found          临时性重定向。\n          303 See Other      临时性重定向，且总是使用 GET 请求新的 URI。\n          304  Not Modified 自从上次请求后，请求的网页未修改过。\n\n          400 Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。\n          401 Unauthorized 请求未授权。\n          403 Forbidden      禁止访问。\n          404 Not Found      找不到如何与 URI 相匹配的资源。\n\n          500 Internal Server Error  最常见的服务器端错误。\n          503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。\n      ]\n\n    完整版\n    1**(信息类)：表示接收到请求并且继续处理\n      100——客户必须继续发出请求\n      101——客户要求服务器根据请求转换HTTP协议版本\n\n    2**(响应成功)：表示动作被成功接收、理解和接受\n      200——表明该请求被成功地完成，所请求的资源发送回客户端\n      201——提示知道新文件的URL\n      202——接受和处理、但处理未完成\n      203——返回信息不确定或不完整\n      204——请求收到，但返回信息为空\n      205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件\n      206——服务器已经完成了部分用户的GET请求\n\n    3**(重定向类)：为了完成指定的动作，必须接受进一步处理\n      300——请求的资源可在多处得到\n      301——本网页被永久性转移到另一个URL\n      302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。\n      303——建议客户访问其他URL或访问方式\n      304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用\n      305——请求的资源必须从服务器指定的地址得到\n      306——前一版本HTTP中使用的代码，现行版本中不再使用\n      307——申明请求的资源临时性删除\n\n    4**(客户端错误类)：请求包含错误语法或不能正确执行\n      400——客户端请求有语法错误，不能被服务器所理解\n      401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用\n      HTTP 401.1 - 未授权：登录失败\n      　　HTTP 401.2 - 未授权：服务器配置问题导致登录失败\n      　　HTTP 401.3 - ACL 禁止访问资源\n      　　HTTP 401.4 - 未授权：授权被筛选器拒绝\n      HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败\n      402——保留有效ChargeTo头响应\n      403——禁止访问，服务器收到请求，但是拒绝提供服务\n      HTTP 403.1 禁止访问：禁止可执行访问\n      　　HTTP 403.2 - 禁止访问：禁止读访问\n      　　HTTP 403.3 - 禁止访问：禁止写访问\n      　　HTTP 403.4 - 禁止访问：要求 SSL\n      　　HTTP 403.5 - 禁止访问：要求 SSL 128\n      　　HTTP 403.6 - 禁止访问：IP 地址被拒绝\n      　　HTTP 403.7 - 禁止访问：要求客户证书\n      　　HTTP 403.8 - 禁止访问：禁止站点访问\n      　　HTTP 403.9 - 禁止访问：连接的用户过多\n      　　HTTP 403.10 - 禁止访问：配置无效\n      　　HTTP 403.11 - 禁止访问：密码更改\n      　　HTTP 403.12 - 禁止访问：映射器拒绝访问\n      　　HTTP 403.13 - 禁止访问：客户证书已被吊销\n      　　HTTP 403.15 - 禁止访问：客户访问许可过多\n      　　HTTP 403.16 - 禁止访问：客户证书不可信或者无效\n      HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效\n      404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL\n      405——用户在Request-Line字段定义的方法不允许\n      406——根据用户发送的Accept拖，请求资源不可访问\n      407——类似401，用户必须首先在代理服务器上得到授权\n      408——客户端没有在用户指定的饿时间内完成请求\n      409——对当前资源状态，请求不能完成\n      410——服务器上不再有此资源且无进一步的参考地址\n      411——服务器拒绝用户定义的Content-Length属性请求\n      412——一个或多个请求头字段在当前请求中错误\n      413——请求的资源大于服务器允许的大小\n      414——请求的资源URL长于服务器允许的长度\n      415——请求资源不支持请求项目格式\n      416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段\n      417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。\n\n    5**(服务端错误类)：服务器不能正确执行一个正确的请求\n      HTTP 500 - 服务器遇到错误，无法完成请求\n      　　HTTP 500.100 - 内部服务器错误 - ASP 错误\n      　　HTTP 500-11 服务器关闭\n      　　HTTP 500-12 应用程序重新启动\n      　　HTTP 500-13 - 服务器太忙\n      　　HTTP 500-14 - 应用程序无效\n      　　HTTP 500-15 - 不允许请求 global.asa\n      　　Error 501 - 未实现\n    HTTP 502 - 网关错误\n    HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常\n```\n  \n<br/>\n  \n### 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\n```javascript\n    详细版：\n      1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;\n      2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;\n      3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;\n      4、进行HTTP协议会话，客户端发送报头(请求报头);\n      5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;\n      6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;\n      7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304;\n      8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存;\n      9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;\n      10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。\n\n    简洁版：\n      浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；\n      服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；\n      浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；\n      载入解析到的资源文件，渲染页面，完成。\n```\n  \n<br/>\n  \n### 移动端（Android IOS）怎么做好用户体验?\n\n  清晰的视觉纵线、\n  信息的分组、极致的减法、\n  利用选择代替输入、\n  标签及文字的排布方式、\n  依靠明文确认密码、\n  合理的键盘利用、\n\n  ### TCP传输的三次握手四次挥手策略\n\n第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。\n\n第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。\n\n第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。\n\n* 为什么要三次握手：\n为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源\nTCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！\n\n* 四次挥手\n\n1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段；\n2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段；\n3、服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接；\n4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；\n\n### TCP和UDP的区别\n\nTCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来\n\nUDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！\nUDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。\n\n###  HTTP和HTTPS\n\n1、HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS\n2、默认HTTP的端口号为80，HTTPS的端口号为443\n\nHTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。\n\n### 什么是Etag\n\n把Last-Modified和ETag请求的http报头一起使用，可利用客户端（例如浏览器）的缓存。ETag用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么ETag也随之发生变化。浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，\n假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。\n\n### 浏览器的渲染过程\n\n1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。\n2、CSS文件下载完成，开始构建CSSOM\n3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。\n4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。\n5、最后一步，按照算出来的规则，把内容渲染到屏幕上。\n\n以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。\n\n### 一个完整的URL包括以下几部分\n\n1、协议部分\n2、域名部分\n3、端口部分\n4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止\n5、文件名部分：从域名后的最后一个“/”开始到“？”为止\n6、参数部分：从“？”开始到“#”为止之间的部分\n7、锚部分：从“#”开始到最后\n\n### GET和POST的区别\n\nGET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在1024字节，Get是通过地址栏来传值。\n\nPOST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post是通过提交表单来传值。\n\n### 说说网络分层里七层模型是哪七层\n\n应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）\n\n传输层（TCP和UDP）\n\n网络层（IP）\n\n物理和数据链路层（以太网）\n\n### 讲讲304缓存的原理\n\n服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。\n\n304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件\n\n### http keep-alive与tcp keep-alive\n\nhttp keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。\n\n### 常见web安全及防护原理\n\n* sql注入原理\n就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。\n* XSS\n指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。\n* CSRF\nCSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤：1、登录受信任网站A，并在本地生成Cookie。2、在不登出A的情况下，访问危险网站B。\n\n### 对重构的理解\n\n在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。\n\n减少代码间的耦合\n让代码保持弹性\n严格按规范编写代码\n设计可扩展的API\n代替旧有的框架、语言(如VB)\n增强用户体验\n通常来说对于速度的优化也包含在重构中\n\n","slug":"interview-test","published":1,"date":"2017-08-14T03:50:58.000Z","updated":"2017-08-14T03:50:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjvuo4akn001egvk9rw458ux7","content":"<h3 id=\"vue中的MVVM模式\"><a href=\"#vue中的MVVM模式\" class=\"headerlink\" title=\"vue中的MVVM模式\"></a>vue中的MVVM模式</h3><p>  MVVM即Model-View-ViewModel。<br>  Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。  ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。 DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化</p>\n<p><br></p>\n<h3 id=\"Vue提供的生命周期钩子\"><a href=\"#Vue提供的生命周期钩子\" class=\"headerlink\" title=\"Vue提供的生命周期钩子\"></a>Vue提供的生命周期钩子</h3><p>  ①　beforeCreate<br>  在实例初始化之后，数据观测(data observer，开始监控Data对象数据变化)和初始化事件(init event，Vue内部初始化事件)之前被调用。<br>  ②　created<br>  在实例已经创建完成之后被调用。实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，event事件回调。挂载阶段尚未开始，$el 属性不可见。<br>  ③　beforeMount<br>  在挂载开始之前被调用。相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。<br>  ④　mounted<br>  在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。此时模板中的html渲染到了html页面中，此时一般可以做一些Ajax操作。注意mounted只会执行一次。<br>  ⑤　beforeUpdate<br>  在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。<br>  ⑥　updated<br>  在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。<br>  ⑦　beforeDestroy<br>  在实例销毁之前调用。实例仍然完全可用。<br>  ⑧　destroyed<br>  在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>\n<p><br></p>\n<h3 id=\"v-show指令，v-if的区别\"><a href=\"#v-show指令，v-if的区别\" class=\"headerlink\" title=\"v-show指令，v-if的区别\"></a>v-show指令，v-if的区别</h3><p>  条件渲染指令，与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style值</p>\n<p><br></p>\n<h3 id=\"指令keep-alive\"><a href=\"#指令keep-alive\" class=\"headerlink\" title=\"指令keep-alive\"></a>指令keep-alive</h3><p>  在vue-router写着keep-alive，keep-alive的含义： 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component :is=<span class=\"string\">'curremtView'</span> keep-alive&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"指令v-el的使用\"><a href=\"#指令v-el的使用\" class=\"headerlink\" title=\"指令v-el的使用\"></a>指令v-el的使用</h3><p>  有时候我们想就像使用jquery那样去访问一个元素，此时就可以使用v-el指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。</p>\n<p>  HTML不区分大小写，所以v-el:someEl将转换为全小写。可以用v-el:some-el然后设置this.$el.someEl。<br>示例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span v-el:msg&gt;hello&lt;<span class=\"regexp\">/span&gt; </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;span v-el:other-msg&gt;world&lt;/</span>span&gt;  </span><br><span class=\"line\"><span class=\"keyword\">this</span>.$els.msg.textContent <span class=\"comment\">// -&gt;\"hello\"  </span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$els.otherMsg.textContent <span class=\"comment\">// -&gt;\"world\" </span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$els.msg <span class=\"comment\">//-&gt;&lt;span&gt;hello&lt;/span&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"Vue-js特点\"><a href=\"#Vue-js特点\" class=\"headerlink\" title=\"Vue.js特点\"></a>Vue.js特点</h3><p>  简洁：页面由HTML模板+Json数据+Vue实例组成<br>  数据驱动：自动计算属性和追踪依赖的模板表达式<br>  组件化：用可复用、解耦的组件来构造页面<br>  轻量：代码量小，不依赖其他库 快速：精确有效批量DOM更新<br>  模板友好：可通过npm，bower等多种方式安装，很容易融入</p>\n<p><br></p>\n<h3 id=\"JS中的常量（基本数据类型）和内置对象\"><a href=\"#JS中的常量（基本数据类型）和内置对象\" class=\"headerlink\" title=\"JS中的常量（基本数据类型）和内置对象\"></a>JS中的常量（基本数据类型）和内置对象</h3><p>  js中的基本数据类型：String 、number、null、boolean、undefined、object、symbol（ES6）</p>\n<ul>\n<li>1、 利用typeof运算符时其中只有null是异常的，typeof（null）=object，所以在判断变量类型是否为null时要注意。同时利用typeof时对于没有声明的变量是不会报错的，返回值为undefined。全局变量和函数变量在没有声明时使用是会报错的，但是在对象中使用没有定义的属性是不会报错同样返回的是undefined。Function变量是具有length属性的，其长度为传入的参数的个数。</li>\n<li>2、 变量时弱类型的，即其本身是没有类型的，其值才是具有类型的。</li>\n<li>3、 对于number类型，<br>（1）其中要注意的是NAN非数字的数字，用全局的函数isNAN判断时会有问题，即对于非数字类型的变量其也会返回true，所以在使用时可以用以下方式判断NAN：<br>①a!=a<br>②利用ES6中的Number.isNAN;<br>③typeof(a)==’number’&amp;&amp;isNAN(a)<br>（2）还有一个要注意的是+0，-0这两者在使用时是相等的但是在浏览器引擎上还是会有区别，区分二者可以利用：typeof(a)==typeof(b)&amp;&amp;1/a==1/b，+0、-0作为分母时会得到infinite和-infinite。在ES6中有Object.is方法可用于判断两个变量是否相等。可用于上述情况。但是前者的方法的执行效率更好。<br>（3）另外在JS中数字类型也是有最大和最小值的界定的安全范围的<br>（4）判断变量是否为整数的方法：<br>①Number.isInteger(a)，ES6中的方法<br>②typeof（a）==’number’&amp;&amp;a%1==0<br>③或者使用Math.ceil(a)==a等类似的方法</li>\n<li>4、变量在复制和作为参数传递时会有引用传递和值传递之分：<br>（1）值传递即普通的变量类型<br>（2）引用传递，如对象和数组等幅值或者作为参数传递传递的是复制的引用会相会影响：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">Var b=a;</span><br><span class=\"line\">b.push(<span class=\"number\">4</span>);<span class=\"comment\">//a=[1,2,3,4];b=[1,2,3,4]</span></span><br><span class=\"line\">但是当b重新赋值时：</span><br><span class=\"line\">Var b=[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]<span class=\"comment\">//a=[1,2,3,4];b=[4,5,6]因为b的引用已经发生了改变不在是a数组的引用的复制。</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JS中的内置函数: String、Number、Boolean、RegExp、Date、Error、Array、<br>Function、Object、symbol;类似于对象的构造函数</p>\n<ul>\n<li>1、这些内置函数构造的变量都是封装了基本类型值的对象如：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var a=<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(‘abb’); <span class=\"comment\">//typeof(a)=object</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>除了利用Function构造的变量通过typeof输出为function外其他均为object</p>\n<ul>\n<li>2、为了知道构造的变量的真实类型可以利用：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);<span class=\"comment\">//”[object,array]”</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>后面的一个值即为传入参数的类型</p>\n<ul>\n<li>3、如果有常量形式（即利用基本数据类型）赋值给变量就不要用该方式来定义变量</li>\n</ul>\n<p><br></p>\n<h3 id=\"js中判断一个对象的类型的种种方法\"><a href=\"#js中判断一个对象的类型的种种方法\" class=\"headerlink\" title=\"js中判断一个对象的类型的种种方法\"></a>js中判断一个对象的类型的种种方法</h3><h4 id=\"javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。\"><a href=\"#javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。\" class=\"headerlink\" title=\"javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。\"></a>javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。</h4><ul>\n<li><p>typeof：typeof是一个一元运算符，返回结果是一个说明运算数类型的字符串。如：”number”，”string”，”boolean”，”object”，”function”，”undefined”（可用于判断变量是否存在）。 但 typeof 的能力有限，其对于Date、RegExp、Array类型返回的都是”object”。所以它只在区别对象和原始类型的时候才有用。要区一种对象类型和另一种对象类型，必须使用其他的方法。</p>\n</li>\n<li><p>instanceof 运算符：instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。instanceof方法可以判断变量是否是数组类型，但是只限同一全局环境之内，在一个页面有多个iframe的情况下，instanceof失效。</p>\n</li>\n<li><p>constructor 属性: JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。如给定一个求知的值 通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。</p>\n</li>\n<li><p>Object.prototype.toString.call()：该方法是目前为止发现的判断一个对象类型的最好的办法。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"事件冒泡与事件捕获\"><a href=\"#事件冒泡与事件捕获\" class=\"headerlink\" title=\"事件冒泡与事件捕获\"></a>事件冒泡与事件捕获</h3><h4 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h4><p>微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象，由内向外。</p>\n<h3 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h3><p>网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素，由外向内。</p>\n<p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.addEventListener(event, <span class=\"function\"><span class=\"keyword\">function</span>, <span class=\"title\">useCapture</span>)</span></span><br></pre></td></tr></table></figure></p>\n<p>第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。</p>\n<p>对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。</p>\n<h5 id=\"IE浏览器\"><a href=\"#IE浏览器\" class=\"headerlink\" title=\"IE浏览器\"></a>IE浏览器</h5><p>IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.attachEvent(<span class=\"string\">\"onclick\"</span>, doSomething2);</span><br></pre></td></tr></table></figure></p>\n<p>附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。</p>\n<h4 id=\"事件的传播是可以阻止的：\"><a href=\"#事件的传播是可以阻止的：\" class=\"headerlink\" title=\"事件的传播是可以阻止的：\"></a>事件的传播是可以阻止的：</h4><p>• 在W3c中，使用stopPropagation（）方法<br>• 在IE下设置cancelBubble = true；<br>在捕获的过程中stopPropagation（）；后，后面的冒泡过程也不会发生了~<br>3.阻止事件的默认行为，例如click a 后的跳转~<br>• 在W3c中，使用preventDefault（）方法；<br>• 在IE下设置window.event.returnValue = false;</p>\n<p><br></p>\n<h3 id=\"浏览器的重绘与重排\"><a href=\"#浏览器的重绘与重排\" class=\"headerlink\" title=\"浏览器的重绘与重排\"></a>浏览器的重绘与重排</h3><p>1.重排的概念<br>浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM树和渲染树），DOM树表示页面结构，渲染树表示DOM节点如何显示。重排是DOM元素的几何属性变化，DOM树的结构变化，渲染树需要重新计算。</p>\n<p>2.重绘的概念<br>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p>\n<p>3.重绘和重排的关系<br>重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。</p>\n<p>4.什么情况下会触发重排？<br>(1)页面渲染初始化时；（这个无法避免）<br>(2)浏览器窗口改变尺寸；<br>(3)元素尺寸改变时；<br>(4)元素位置改变时；<br>(5)元素内容改变时；<br>(6)添加或删除可见的DOM 元素时。</p>\n<p>6.无论是外链CSS还是内联CSS都会阻塞DOM渲染（Rendering），然而DOM解析（Parsing）会正常进行。 这意味着在CSS下载并解析结束之前，它后面的HTML都不会显示。 这也是为什么我们把样式放在HTML内容之前，以防止被呈现内容发生样式跳动。 当然代价就是显示延迟，所以性能攸关的站点都会内联所有CSS。</p>\n<p><br></p>\n<h3 id=\"extend-obj-fn-extend-obj\"><a href=\"#extend-obj-fn-extend-obj\" class=\"headerlink\" title=\"$.extend(obj);$.fn.extend(obj);\"></a>$.extend(obj);$.fn.extend(obj);</h3><p>$拓展的方法是静态方法，可以使用$直接调用，其拓展的方式有两种，一般使用$.extend({});而$.fn拓展的方法是实例方法，必须由“对象”$(“”)来调用，其拓展的方式同样有两种，一般使用$.fn.extend({ })。</p>\n<p>$.extend(obj);是为了扩展jquery本身，为类添加新的方法</p>\n<p>$.fn.extend(obj);给JQUERY对象添加方法。</p>\n<p>$.fn 中的fn其实是prototype，即$.fn=$.prototype;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.extend(&#123;</span><br><span class=\"line\">add:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$.add(<span class=\"number\">5</span>,<span class=\"number\">8</span>) <span class=\"comment\">//return 13</span></span><br></pre></td></tr></table></figure>\n<p>这边的调用直接调用，前面不用任何对象。直接$.+方法名</p>\n<p>$.fn.extend(obj)；对prototype进行扩展，为jquery类添加成员函数， jquery类的实例可以使用这个成员函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.fn.extend(&#123;</span><br><span class=\"line\">clickwhile:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  $(<span class=\"keyword\">this</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert($(<span class=\"keyword\">this</span>).val()) </span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(<span class=\"string\">'input'</span>).clickwhile();<span class=\"comment\">//当点击输入框会弹出该对象的Value值</span></span><br></pre></td></tr></table></figure>\n<p>注意调用时候前面是有对象的。即$(‘input’) 这么个东西。</p>\n<p><br></p>\n<h3 id=\"CSS-hack区分IE6-IE7-IE8-firefox\"><a href=\"#CSS-hack区分IE6-IE7-IE8-firefox\" class=\"headerlink\" title=\"CSS hack区分IE6,IE7,IE8,firefox\"></a>CSS hack区分IE6,IE7,IE8,firefox</h3><h4 id=\"CSS-hack使用原理\"><a href=\"#CSS-hack使用原理\" class=\"headerlink\" title=\"CSS hack使用原理\"></a>CSS hack使用原理</h4><p>简单来讲，CSS hack就是浏览器解析CSS时的漏洞，因此不同的浏览器就有不同的CSS hack写法。 CSS hack使用原则: 尽力避免使用CSS hack，并寻找其它的应对方法。事实上，使用IE的条件注释来区分IE各个版本，是非常不错的选择。</p>\n<h4 id=\"CSS-hack使用后的弊端\"><a href=\"#CSS-hack使用后的弊端\" class=\"headerlink\" title=\"CSS hack使用后的弊端\"></a>CSS hack使用后的弊端</h4><p>CSS Hack除了能迅速区分浏览器版本，并可能获得大概一直的效果，但从长远看，CSS Hack会引起许多新的错误。</p>\n<h4 id=\"CSS-hack的实现方式-针对IE6\"><a href=\"#CSS-hack的实现方式-针对IE6\" class=\"headerlink\" title=\"CSS hack的实现方式(针对IE6)\"></a>CSS hack的实现方式(针对IE6)</h4><ul>\n<li>1.利用浏览器对相同代码的解析和支持的不同实现的hack<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#test&#123;</span><br><span class=\"line\">   _width:<span class=\"number\">80</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在IE7及以上版本的浏览器中会被当作错误特性而舍弃，但是在IE6中可以被正常的解析。这时候，可以把_width当作hack，专门针对IE6来设置元素的宽度。</p>\n<ul>\n<li>2.利用IE对标准的支持缺陷写的CSS hack<br>!important只有IE7及以上版本的IE及其他浏览器支持，所以，可以用!important来针对IE6以外的浏览器写CSS代码；再如，head:first-child+bodyselector，:first-child不被IE6支持，所以可以用来针对IE6以外的浏览器编写CSS代码。IE6支持下划线，IE7和firefox均不支持下划线。</li>\n</ul>\n<blockquote>\n<p>CSS hack区别IE6与Firefox：<br>background:orange;*background:blue;</p>\n</blockquote>\n<blockquote>\n<p>CSS hack区别IE6与IE7：<br>background:green !important;background:blue;</p>\n</blockquote>\n<blockquote>\n<p>CSS hack区别IE7与Firefox：<br>background:orange; *background:green;</p>\n</blockquote>\n<blockquote>\n<p>CSS hack区别Firefox，IE7，IE6：<br>background:orange;<em>background:green !important;</em>background:blue;</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"如何避免FOUC？\"><a href=\"#如何避免FOUC？\" class=\"headerlink\" title=\"如何避免FOUC？\"></a>如何避免FOUC？</h3><p>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.原因大致为：</p>\n<p>1，使用import方法导入样式表。<br>2，将样式表放在页面底部<br>3，有几个样式表，放在html结构的不同位置。其实原理很清楚：当样式表晚于 结构性html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂 的 花屏现象。解决方法：使用LINK标签将样式表放在文档HEAD中更多</p>\n<p><br></p>\n<h3 id=\"DOM-中-Property-和-Attribute-的区别\"><a href=\"#DOM-中-Property-和-Attribute-的区别\" class=\"headerlink\" title=\"DOM 中 Property 和 Attribute 的区别\"></a>DOM 中 Property 和 Attribute 的区别</h3><ul>\n<li><p>Property：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型直接继承自Element并添加了一些属性，添加的这些属性分别对应于每个HTML元素都有下面的这5个标准特性: id,title,lang,dir,className。DOM节点是一个对象，因此，他可以和其他的JavaScript对象一样添加自定义的属性以及方法。property的值可以是任何的数据类型，对大小写敏感，自定义的property不会出现在html代码中，只存在js中。</p>\n</li>\n<li><p>Attribute：特性，区别于property，attribute只能是字符串，大小写不敏感，出现在innerHTML中，通过类数组attributes可以罗列所有的attribute。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"document-onload和document-ready两个事件的区别\"><a href=\"#document-onload和document-ready两个事件的区别\" class=\"headerlink\" title=\"document.onload和document.ready两个事件的区别\"></a>document.onload和document.ready两个事件的区别</h3><ul>\n<li>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）</li>\n<li>onload，指示页面包含图片等文件在内的所有元素都加载完成。</li>\n</ul>\n<p><br></p>\n<h3 id=\"JavaScript的同源策略\"><a href=\"#JavaScript的同源策略\" class=\"headerlink\" title=\"JavaScript的同源策略\"></a>JavaScript的同源策略</h3><p>在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>\n<p><br></p>\n<h3 id=\"给选择器一个上下文\"><a href=\"#给选择器一个上下文\" class=\"headerlink\" title=\"给选择器一个上下文\"></a>给选择器一个上下文</h3><p>jQuery选择器中有一个这样的选择器，它能指定上下文。jQuery(expression,context);通过它，能缩小选择器在DOM中搜索的范围，达到节省时间，提高效率。普通方式：$(‘.myDiv’)改进方式：$(‘.myDiv’,$(“#listItem”))。</p>\n<p><br></p>\n<h3 id=\"请解释JSONP的工作原理，以及它为什么不是真正的AJAX\"><a href=\"#请解释JSONP的工作原理，以及它为什么不是真正的AJAX\" class=\"headerlink\" title=\"请解释JSONP的工作原理，以及它为什么不是真正的AJAX\"></a>请解释JSONP的工作原理，以及它为什么不是真正的AJAX</h3><p>JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>\n<p>AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！</p>\n<p><br></p>\n<h3 id=\"浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别\"><a href=\"#浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别\" class=\"headerlink\" title=\"浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别\"></a>浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别</h3><p>特性检测：为特定浏览器的特性进行测试，并仅当特性存在时即可应用特性。</p>\n<p>User-Agent检测：最早的浏览器嗅探即用户代理检测，服务端（以及后来的客户端）根据UA字符串屏蔽某些特定的浏览器查看网站内容。</p>\n<p>特性推断：尝试使用多个特性但仅验证了其中之一。根据一个特性的存在推断另一个特性是否存在。问题是，推断是假设并非事实，而且可能导致可维护性的问题</p>\n<p><br></p>\n<h3 id=\"JavaScript宿主对象和原生对象的区别\"><a href=\"#JavaScript宿主对象和原生对象的区别\" class=\"headerlink\" title=\"JavaScript宿主对象和原生对象的区别\"></a>JavaScript宿主对象和原生对象的区别</h3><h4 id=\"原生对象\"><a href=\"#原生对象\" class=\"headerlink\" title=\"原生对象\"></a>原生对象</h4><p>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>\n<p>“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。</p>\n<p>由此可以看出，简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。</p>\n<h4 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h4><p>ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。</p>\n<p>同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。如此就可以理解了。内置对象是本地对象的一种。</p>\n<h4 id=\"宿主对象\"><a href=\"#宿主对象\" class=\"headerlink\" title=\"宿主对象\"></a>宿主对象</h4><p>何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。</p>\n<p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的BOM和DOM都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。</p>\n<p><br></p>\n<h3 id=\"AMD、CMD和CommonJS规范\"><a href=\"#AMD、CMD和CommonJS规范\" class=\"headerlink\" title=\"AMD、CMD和CommonJS规范\"></a>AMD、CMD和CommonJS规范</h3><h4 id=\"CommonJS规范\"><a href=\"#CommonJS规范\" class=\"headerlink\" title=\"CommonJS规范\"></a>CommonJS规范</h4><p> CommonJS是在浏览器环境之外构建JavaScript生态系统为目标产生的项目，比如服务器和桌面环境中。CommonJS规范是为了解决JavaScript的作用域问题而定义的模块形式，<br>可以使每个模块在它自身的命名空间中执行。该规范的主要内容是：模块必须通过  module.exports导出对外的变量或接口，通过require()来导入其他模块的输出到当前模块。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// moduleA.js  </span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> value </span>)</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// moduleB.js  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> multiplyBy2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./moduleA'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">var</span> result = multiplyBy2(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>CommonJS是同步加载模块，但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过id进行索引，这样就可以浏览器进行解析了</p>\n<p>服务器端的Node.js遵循CommonJS规范。核心思想是允许模块通过require 方法来同步加载所要依赖的其他模块，然后通过 exports或module.exports来导出需要暴露的接口。</p>\n<p>优点：<br>服务器端便于重用<br>NPM中已经将近20w个模块包<br>简单并容易使用<br>缺点：<br>同步的模块方式不适合不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的<br>不能非阻塞的并行加载多个模块</p>\n<h4 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h4><p>AMD规范其实只有一个主要接口 define(id,dependencies,factory)，它要在声明模块的时候指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">\"module\"</span>, [<span class=\"string\">\"dep1\"</span>, <span class=\"string\">\"dep2\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d1, d2</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> someExportedValue;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"module\"</span>, <span class=\"string\">\"../file\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, file</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;);  \\</span><br></pre></td></tr></table></figure>\n<p>优点：<br>适合在浏览器环境异步加载<br>并行加载多个模块<br>缺点：<br>提高开发成本，代码阅读和书写比较困难<br>不符合通用的模块思维方式，是一种妥协的实现</p>\n<h4 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h4><p>CMD规范和AMD相似，尽量保持简单，并且与CommonJS和NodeJS的Modules规范保持了很大的兼容性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery'</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> Spinning = <span class=\"built_in\">require</span>(<span class=\"string\">'./spinning'</span>);  </span><br><span class=\"line\">  exports.doSomething = ...  </span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = ...  </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>优点：<br>依赖就近，延迟执行<br>很容易在node中运行<br>缺点：<br>依赖SPM打包，模块的加载逻辑偏重</p>\n<p><br></p>\n<h3 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h3><p>JavaScript事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个父级元素上，这样就避免了把事件处理器添加到多个子级元素上。当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。事件代理用到了两个在JavaSciprt事件中常被忽略的特性：事件冒泡以及目标元素。</p>\n<p><br></p>\n<h3 id=\"如果设计中使用了非标准的字体，如何去实现\"><a href=\"#如果设计中使用了非标准的字体，如何去实现\" class=\"headerlink\" title=\"如果设计中使用了非标准的字体，如何去实现\"></a>如果设计中使用了非标准的字体，如何去实现</h3><p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。<br>方法：</p>\n<ul>\n<li>用图片代替</li>\n<li>web fonts在线字库，如Google Webfonts，Typekit等等；<a href=\"http://www.chinaz.com/free/2012/0815/269267.shtml；\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/free/2012/0815/269267.shtml；</a></li>\n<li>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)</li>\n</ul>\n<p><br></p>\n<h3 id=\"使用CSS预处理器的优缺点\"><a href=\"#使用CSS预处理器的优缺点\" class=\"headerlink\" title=\"使用CSS预处理器的优缺点\"></a>使用CSS预处理器的优缺点</h3><p>LESS&amp;SassLESS是受Sass启发而开发的工具，它列出了如下开发的理由：</p>\n<p>“为什么要开发一个Sass的替代品呢？原因很简单：首先是语法。Sass的一个关键特性是缩进式的语法，这种语法可以产生柱式外观的代码。但是你需要花费时间学习一门新的语法以及重新构建你现在的样式表。LESS给CSS带来了很多特性，使得LESS能够和CSS无缝地紧密结合在一起。因此，你可以平滑地由CSS迁移到LESS，如果你只是对使用变量或者操作感兴趣的话，你不需要学习一整门全新的语言。”</p>\n<p>Stylus相对前两者较新，可以看官方文档介绍的功能。</p>\n<p>1.来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：<a href=\"http://learnboost.github.io/stylus/docs/js.html；\" target=\"_blank\" rel=\"noopener\">http://learnboost.github.io/stylus/docs/js.html；</a><br>2.支持Ruby之类等等框架；<br>3.更多更强大的支持和功能总结：Sass看起来在提供的特性上占有优势，但是LESS能够让开发者平滑地从现存CSS文件过渡到LESS，而不需要像Sass那样需要将CSS文件转换成Sass格式。Stylus功能上更为强壮，和js联系更加紧密。</p>\n<p><br></p>\n<h3 id=\"cookies，sessionStorage和localStorage的区别\"><a href=\"#cookies，sessionStorage和localStorage的区别\" class=\"headerlink\" title=\"cookies，sessionStorage和localStorage的区别\"></a>cookies，sessionStorage和localStorage的区别</h3><p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>\n<p>存储大小：<br>  cookie数据大小不能超过4k。<br>  sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>\n<p>有期时间：<br>  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>  sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>\n<p><br></p>\n<h3 id=\"浏览器标准模式和怪异模式之间的区别\"><a href=\"#浏览器标准模式和怪异模式之间的区别\" class=\"headerlink\" title=\"浏览器标准模式和怪异模式之间的区别\"></a>浏览器标准模式和怪异模式之间的区别</h3><p>W3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。这样浏览器渲染上就产生了Quircks mode和Standars mode，两种渲染方法共存在一个浏览器上。IE盒子模型和标准W3C盒子模型：ie的width包括：padding\\border。标准的width不包括：padding\\border</p>\n<p> 在js中如何判断当前浏览器正在以何种方式解析？<br>         document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。</p>\n<p><br></p>\n<h3 id=\"doctype（文档类型）的作用，有多少种文档类型\"><a href=\"#doctype（文档类型）的作用，有多少种文档类型\" class=\"headerlink\" title=\"doctype（文档类型）的作用，有多少种文档类型\"></a>doctype（文档类型）的作用，有多少种文档类型</h3><p>此标签可告知浏览器文档使用哪种HTML或XHTML规范。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。</p>\n<p>HTML 4.01规定了三种文档类型：Strict、Transitional以及Frameset。</p>\n<p>XHTML 1.0规定了三种XML文档类型：Strict、Transitional以及Frameset。</p>\n<p>Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>\n<p><br></p>\n<h3 id=\"对语义化的理解\"><a href=\"#对语义化的理解\" class=\"headerlink\" title=\"对语义化的理解\"></a>对语义化的理解</h3><p>1：去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如 h1 是粗体，字体大小2em，加粗；strong 是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</p>\n<p>2.屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页。</p>\n<p>3.PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）。</p>\n<p>4.有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。</p>\n<p>5.便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>\n<p><br></p>\n<h3 id=\"渐进增强和优雅降级\"><a href=\"#渐进增强和优雅降级\" class=\"headerlink\" title=\"渐进增强和优雅降级\"></a>渐进增强和优雅降级</h3><p>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p>\n<p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>\n<p><br></p>\n<h3 id=\"浏览器同一时间可以从一个域名下载多少资源\"><a href=\"#浏览器同一时间可以从一个域名下载多少资源\" class=\"headerlink\" title=\"浏览器同一时间可以从一个域名下载多少资源\"></a>浏览器同一时间可以从一个域名下载多少资源</h3><p>这个专业的说法叫“浏览器并发请求数”。意即，同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻止。所有浏览器的并发数目一般限制在10以内。</p>\n<p> <img src=\"https://pic4.zhimg.com/ea606d016e8ab77db9d8a8dfa5243a1b_r.jpg\" width=\"200\" height=\"200\"></p>\n<p><br></p>\n<h3 id=\"Canvas-与-SVG\"><a href=\"#Canvas-与-SVG\" class=\"headerlink\" title=\"Canvas 与 SVG\"></a>Canvas 与 SVG</h3><h4 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h4><ul>\n<li>依赖分辨率</li>\n<li>不支持事件处理器</li>\n<li>弱的文本渲染能力</li>\n<li>能够以 .png 或 .jpg 格式保存结果图像</li>\n<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘<h3 id=\"SVG\"><a href=\"#SVG\" class=\"headerlink\" title=\"SVG\"></a>SVG</h3></li>\n<li>不依赖分辨率</li>\n<li>支持事件处理器</li>\n<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>\n<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>\n<li>不适合游戏应用</li>\n</ul>\n<p><br></p>\n<h3 id=\"页面导入样式时，使用link和-import有什么区别\"><a href=\"#页面导入样式时，使用link和-import有什么区别\" class=\"headerlink\" title=\"页面导入样式时，使用link和@import有什么区别\"></a>页面导入样式时，使用link和@import有什么区别</h3><p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</p>\n<p>（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>\n<p>（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问</p>\n<p><br></p>\n<h3 id=\"介绍一下你对浏览器内核的理解\"><a href=\"#介绍一下你对浏览器内核的理解\" class=\"headerlink\" title=\"介绍一下你对浏览器内核的理解\"></a>介绍一下你对浏览器内核的理解</h3><p>  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>\n<p>  JS引擎则：解析和执行javascript来实现网页的动态效果。</p>\n<p>  最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>\n<p><br></p>\n<h3 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h3><p>  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br>  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p>\n<p><br></p>\n<h3 id=\"html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和\"><a href=\"#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和\" class=\"headerlink\" title=\"html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和\"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和</h3><p>HTML5？</p>\n<ul>\n<li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>\n<pre><code>绘画 canvas;\n用于媒介回放的 video 和 audio 元素;\n本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\nsessionStorage 的数据在浏览器关闭后自动删除;\n语意化更好的内容元素，比如 article、footer、header、nav、section;\n表单控件，calendar、date、time、email、url、search;\n新的技术webworker, websocket, Geolocation;\n</code></pre><p>   移除的元素：</p>\n<pre><code>纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n对可用性产生负面影响的元素：frame，frameset，noframes；\n</code></pre><ul>\n<li><p>支持HTML5新标签：<br>   IE8/IE7/IE6支持通过document.createElement方法产生的标签，</p>\n<pre><code>可以利用这一特性让这些浏览器支持HTML5新标签，\n浏览器支持新标签后，还需要添加标签默认的样式。\n</code></pre><p>   当然也可以直接使用成熟的框架、比如html5shim;</p>\n</li>\n<li><p>如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"HTML5的离线储存怎么使用\"><a href=\"#HTML5的离线储存怎么使用\" class=\"headerlink\" title=\"HTML5的离线储存怎么使用\"></a>HTML5的离线储存怎么使用</h3><p>  在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>\n<p><br></p>\n<h3 id=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"><a href=\"#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\" class=\"headerlink\" title=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h3><p>  在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>  离线的情况下，浏览器就直接使用离线存储的资源。</p>\n<p><br></p>\n<h3 id=\"iframe有那些缺点？\"><a href=\"#iframe有那些缺点？\" class=\"headerlink\" title=\"iframe有那些缺点？\"></a>iframe有那些缺点？</h3><ul>\n<li>iframe会阻塞主页面的Onload事件；</li>\n<li><p>搜索引擎的检索程序无法解读这种页面，不利于SEO;</p>\n</li>\n<li><p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p>\n<p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript<br>动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"Label的作用是什么？是怎么用的\"><a href=\"#Label的作用是什么？是怎么用的\" class=\"headerlink\" title=\"Label的作用是什么？是怎么用的?\"></a>Label的作用是什么？是怎么用的?</h3><p> label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"Name\"</span>&gt;<span class=\"built_in\">Number</span>:&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=“text“name=<span class=\"string\">\"Name\"</span> id=<span class=\"string\">\"Name\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;label&gt;<span class=\"built_in\">Date</span>:&lt;input type=\"text\" name=\"B\"/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"HTML5的form如何关闭自动完成功能？\"><a href=\"#HTML5的form如何关闭自动完成功能？\" class=\"headerlink\" title=\"HTML5的form如何关闭自动完成功能？\"></a>HTML5的form如何关闭自动完成功能？</h3><p>  给不想要提示的 form 或某个 input 设置为 autocomplete=off。</p>\n<p><br></p>\n<h3 id=\"如何实现浏览器内多个标签页之间的通信\"><a href=\"#如何实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"如何实现浏览器内多个标签页之间的通信?\"></a>如何实现浏览器内多个标签页之间的通信?</h3><p>  WebSocket、SharedWorker；<br>  也可以调用localstorge、cookies等本地存储方式；</p>\n<p>  localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，<br>  我们通过监听事件，控制它的值来进行页面信息通信；<br>  注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</p>\n<p><br></p>\n<h3 id=\"webSocket如何兼容低浏览器？\"><a href=\"#webSocket如何兼容低浏览器？\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器？\"></a>webSocket如何兼容低浏览器？</h3><ul>\n<li>Adobe Flash Socket 、</li>\n<li>ActiveX HTMLFile (IE) 、</li>\n<li>基于 multipart 编码发送 XHR 、</li>\n<li>基于长轮询的 XHR</li>\n</ul>\n<p><br></p>\n<h3 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途？\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途？\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途？\"></a>页面可见性（Page Visibility API） 可以有哪些用途？</h3><p>  通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;<br>  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</p>\n<p><br></p>\n<h3 id=\"实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\"><a href=\"#实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\" class=\"headerlink\" title=\"实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\"></a>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=<span class=\"string\">\"height:1px;overflow:hidden;background:red\"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\"><a href=\"#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\" class=\"headerlink\" title=\"介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3><p>  （1）有两种， IE 盒子模型、W3C 盒子模型；<br>  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>  （3）区  别： IE的content部分把 border 和 padding计算了进去;</p>\n<p><br></p>\n<h3 id=\"CSS优先级算法如何计算？\"><a href=\"#CSS优先级算法如何计算？\" class=\"headerlink\" title=\"CSS优先级算法如何计算？\"></a>CSS优先级算法如何计算？</h3><ul>\n<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>\n<li><p>载入样式以最后载入的定位为准;</p>\n<p>优先级为:<br>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。<br>!important &gt;  id &gt; class &gt; tag<br>important 比 内联优先级高</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"CSS3新增伪类有那些？\"><a href=\"#CSS3新增伪类有那些？\" class=\"headerlink\" title=\"CSS3新增伪类有那些？\"></a>CSS3新增伪类有那些？</h3><pre><code>举例：\np:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\np:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\np:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\np:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。\np:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。\n\n:after            在元素之前添加内容,也可以用来做清除浮动。\n:before            在元素之后添加内容\n :enabled          \n:disabled         控制表单控件的禁用状态。\n:checked        单选框或复选框被选中。\n</code></pre><p><br></p>\n<h3 id=\"CSS3有哪些新特性？\"><a href=\"#CSS3有哪些新特性？\" class=\"headerlink\" title=\"CSS3有哪些新特性？\"></a>CSS3有哪些新特性？</h3><p> 新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）<br>      圆角            （border-radius:8px）<br>    多列布局        （multi-column layout）<br>    阴影和反射    （Shadow\\Reflect）<br>    文字特效        （text-shadow、）<br>    文字渲染        （Text-decoration）<br>    线性渐变        （gradient）<br>    旋转             （transform）<br>    缩放,定位,倾斜,动画,多背景<br>    例如:transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:</p>\n<p><br></p>\n<h3 id=\"请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景\"><a href=\"#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景\" class=\"headerlink\" title=\"请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景\"></a>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景</h3><p>  一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。<br>   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。<br>   采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。<br>   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。<br>   在布局上有了比以前更加灵活的空间。</p>\n<p><br></p>\n<h3 id=\"li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\"><a href=\"#li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\" class=\"headerlink\" title=\"li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\"></a>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p> 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p>\n<p><br></p>\n<h3 id=\"对BFC规范-块级格式化上下文：block-formatting-context-的理解？\"><a href=\"#对BFC规范-块级格式化上下文：block-formatting-context-的理解？\" class=\"headerlink\" title=\"对BFC规范(块级格式化上下文：block formatting context)的理解？\"></a>对BFC规范(块级格式化上下文：block formatting context)的理解？</h3><p>（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）<br>   一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。<br>   不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</p>\n<p><br></p>\n<h3 id=\"before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用\"><a href=\"#before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用\" class=\"headerlink\" title=\"::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用\"></a>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用</h3><p>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）<br>  双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，<br>  比如:first-line、:first-letter、:before、:after等，<br>  而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</p>\n<p>  想让插入的内容出现在其它内容前，使用::before，否者，使用::after；<br>  在代码顺序上，::after生成的内容也比::before生成的内容靠后。<br>  如果按堆栈视角，::after生成的内容会在::before生成的内容之上</p>\n<p><br></p>\n<h3 id=\"让页面里的字体变清晰，变细用CSS怎么做？\"><a href=\"#让页面里的字体变清晰，变细用CSS怎么做？\" class=\"headerlink\" title=\"让页面里的字体变清晰，变细用CSS怎么做？\"></a>让页面里的字体变清晰，变细用CSS怎么做？</h3><p>  -webkit-font-smoothing: antialiased;</p>\n<p><br></p>\n<h3 id=\"position-fixed-在android下无效怎么处理？\"><a href=\"#position-fixed-在android下无效怎么处理？\" class=\"headerlink\" title=\"position:fixed;在android下无效怎么处理？\"></a>position:fixed;在android下无效怎么处理？</h3><p>  fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，<br>  原来的网页还好好的在那，fixed的内容也没有变过位置，<br>  所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。<br>  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"></p>\n<p><br></p>\n<h3 id=\"如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"><a href=\"#如果需要手动写动画，你认为最小时间间隔是多久，为什么？\" class=\"headerlink\" title=\"如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</p>\n<p>display:inline-block 什么时候会显示间隙？</p>\n<p>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p>\n<p><br></p>\n<h3 id=\"什么是CSS-预处理器-后处理器？\"><a href=\"#什么是CSS-预处理器-后处理器？\" class=\"headerlink\" title=\"什么是CSS 预处理器 / 后处理器？\"></a>什么是CSS 预处理器 / 后处理器？</h3><ul>\n<li><p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，<br> 还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p>\n<ul>\n<li>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的<br>是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"JavaScript原型，原型链-有什么特点？\"><a href=\"#JavaScript原型，原型链-有什么特点？\" class=\"headerlink\" title=\"JavaScript原型，原型链 ? 有什么特点？\"></a>JavaScript原型，原型链 ? 有什么特点？</h3><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br> 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br> 于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br> 关系：instance.constructor.prototype = instance.<strong>proto</strong></p>\n<p> 特点：<br> JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>\n<p><br></p>\n<h3 id=\"如何将字符串转化为数字，例如’12-3b’\"><a href=\"#如何将字符串转化为数字，例如’12-3b’\" class=\"headerlink\" title=\"如何将字符串转化为数字，例如’12.3b’?\"></a>如何将字符串转化为数字，例如’12.3b’?</h3><ul>\n<li>parseFloat(‘12.3b’);</li>\n<li>正则表达式，’12.3b’.match(/(\\d)+(.)?(\\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</li>\n</ul>\n<p><br></p>\n<h3 id=\"如何实现数组的随机排序？\"><a href=\"#如何实现数组的随机排序？\" class=\"headerlink\" title=\"如何实现数组的随机排序？\"></a>如何实现数组的随机排序？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() - <span class=\"number\">0.5</span>;</span><br><span class=\"line\"> <span class=\"comment\">// return Math.random() ;   从大到小</span></span><br><span class=\"line\"> <span class=\"comment\">// return Math.random() - 1;  从小到大</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortNumber</span>(<span class=\"params\">a, b</span>)</span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> a - b</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"> arr = [<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">12</span>,<span class=\"number\">1100</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(arr.sort(sortNumber))  <span class=\"comment\">// 实现数组又大到小排序</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"Javascript如何实现继承？\"><a href=\"#Javascript如何实现继承？\" class=\"headerlink\" title=\"Javascript如何实现继承？\"></a>Javascript如何实现继承？</h3><p>1、构造继承<br> 2、原型继承<br> 3、实例继承<br> 4、拷贝继承</p>\n<p> 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'wang'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">28</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent();<span class=\"comment\">//继承了Parent，通过原型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> demo = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">alert(demo.age);</span><br><span class=\"line\">alert(demo.name);<span class=\"comment\">//得到被继承的属性</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"javascript创建对象的几种方式？\"><a href=\"#javascript创建对象的几种方式？\" class=\"headerlink\" title=\"javascript创建对象的几种方式？\"></a>javascript创建对象的几种方式？</h3><pre><code>1、对象字面量的方式\n2、用function来模拟无参的构造函数\n3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\n4 、用原型方式来创建\n</code></pre><p><br></p>\n<h3 id=\"Javascript作用链域\"><a href=\"#Javascript作用链域\" class=\"headerlink\" title=\"Javascript作用链域?\"></a>Javascript作用链域?</h3><p> 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。<br> 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，<br> 直至全局函数，这种组织形式就是作用域链。</p>\n<p><br></p>\n<h3 id=\"eval是做什么的？\"><a href=\"#eval是做什么的？\" class=\"headerlink\" title=\"eval是做什么的？\"></a>eval是做什么的？</h3><p>它的功能是把对应的字符串解析成JS代码并运行；<br> 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。<br> 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’);</p>\n<p>什么是window对象? 什么是document对象?</p>\n<p> window对象是指浏览器打开的窗口。<br> document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</p>\n<p><br></p>\n<h3 id=\"“1”-“2”-“3”-map-parseInt-答案是多少？\"><a href=\"#“1”-“2”-“3”-map-parseInt-答案是多少？\" class=\"headerlink\" title=\"[“1”, “2”, “3”].map(parseInt) 答案是多少？\"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><p> parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，<br> 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;<br> 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。</p>\n<p> function parseInt(str, radix) {<br>     return str+’-‘+radix;<br> };<br> var a=[“1”, “2”, “3”];<br> a.map(parseInt);  // [“1-0”, “2-1”, “3-2”] 不能大于radix</p>\n<p> 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN<br> 所以[“1”, “2”, “3”].map(parseInt) 答案也就是：[1, NaN, NaN]</p>\n<p><br></p>\n<h3 id=\"什么是闭包（closure），为什么要用它？\"><a href=\"#什么是闭包（closure），为什么要用它？\" class=\"headerlink\" title=\"什么是闭包（closure），为什么要用它？\"></a>什么是闭包（closure），为什么要用它？</h3><p>  闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</p>\n<p> 闭包的特性：</p>\n<p> 1.函数内再嵌套函数<br> 2.内部函数可以引用外层的参数和变量<br> 3.参数和变量不会被垃圾回收机制回收</p>\n<p><br></p>\n<h3 id=\"new操作符具体干了什么呢\"><a href=\"#new操作符具体干了什么呢\" class=\"headerlink\" title=\"new操作符具体干了什么呢?\"></a>new操作符具体干了什么呢?</h3><pre><code>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n2、属性和方法被加入到 this 引用的对象中。\n3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n</code></pre><p><br></p>\n<h3 id=\"js延迟加载的方式有哪些？\"><a href=\"#js延迟加载的方式有哪些？\" class=\"headerlink\" title=\"js延迟加载的方式有哪些？\"></a>js延迟加载的方式有哪些？</h3><p> defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p>\n<p><br></p>\n<h3 id=\"Ajax-是什么-如何创建一个Ajax？\"><a href=\"#Ajax-是什么-如何创建一个Ajax？\" class=\"headerlink\" title=\"Ajax 是什么? 如何创建一个Ajax？\"></a>Ajax 是什么? 如何创建一个Ajax？</h3><p>ajax的全称：Asynchronous Javascript And XML。<br> 异步传输+js+xml。<br> 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</p>\n<p> (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象<br> (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br> (3)设置响应HTTP请求状态变化的函数<br> (4)发送HTTP请求<br> (5)获取异步调用返回的数据<br> (6)使用JavaScript和DOM实现局部刷新</p>\n<p><br></p>\n<h3 id=\"如何判断当前脚本运行在浏览器还是node环境中？\"><a href=\"#如何判断当前脚本运行在浏览器还是node环境中？\" class=\"headerlink\" title=\"如何判断当前脚本运行在浏览器还是node环境中？\"></a>如何判断当前脚本运行在浏览器还是node环境中？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span> === <span class=\"built_in\">window</span> ? <span class=\"string\">'browser'</span> : <span class=\"string\">'node'</span>;</span><br></pre></td></tr></table></figure>\n<p>  通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</p>\n<p><br></p>\n<h3 id=\"那些操作会造成内存泄漏？\"><a href=\"#那些操作会造成内存泄漏？\" class=\"headerlink\" title=\"那些操作会造成内存泄漏？\"></a>那些操作会造成内存泄漏？</h3><p> 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br> 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>\n<p> setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br> 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>\n<p><br></p>\n<h3 id=\"检测浏览器版本版本有哪些方式？\"><a href=\"#检测浏览器版本版本有哪些方式？\" class=\"headerlink\" title=\"检测浏览器版本版本有哪些方式？\"></a>检测浏览器版本版本有哪些方式？</h3><p>  功能检测、userAgent特征检测</p>\n<p>  比如：navigator.userAgent</p>\n<p><br></p>\n<h3 id=\"Object-is-与原来的比较操作符“-”、“-”的区别？\"><a href=\"#Object-is-与原来的比较操作符“-”、“-”的区别？\" class=\"headerlink\" title=\"Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？\"></a>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</h3><p> 两等号判等，会在比较时进行类型转换；<br>  三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；</p>\n<p>  Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，<br>  但 Object.is(NaN, NaN) 会返回 true.</p>\n<p>   Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。<br>  前端框架相关</p>\n<p><br></p>\n<h3 id=\"是否了解公钥加密和私钥加密。\"><a href=\"#是否了解公钥加密和私钥加密。\" class=\"headerlink\" title=\"是否了解公钥加密和私钥加密。\"></a>是否了解公钥加密和私钥加密。</h3><p>  一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;<br>  HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</p>\n<p><br></p>\n<h3 id=\"对Node的优点和缺点提出了自己的看法？\"><a href=\"#对Node的优点和缺点提出了自己的看法？\" class=\"headerlink\" title=\"对Node的优点和缺点提出了自己的看法？\"></a>对Node的优点和缺点提出了自己的看法？</h3><pre><code>*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，\n  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。\n  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，\n  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。\n\n*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，\n  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。\n</code></pre><p><br></p>\n<h3 id=\"你有用过哪些前端性能优化的方法？\"><a href=\"#你有用过哪些前端性能优化的方法？\" class=\"headerlink\" title=\"你有用过哪些前端性能优化的方法？\"></a>你有用过哪些前端性能优化的方法？</h3><pre><code>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\n\n（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n\n（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\n\n（4） 当需要设置的样式很多时设置className而不是直接操作style。\n\n（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。\n\n（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。\n\n（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。\n\n（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。\n对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。\n</code></pre><p><br></p>\n<h3 id=\"http状态码有那些？分别代表是什么意思？\"><a href=\"#http状态码有那些？分别代表是什么意思？\" class=\"headerlink\" title=\"http状态码有那些？分别代表是什么意思？\"></a>http状态码有那些？分别代表是什么意思？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  [</span><br><span class=\"line\">      <span class=\"number\">100</span>  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class=\"line\">      <span class=\"number\">200</span>  OK         正常返回信息</span><br><span class=\"line\">      <span class=\"number\">201</span>  Created      请求成功并且服务器创建了新的资源</span><br><span class=\"line\">      <span class=\"number\">202</span>  Accepted     服务器已接受请求，但尚未处理</span><br><span class=\"line\">      <span class=\"number\">301</span>  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class=\"line\">      <span class=\"number\">302</span> Found          临时性重定向。</span><br><span class=\"line\">      <span class=\"number\">303</span> See Other      临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class=\"line\">      <span class=\"number\">304</span>  Not Modified 自从上次请求后，请求的网页未修改过。</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"number\">400</span> Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class=\"line\">      <span class=\"number\">401</span> Unauthorized 请求未授权。</span><br><span class=\"line\">      <span class=\"number\">403</span> Forbidden      禁止访问。</span><br><span class=\"line\">      <span class=\"number\">404</span> Not Found      找不到如何与 URI 相匹配的资源。</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"number\">500</span> Internal Server <span class=\"built_in\">Error</span>  最常见的服务器端错误。</span><br><span class=\"line\">      <span class=\"number\">503</span> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">完整版</span><br><span class=\"line\"><span class=\"number\">1</span>**(信息类)：表示接收到请求并且继续处理</span><br><span class=\"line\">  <span class=\"number\">100</span>——客户必须继续发出请求</span><br><span class=\"line\">  <span class=\"number\">101</span>——客户要求服务器根据请求转换HTTP协议版本</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>**(响应成功)：表示动作被成功接收、理解和接受</span><br><span class=\"line\">  <span class=\"number\">200</span>——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class=\"line\">  <span class=\"number\">201</span>——提示知道新文件的URL</span><br><span class=\"line\">  <span class=\"number\">202</span>——接受和处理、但处理未完成</span><br><span class=\"line\">  <span class=\"number\">203</span>——返回信息不确定或不完整</span><br><span class=\"line\">  <span class=\"number\">204</span>——请求收到，但返回信息为空</span><br><span class=\"line\">  <span class=\"number\">205</span>——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class=\"line\">  <span class=\"number\">206</span>——服务器已经完成了部分用户的GET请求</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>**(重定向类)：为了完成指定的动作，必须接受进一步处理</span><br><span class=\"line\">  <span class=\"number\">300</span>——请求的资源可在多处得到</span><br><span class=\"line\">  <span class=\"number\">301</span>——本网页被永久性转移到另一个URL</span><br><span class=\"line\">  <span class=\"number\">302</span>——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</span><br><span class=\"line\">  <span class=\"number\">303</span>——建议客户访问其他URL或访问方式</span><br><span class=\"line\">  <span class=\"number\">304</span>——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</span><br><span class=\"line\">  <span class=\"number\">305</span>——请求的资源必须从服务器指定的地址得到</span><br><span class=\"line\">  <span class=\"number\">306</span>——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class=\"line\">  <span class=\"number\">307</span>——申明请求的资源临时性删除</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>**(客户端错误类)：请求包含错误语法或不能正确执行</span><br><span class=\"line\">  <span class=\"number\">400</span>——客户端请求有语法错误，不能被服务器所理解</span><br><span class=\"line\">  <span class=\"number\">401</span>——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class=\"line\">  HTTP <span class=\"number\">401.1</span> - 未授权：登录失败</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.2</span> - 未授权：服务器配置问题导致登录失败</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.3</span> - ACL 禁止访问资源</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.4</span> - 未授权：授权被筛选器拒绝</span><br><span class=\"line\">  HTTP <span class=\"number\">401.5</span> - 未授权：ISAPI 或 CGI 授权失败</span><br><span class=\"line\">  <span class=\"number\">402</span>——保留有效ChargeTo头响应</span><br><span class=\"line\">  <span class=\"number\">403</span>——禁止访问，服务器收到请求，但是拒绝提供服务</span><br><span class=\"line\">  HTTP <span class=\"number\">403.1</span> 禁止访问：禁止可执行访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.2</span> - 禁止访问：禁止读访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.3</span> - 禁止访问：禁止写访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.4</span> - 禁止访问：要求 SSL</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.5</span> - 禁止访问：要求 SSL <span class=\"number\">128</span></span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.6</span> - 禁止访问：IP 地址被拒绝</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.7</span> - 禁止访问：要求客户证书</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.8</span> - 禁止访问：禁止站点访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.9</span> - 禁止访问：连接的用户过多</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.10</span> - 禁止访问：配置无效</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.11</span> - 禁止访问：密码更改</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.12</span> - 禁止访问：映射器拒绝访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.13</span> - 禁止访问：客户证书已被吊销</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.15</span> - 禁止访问：客户访问许可过多</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.16</span> - 禁止访问：客户证书不可信或者无效</span><br><span class=\"line\">  HTTP <span class=\"number\">403.17</span> - 禁止访问：客户证书已经到期或者尚未生效</span><br><span class=\"line\">  <span class=\"number\">404</span>——一个<span class=\"number\">404</span>错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</span><br><span class=\"line\">  <span class=\"number\">405</span>——用户在Request-Line字段定义的方法不允许</span><br><span class=\"line\">  <span class=\"number\">406</span>——根据用户发送的Accept拖，请求资源不可访问</span><br><span class=\"line\">  <span class=\"number\">407</span>——类似<span class=\"number\">401</span>，用户必须首先在代理服务器上得到授权</span><br><span class=\"line\">  <span class=\"number\">408</span>——客户端没有在用户指定的饿时间内完成请求</span><br><span class=\"line\">  <span class=\"number\">409</span>——对当前资源状态，请求不能完成</span><br><span class=\"line\">  <span class=\"number\">410</span>——服务器上不再有此资源且无进一步的参考地址</span><br><span class=\"line\">  <span class=\"number\">411</span>——服务器拒绝用户定义的Content-Length属性请求</span><br><span class=\"line\">  <span class=\"number\">412</span>——一个或多个请求头字段在当前请求中错误</span><br><span class=\"line\">  <span class=\"number\">413</span>——请求的资源大于服务器允许的大小</span><br><span class=\"line\">  <span class=\"number\">414</span>——请求的资源URL长于服务器允许的长度</span><br><span class=\"line\">  <span class=\"number\">415</span>——请求资源不支持请求项目格式</span><br><span class=\"line\">  <span class=\"number\">416</span>——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class=\"line\">  <span class=\"number\">417</span>——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5</span>**(服务端错误类)：服务器不能正确执行一个正确的请求</span><br><span class=\"line\">  HTTP <span class=\"number\">500</span> - 服务器遇到错误，无法完成请求</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500.100</span> - 内部服务器错误 - ASP 错误</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-11</span> 服务器关闭</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-12</span> 应用程序重新启动</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-13</span> - 服务器太忙</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-14</span> - 应用程序无效</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-15</span> - 不允许请求 global.asa</span><br><span class=\"line\">  　　<span class=\"built_in\">Error</span> <span class=\"number\">501</span> - 未实现</span><br><span class=\"line\">HTTP <span class=\"number\">502</span> - 网关错误</span><br><span class=\"line\">HTTP <span class=\"number\">503</span>：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\"><a href=\"#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\" class=\"headerlink\" title=\"一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">详细版：</span><br><span class=\"line\">  <span class=\"number\">1</span>、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</span><br><span class=\"line\">  <span class=\"number\">2</span>、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</span><br><span class=\"line\">  <span class=\"number\">3</span>、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</span><br><span class=\"line\">  <span class=\"number\">4</span>、进行HTTP协议会话，客户端发送报头(请求报头);</span><br><span class=\"line\">  <span class=\"number\">5</span>、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</span><br><span class=\"line\">  <span class=\"number\">6</span>、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</span><br><span class=\"line\">  <span class=\"number\">7</span>、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回<span class=\"number\">304</span>;</span><br><span class=\"line\">  <span class=\"number\">8</span>、浏览器开始下载html文档(响应报头，状态码<span class=\"number\">200</span>)，同时使用缓存;</span><br><span class=\"line\">  <span class=\"number\">9</span>、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</span><br><span class=\"line\">  <span class=\"number\">10</span>、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</span><br><span class=\"line\"></span><br><span class=\"line\">简洁版：</span><br><span class=\"line\">  浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</span><br><span class=\"line\">  服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</span><br><span class=\"line\">  浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</span><br><span class=\"line\">  载入解析到的资源文件，渲染页面，完成。</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"移动端（Android-IOS）怎么做好用户体验\"><a href=\"#移动端（Android-IOS）怎么做好用户体验\" class=\"headerlink\" title=\"移动端（Android IOS）怎么做好用户体验?\"></a>移动端（Android IOS）怎么做好用户体验?</h3><p>  清晰的视觉纵线、<br>  信息的分组、极致的减法、<br>  利用选择代替输入、<br>  标签及文字的排布方式、<br>  依靠明文确认密码、<br>  合理的键盘利用、</p>\n<h3 id=\"TCP传输的三次握手四次挥手策略\"><a href=\"#TCP传输的三次握手四次挥手策略\" class=\"headerlink\" title=\"TCP传输的三次握手四次挥手策略\"></a>TCP传输的三次握手四次挥手策略</h3><p>第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。</p>\n<p>第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。</p>\n<p>第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。</p>\n<ul>\n<li><p>为什么要三次握手：<br>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源<br>TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！</p>\n</li>\n<li><p>四次挥手</p>\n</li>\n</ul>\n<p>1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段；<br>2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段；<br>3、服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接；<br>4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；</p>\n<h3 id=\"TCP和UDP的区别\"><a href=\"#TCP和UDP的区别\" class=\"headerlink\" title=\"TCP和UDP的区别\"></a>TCP和UDP的区别</h3><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来</p>\n<p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>\n<h3 id=\"HTTP和HTTPS\"><a href=\"#HTTP和HTTPS\" class=\"headerlink\" title=\"HTTP和HTTPS\"></a>HTTP和HTTPS</h3><p>1、HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS<br>2、默认HTTP的端口号为80，HTTPS的端口号为443</p>\n<p>HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。</p>\n<h3 id=\"什么是Etag\"><a href=\"#什么是Etag\" class=\"headerlink\" title=\"什么是Etag\"></a>什么是Etag</h3><p>把Last-Modified和ETag请求的http报头一起使用，可利用客户端（例如浏览器）的缓存。ETag用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么ETag也随之发生变化。浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，<br>假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。</p>\n<h3 id=\"浏览器的渲染过程\"><a href=\"#浏览器的渲染过程\" class=\"headerlink\" title=\"浏览器的渲染过程\"></a>浏览器的渲染过程</h3><p>1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。<br>2、CSS文件下载完成，开始构建CSSOM<br>3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。<br>4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。<br>5、最后一步，按照算出来的规则，把内容渲染到屏幕上。</p>\n<p>以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。</p>\n<h3 id=\"一个完整的URL包括以下几部分\"><a href=\"#一个完整的URL包括以下几部分\" class=\"headerlink\" title=\"一个完整的URL包括以下几部分\"></a>一个完整的URL包括以下几部分</h3><p>1、协议部分<br>2、域名部分<br>3、端口部分<br>4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止<br>5、文件名部分：从域名后的最后一个“/”开始到“？”为止<br>6、参数部分：从“？”开始到“#”为止之间的部分<br>7、锚部分：从“#”开始到最后</p>\n<h3 id=\"GET和POST的区别\"><a href=\"#GET和POST的区别\" class=\"headerlink\" title=\"GET和POST的区别\"></a>GET和POST的区别</h3><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在1024字节，Get是通过地址栏来传值。</p>\n<p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post是通过提交表单来传值。</p>\n<h3 id=\"说说网络分层里七层模型是哪七层\"><a href=\"#说说网络分层里七层模型是哪七层\" class=\"headerlink\" title=\"说说网络分层里七层模型是哪七层\"></a>说说网络分层里七层模型是哪七层</h3><p>应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）</p>\n<p>传输层（TCP和UDP）</p>\n<p>网络层（IP）</p>\n<p>物理和数据链路层（以太网）</p>\n<h3 id=\"讲讲304缓存的原理\"><a href=\"#讲讲304缓存的原理\" class=\"headerlink\" title=\"讲讲304缓存的原理\"></a>讲讲304缓存的原理</h3><p>服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>\n<p>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</p>\n<h3 id=\"http-keep-alive与tcp-keep-alive\"><a href=\"#http-keep-alive与tcp-keep-alive\" class=\"headerlink\" title=\"http keep-alive与tcp keep-alive\"></a>http keep-alive与tcp keep-alive</h3><p>http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。</p>\n<h3 id=\"常见web安全及防护原理\"><a href=\"#常见web安全及防护原理\" class=\"headerlink\" title=\"常见web安全及防护原理\"></a>常见web安全及防护原理</h3><ul>\n<li>sql注入原理<br>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</li>\n<li>XSS<br>指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</li>\n<li>CSRF<br>CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤：1、登录受信任网站A，并在本地生成Cookie。2、在不登出A的情况下，访问危险网站B。</li>\n</ul>\n<h3 id=\"对重构的理解\"><a href=\"#对重构的理解\" class=\"headerlink\" title=\"对重构的理解\"></a>对重构的理解</h3><p>在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p>\n<p>减少代码间的耦合<br>让代码保持弹性<br>严格按规范编写代码<br>设计可扩展的API<br>代替旧有的框架、语言(如VB)<br>增强用户体验<br>通常来说对于速度的优化也包含在重构中</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"vue中的MVVM模式\"><a href=\"#vue中的MVVM模式\" class=\"headerlink\" title=\"vue中的MVVM模式\"></a>vue中的MVVM模式</h3><p>  MVVM即Model-View-ViewModel。<br>  Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。  ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的，这个HTML元素可以是body，也可以是某个id所指代的元素。 DOM Listeners和Data Bindings是实现双向绑定的关键。DOM Listeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；Data Bindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化</p>\n<p><br></p>\n<h3 id=\"Vue提供的生命周期钩子\"><a href=\"#Vue提供的生命周期钩子\" class=\"headerlink\" title=\"Vue提供的生命周期钩子\"></a>Vue提供的生命周期钩子</h3><p>  ①　beforeCreate<br>  在实例初始化之后，数据观测(data observer，开始监控Data对象数据变化)和初始化事件(init event，Vue内部初始化事件)之前被调用。<br>  ②　created<br>  在实例已经创建完成之后被调用。实例已完成以下的配置：数据观测(data observer)，属性和方法的运算，event事件回调。挂载阶段尚未开始，$el 属性不可见。<br>  ③　beforeMount<br>  在挂载开始之前被调用。相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。<br>  ④　mounted<br>  在el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。此时模板中的html渲染到了html页面中，此时一般可以做一些Ajax操作。注意mounted只会执行一次。<br>  ⑤　beforeUpdate<br>  在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。<br>  ⑥　updated<br>  在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。<br>  ⑦　beforeDestroy<br>  在实例销毁之前调用。实例仍然完全可用。<br>  ⑧　destroyed<br>  在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。</p>\n<p><br></p>\n<h3 id=\"v-show指令，v-if的区别\"><a href=\"#v-show指令，v-if的区别\" class=\"headerlink\" title=\"v-show指令，v-if的区别\"></a>v-show指令，v-if的区别</h3><p>  条件渲染指令，与v-if不同的是，无论v-show的值为true或false，元素都会存在于HTML代码中；而只有当v-if的值为true，元素才会存在于HTML代码中。v-show指令只是设置了元素CSS的style值</p>\n<p><br></p>\n<h3 id=\"指令keep-alive\"><a href=\"#指令keep-alive\" class=\"headerlink\" title=\"指令keep-alive\"></a>指令keep-alive</h3><p>  在vue-router写着keep-alive，keep-alive的含义： 如果把切换出去的组件保留在内存中，可以保留它的状态或避免重新渲染。为此可以添加一个keep-alive指令<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;component :is=<span class=\"string\">'curremtView'</span> keep-alive&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"指令v-el的使用\"><a href=\"#指令v-el的使用\" class=\"headerlink\" title=\"指令v-el的使用\"></a>指令v-el的使用</h3><p>  有时候我们想就像使用jquery那样去访问一个元素，此时就可以使用v-el指令，去给这个元素注册一个索引，方便通过所属实例的$el访问这个元素。</p>\n<p>  HTML不区分大小写，所以v-el:someEl将转换为全小写。可以用v-el:some-el然后设置this.$el.someEl。<br>示例<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;span v-el:msg&gt;hello&lt;<span class=\"regexp\">/span&gt; </span></span><br><span class=\"line\"><span class=\"regexp\">&lt;span v-el:other-msg&gt;world&lt;/</span>span&gt;  </span><br><span class=\"line\"><span class=\"keyword\">this</span>.$els.msg.textContent <span class=\"comment\">// -&gt;\"hello\"  </span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$els.otherMsg.textContent <span class=\"comment\">// -&gt;\"world\" </span></span><br><span class=\"line\"><span class=\"keyword\">this</span>.$els.msg <span class=\"comment\">//-&gt;&lt;span&gt;hello&lt;/span&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"Vue-js特点\"><a href=\"#Vue-js特点\" class=\"headerlink\" title=\"Vue.js特点\"></a>Vue.js特点</h3><p>  简洁：页面由HTML模板+Json数据+Vue实例组成<br>  数据驱动：自动计算属性和追踪依赖的模板表达式<br>  组件化：用可复用、解耦的组件来构造页面<br>  轻量：代码量小，不依赖其他库 快速：精确有效批量DOM更新<br>  模板友好：可通过npm，bower等多种方式安装，很容易融入</p>\n<p><br></p>\n<h3 id=\"JS中的常量（基本数据类型）和内置对象\"><a href=\"#JS中的常量（基本数据类型）和内置对象\" class=\"headerlink\" title=\"JS中的常量（基本数据类型）和内置对象\"></a>JS中的常量（基本数据类型）和内置对象</h3><p>  js中的基本数据类型：String 、number、null、boolean、undefined、object、symbol（ES6）</p>\n<ul>\n<li>1、 利用typeof运算符时其中只有null是异常的，typeof（null）=object，所以在判断变量类型是否为null时要注意。同时利用typeof时对于没有声明的变量是不会报错的，返回值为undefined。全局变量和函数变量在没有声明时使用是会报错的，但是在对象中使用没有定义的属性是不会报错同样返回的是undefined。Function变量是具有length属性的，其长度为传入的参数的个数。</li>\n<li>2、 变量时弱类型的，即其本身是没有类型的，其值才是具有类型的。</li>\n<li>3、 对于number类型，<br>（1）其中要注意的是NAN非数字的数字，用全局的函数isNAN判断时会有问题，即对于非数字类型的变量其也会返回true，所以在使用时可以用以下方式判断NAN：<br>①a!=a<br>②利用ES6中的Number.isNAN;<br>③typeof(a)==’number’&amp;&amp;isNAN(a)<br>（2）还有一个要注意的是+0，-0这两者在使用时是相等的但是在浏览器引擎上还是会有区别，区分二者可以利用：typeof(a)==typeof(b)&amp;&amp;1/a==1/b，+0、-0作为分母时会得到infinite和-infinite。在ES6中有Object.is方法可用于判断两个变量是否相等。可用于上述情况。但是前者的方法的执行效率更好。<br>（3）另外在JS中数字类型也是有最大和最小值的界定的安全范围的<br>（4）判断变量是否为整数的方法：<br>①Number.isInteger(a)，ES6中的方法<br>②typeof（a）==’number’&amp;&amp;a%1==0<br>③或者使用Math.ceil(a)==a等类似的方法</li>\n<li>4、变量在复制和作为参数传递时会有引用传递和值传递之分：<br>（1）值传递即普通的变量类型<br>（2）引用传递，如对象和数组等幅值或者作为参数传递传递的是复制的引用会相会影响：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var a=[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>];</span><br><span class=\"line\">Var b=a;</span><br><span class=\"line\">b.push(<span class=\"number\">4</span>);<span class=\"comment\">//a=[1,2,3,4];b=[1,2,3,4]</span></span><br><span class=\"line\">但是当b重新赋值时：</span><br><span class=\"line\">Var b=[<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>]<span class=\"comment\">//a=[1,2,3,4];b=[4,5,6]因为b的引用已经发生了改变不在是a数组的引用的复制。</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>JS中的内置函数: String、Number、Boolean、RegExp、Date、Error、Array、<br>Function、Object、symbol;类似于对象的构造函数</p>\n<ul>\n<li>1、这些内置函数构造的变量都是封装了基本类型值的对象如：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Var a=<span class=\"keyword\">new</span> <span class=\"built_in\">String</span>(‘abb’); <span class=\"comment\">//typeof(a)=object</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>除了利用Function构造的变量通过typeof输出为function外其他均为object</p>\n<ul>\n<li>2、为了知道构造的变量的真实类型可以利用：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call([<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]);<span class=\"comment\">//”[object,array]”</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>后面的一个值即为传入参数的类型</p>\n<ul>\n<li>3、如果有常量形式（即利用基本数据类型）赋值给变量就不要用该方式来定义变量</li>\n</ul>\n<p><br></p>\n<h3 id=\"js中判断一个对象的类型的种种方法\"><a href=\"#js中判断一个对象的类型的种种方法\" class=\"headerlink\" title=\"js中判断一个对象的类型的种种方法\"></a>js中判断一个对象的类型的种种方法</h3><h4 id=\"javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。\"><a href=\"#javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。\" class=\"headerlink\" title=\"javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。\"></a>javascript中检测对象的类型的运算符有：typeof、constructor、instanceof。</h4><ul>\n<li><p>typeof：typeof是一个一元运算符，返回结果是一个说明运算数类型的字符串。如：”number”，”string”，”boolean”，”object”，”function”，”undefined”（可用于判断变量是否存在）。 但 typeof 的能力有限，其对于Date、RegExp、Array类型返回的都是”object”。所以它只在区别对象和原始类型的时候才有用。要区一种对象类型和另一种对象类型，必须使用其他的方法。</p>\n</li>\n<li><p>instanceof 运算符：instanceof 运算符要求其左边的运算数是一个对象，右边的运算数是对象类的名字或构造函数。如果 object 是 class 或构造函数的实例，则 instanceof 运算符返回 true。如果 object 不是指定类或函数的实例，或者 object 为 null，则返回 false。instanceof方法可以判断变量是否是数组类型，但是只限同一全局环境之内，在一个页面有多个iframe的情况下，instanceof失效。</p>\n</li>\n<li><p>constructor 属性: JavaScript中，每个对象都有一个constructor属性，它引用了初始化该对象的构造函数，常用于判断未知对象的类型。如给定一个求知的值 通过typeof运算符来判断它是原始的值还是对象。如果是对象，就可以使用constructor属性来判断其类型。</p>\n</li>\n<li><p>Object.prototype.toString.call()：该方法是目前为止发现的判断一个对象类型的最好的办法。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"事件冒泡与事件捕获\"><a href=\"#事件冒泡与事件捕获\" class=\"headerlink\" title=\"事件冒泡与事件捕获\"></a>事件冒泡与事件捕获</h3><h4 id=\"事件冒泡\"><a href=\"#事件冒泡\" class=\"headerlink\" title=\"事件冒泡\"></a>事件冒泡</h4><p>微软提出了名为事件冒泡(event bubbling)的事件流。事件冒泡可以形象地比喻为把一颗石头投入水中，泡泡会一直从水底冒出水面。也就是说，事件会从最内层的元素开始发生，一直向上传播，直到document对象，由内向外。</p>\n<h3 id=\"事件捕获\"><a href=\"#事件捕获\" class=\"headerlink\" title=\"事件捕获\"></a>事件捕获</h3><p>网景提出另一种事件流名为事件捕获(event capturing)。与事件冒泡相反，事件会从最外层开始发生，直到最具体的元素，由外向内。</p>\n<p>addEventListener方法用来为一个特定的元素绑定一个事件处理函数，是JavaScript中的常用方法。addEventListener有三个参数：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">element.addEventListener(event, <span class=\"function\"><span class=\"keyword\">function</span>, <span class=\"title\">useCapture</span>)</span></span><br></pre></td></tr></table></figure></p>\n<p>第一个参数是需要绑定的事件，第二个参数是触发事件后要执行的函数。而第三个参数默认值是false，表示在事件冒泡的阶段调用事件处理函数，如果参数为true，则表示在事件捕获阶段调用处理函数。</p>\n<p>对于事件代理来说，在事件捕获或者事件冒泡阶段处理并没有明显的优劣之分，但是由于事件冒泡的事件流模型被所有主流的浏览器兼容，从兼容性角度来说还是建议大家使用事件冒泡模型。</p>\n<h5 id=\"IE浏览器\"><a href=\"#IE浏览器\" class=\"headerlink\" title=\"IE浏览器\"></a>IE浏览器</h5><p>IE只支持事件冒泡，不支持事件捕获，它也不支持addEventListener函数，不会用第三个参数来表示是冒泡还是捕获，它提供了另一个函数attachEvent。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ele.attachEvent(<span class=\"string\">\"onclick\"</span>, doSomething2);</span><br></pre></td></tr></table></figure></p>\n<p>附：事件冒泡（的过程）：事件从发生的目标（event.srcElement||event.target）开始，沿着文档逐层向上冒泡，到document为止。</p>\n<h4 id=\"事件的传播是可以阻止的：\"><a href=\"#事件的传播是可以阻止的：\" class=\"headerlink\" title=\"事件的传播是可以阻止的：\"></a>事件的传播是可以阻止的：</h4><p>• 在W3c中，使用stopPropagation（）方法<br>• 在IE下设置cancelBubble = true；<br>在捕获的过程中stopPropagation（）；后，后面的冒泡过程也不会发生了~<br>3.阻止事件的默认行为，例如click a 后的跳转~<br>• 在W3c中，使用preventDefault（）方法；<br>• 在IE下设置window.event.returnValue = false;</p>\n<p><br></p>\n<h3 id=\"浏览器的重绘与重排\"><a href=\"#浏览器的重绘与重排\" class=\"headerlink\" title=\"浏览器的重绘与重排\"></a>浏览器的重绘与重排</h3><p>1.重排的概念<br>浏览器下载完页面中的所有组件（HTML、JavaScript、CSS、图片）之后会解析生成两个内部数据结构（DOM树和渲染树），DOM树表示页面结构，渲染树表示DOM节点如何显示。重排是DOM元素的几何属性变化，DOM树的结构变化，渲染树需要重新计算。</p>\n<p>2.重绘的概念<br>重绘是一个元素外观的改变所触发的浏览器行为，例如改变visibility、outline、背景色等属性。浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。由于浏览器的流布局，对渲染树的计算通常只需要遍历一次就可以完成。但table及其内部元素除外，它可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用table布局页面的原因之一。</p>\n<p>3.重绘和重排的关系<br>重绘不会引起重排，但重排一定会引起重绘，一个元素的重排通常会带来一系列的反应，甚至触发整个文档的重排和重绘，性能代价是高昂的。</p>\n<p>4.什么情况下会触发重排？<br>(1)页面渲染初始化时；（这个无法避免）<br>(2)浏览器窗口改变尺寸；<br>(3)元素尺寸改变时；<br>(4)元素位置改变时；<br>(5)元素内容改变时；<br>(6)添加或删除可见的DOM 元素时。</p>\n<p>6.无论是外链CSS还是内联CSS都会阻塞DOM渲染（Rendering），然而DOM解析（Parsing）会正常进行。 这意味着在CSS下载并解析结束之前，它后面的HTML都不会显示。 这也是为什么我们把样式放在HTML内容之前，以防止被呈现内容发生样式跳动。 当然代价就是显示延迟，所以性能攸关的站点都会内联所有CSS。</p>\n<p><br></p>\n<h3 id=\"extend-obj-fn-extend-obj\"><a href=\"#extend-obj-fn-extend-obj\" class=\"headerlink\" title=\"$.extend(obj);$.fn.extend(obj);\"></a>$.extend(obj);$.fn.extend(obj);</h3><p>$拓展的方法是静态方法，可以使用$直接调用，其拓展的方式有两种，一般使用$.extend({});而$.fn拓展的方法是实例方法，必须由“对象”$(“”)来调用，其拓展的方式同样有两种，一般使用$.fn.extend({ })。</p>\n<p>$.extend(obj);是为了扩展jquery本身，为类添加新的方法</p>\n<p>$.fn.extend(obj);给JQUERY对象添加方法。</p>\n<p>$.fn 中的fn其实是prototype，即$.fn=$.prototype;</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.extend(&#123;</span><br><span class=\"line\">add:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a,b</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a+b;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$.add(<span class=\"number\">5</span>,<span class=\"number\">8</span>) <span class=\"comment\">//return 13</span></span><br></pre></td></tr></table></figure>\n<p>这边的调用直接调用，前面不用任何对象。直接$.+方法名</p>\n<p>$.fn.extend(obj)；对prototype进行扩展，为jquery类添加成员函数， jquery类的实例可以使用这个成员函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$.fn.extend(&#123;</span><br><span class=\"line\">clickwhile:<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  $(<span class=\"keyword\">this</span>).click(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  alert($(<span class=\"keyword\">this</span>).val()) </span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">$(<span class=\"string\">'input'</span>).clickwhile();<span class=\"comment\">//当点击输入框会弹出该对象的Value值</span></span><br></pre></td></tr></table></figure>\n<p>注意调用时候前面是有对象的。即$(‘input’) 这么个东西。</p>\n<p><br></p>\n<h3 id=\"CSS-hack区分IE6-IE7-IE8-firefox\"><a href=\"#CSS-hack区分IE6-IE7-IE8-firefox\" class=\"headerlink\" title=\"CSS hack区分IE6,IE7,IE8,firefox\"></a>CSS hack区分IE6,IE7,IE8,firefox</h3><h4 id=\"CSS-hack使用原理\"><a href=\"#CSS-hack使用原理\" class=\"headerlink\" title=\"CSS hack使用原理\"></a>CSS hack使用原理</h4><p>简单来讲，CSS hack就是浏览器解析CSS时的漏洞，因此不同的浏览器就有不同的CSS hack写法。 CSS hack使用原则: 尽力避免使用CSS hack，并寻找其它的应对方法。事实上，使用IE的条件注释来区分IE各个版本，是非常不错的选择。</p>\n<h4 id=\"CSS-hack使用后的弊端\"><a href=\"#CSS-hack使用后的弊端\" class=\"headerlink\" title=\"CSS hack使用后的弊端\"></a>CSS hack使用后的弊端</h4><p>CSS Hack除了能迅速区分浏览器版本，并可能获得大概一直的效果，但从长远看，CSS Hack会引起许多新的错误。</p>\n<h4 id=\"CSS-hack的实现方式-针对IE6\"><a href=\"#CSS-hack的实现方式-针对IE6\" class=\"headerlink\" title=\"CSS hack的实现方式(针对IE6)\"></a>CSS hack的实现方式(针对IE6)</h4><ul>\n<li>1.利用浏览器对相同代码的解析和支持的不同实现的hack<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#test&#123;</span><br><span class=\"line\">   _width:<span class=\"number\">80</span>px;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在IE7及以上版本的浏览器中会被当作错误特性而舍弃，但是在IE6中可以被正常的解析。这时候，可以把_width当作hack，专门针对IE6来设置元素的宽度。</p>\n<ul>\n<li>2.利用IE对标准的支持缺陷写的CSS hack<br>!important只有IE7及以上版本的IE及其他浏览器支持，所以，可以用!important来针对IE6以外的浏览器写CSS代码；再如，head:first-child+bodyselector，:first-child不被IE6支持，所以可以用来针对IE6以外的浏览器编写CSS代码。IE6支持下划线，IE7和firefox均不支持下划线。</li>\n</ul>\n<blockquote>\n<p>CSS hack区别IE6与Firefox：<br>background:orange;*background:blue;</p>\n</blockquote>\n<blockquote>\n<p>CSS hack区别IE6与IE7：<br>background:green !important;background:blue;</p>\n</blockquote>\n<blockquote>\n<p>CSS hack区别IE7与Firefox：<br>background:orange; *background:green;</p>\n</blockquote>\n<blockquote>\n<p>CSS hack区别Firefox，IE7，IE6：<br>background:orange;<em>background:green !important;</em>background:blue;</p>\n</blockquote>\n<p><br></p>\n<h3 id=\"如何避免FOUC？\"><a href=\"#如何避免FOUC？\" class=\"headerlink\" title=\"如何避免FOUC？\"></a>如何避免FOUC？</h3><p>如果使用import方法对CSS进行导入,会导致某些页面在Windows 下的Internet Explorer出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC.原因大致为：</p>\n<p>1，使用import方法导入样式表。<br>2，将样式表放在页面底部<br>3，有几个样式表，放在html结构的不同位置。其实原理很清楚：当样式表晚于 结构性html 加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂 的 花屏现象。解决方法：使用LINK标签将样式表放在文档HEAD中更多</p>\n<p><br></p>\n<h3 id=\"DOM-中-Property-和-Attribute-的区别\"><a href=\"#DOM-中-Property-和-Attribute-的区别\" class=\"headerlink\" title=\"DOM 中 Property 和 Attribute 的区别\"></a>DOM 中 Property 和 Attribute 的区别</h3><ul>\n<li><p>Property：属性，所有的HTML元素都由HTMLElement类型表示，HTMLElement类型直接继承自Element并添加了一些属性，添加的这些属性分别对应于每个HTML元素都有下面的这5个标准特性: id,title,lang,dir,className。DOM节点是一个对象，因此，他可以和其他的JavaScript对象一样添加自定义的属性以及方法。property的值可以是任何的数据类型，对大小写敏感，自定义的property不会出现在html代码中，只存在js中。</p>\n</li>\n<li><p>Attribute：特性，区别于property，attribute只能是字符串，大小写不敏感，出现在innerHTML中，通过类数组attributes可以罗列所有的attribute。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"document-onload和document-ready两个事件的区别\"><a href=\"#document-onload和document-ready两个事件的区别\" class=\"headerlink\" title=\"document.onload和document.ready两个事件的区别\"></a>document.onload和document.ready两个事件的区别</h3><ul>\n<li>ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）</li>\n<li>onload，指示页面包含图片等文件在内的所有元素都加载完成。</li>\n</ul>\n<p><br></p>\n<h3 id=\"JavaScript的同源策略\"><a href=\"#JavaScript的同源策略\" class=\"headerlink\" title=\"JavaScript的同源策略\"></a>JavaScript的同源策略</h3><p>在客户端编程语言中，如javascript和 ActionScript，同源策略是一个很重要的安全理念，它在保证数据的安全性方面有着重要的意义。同源策略规定跨域之间的脚本是隔离的，一个域的脚本不能访问和操作另外一个域的绝大部分属性和方法。那么什么叫相同域，什么叫不同的域呢？当两个域具有相同的协议, 相同的端口，相同的host，那么我们就可以认为它们是相同的域。同源策略还应该对一些特殊情况做处理，比如限制file协议下脚本的访问权限。本地的HTML文件在浏览器中是通过file协议打开的，如果脚本能通过file协议访问到硬盘上其它任意文件，就会出现安全隐患，目前IE8还有这样的隐患。</p>\n<p><br></p>\n<h3 id=\"给选择器一个上下文\"><a href=\"#给选择器一个上下文\" class=\"headerlink\" title=\"给选择器一个上下文\"></a>给选择器一个上下文</h3><p>jQuery选择器中有一个这样的选择器，它能指定上下文。jQuery(expression,context);通过它，能缩小选择器在DOM中搜索的范围，达到节省时间，提高效率。普通方式：$(‘.myDiv’)改进方式：$(‘.myDiv’,$(“#listItem”))。</p>\n<p><br></p>\n<h3 id=\"请解释JSONP的工作原理，以及它为什么不是真正的AJAX\"><a href=\"#请解释JSONP的工作原理，以及它为什么不是真正的AJAX\" class=\"headerlink\" title=\"请解释JSONP的工作原理，以及它为什么不是真正的AJAX\"></a>请解释JSONP的工作原理，以及它为什么不是真正的AJAX</h3><p>JSONP (JSON with Padding)是一个简单高效的跨域方式，HTML中的script标签可以加载并执行其他域的javascript，于是我们可以通过script标记来动态加载其他域的资源。例如我要从域A的页面pageA加载域B的数据，那么在域B的页面pageB中我以JavaScript的形式声明pageA需要的数据，然后在 pageA中用script标签把pageB加载进来，那么pageB中的脚本就会得以执行。JSONP在此基础上加入了回调函数，pageB加载完之后会执行pageA中定义的函数，所需要的数据会以参数的形式传递给该函数。JSONP易于实现，但是也会存在一些安全隐患，如果第三方的脚本随意地执行，那么它就可以篡改页面内容，截获敏感数据。但是在受信任的双方传递数据，JSONP是非常合适的选择。</p>\n<p>AJAX是不跨域的，而JSONP是一个是跨域的，还有就是二者接收参数形式不一样！</p>\n<p><br></p>\n<h3 id=\"浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别\"><a href=\"#浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别\" class=\"headerlink\" title=\"浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别\"></a>浏览器特性检测，特性推断和浏览器UA字符串嗅探的区别</h3><p>特性检测：为特定浏览器的特性进行测试，并仅当特性存在时即可应用特性。</p>\n<p>User-Agent检测：最早的浏览器嗅探即用户代理检测，服务端（以及后来的客户端）根据UA字符串屏蔽某些特定的浏览器查看网站内容。</p>\n<p>特性推断：尝试使用多个特性但仅验证了其中之一。根据一个特性的存在推断另一个特性是否存在。问题是，推断是假设并非事实，而且可能导致可维护性的问题</p>\n<p><br></p>\n<h3 id=\"JavaScript宿主对象和原生对象的区别\"><a href=\"#JavaScript宿主对象和原生对象的区别\" class=\"headerlink\" title=\"JavaScript宿主对象和原生对象的区别\"></a>JavaScript宿主对象和原生对象的区别</h3><h4 id=\"原生对象\"><a href=\"#原生对象\" class=\"headerlink\" title=\"原生对象\"></a>原生对象</h4><p>ECMA-262 把本地对象（native object）定义为“独立于宿主环境的 ECMAScript 实现提供的对象”。</p>\n<p>“本地对象”包含哪些内容：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError。</p>\n<p>由此可以看出，简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。</p>\n<h4 id=\"内置对象\"><a href=\"#内置对象\" class=\"headerlink\" title=\"内置对象\"></a>内置对象</h4><p>ECMA-262 把内置对象（built-in object）定义为“由 ECMAScript 实现提供的、独立于宿主环境的所有对象，在 ECMAScript 程序开始执行时出现”。这意味着开发者不必明确实例化内置对象，它已被实例化了。</p>\n<p>同样是“独立于宿主环境”。根据定义我们似乎很难分清“内置对象”与“本地对象”的区别。而ECMA-262 只定义了两个内置对象，即 Global 和 Math （它们也是本地对象，根据定义，每个内置对象都是本地对象）。如此就可以理解了。内置对象是本地对象的一种。</p>\n<h4 id=\"宿主对象\"><a href=\"#宿主对象\" class=\"headerlink\" title=\"宿主对象\"></a>宿主对象</h4><p>何为“宿主对象”？主要在这个“宿主”的概念上，ECMAScript中的“宿主”当然就是我们网页的运行环境，即“操作系统”和“浏览器”。</p>\n<p>所有非本地对象都是宿主对象（host object），即由 ECMAScript 实现的宿主环境提供的对象。所有的BOM和DOM都是宿主对象。因为其对于不同的“宿主”环境所展示的内容不同。其实说白了就是，ECMAScript官方未定义的对象都属于宿主对象，因为其未定义的对象大多数是自己通过ECMAScript程序创建的对象。</p>\n<p><br></p>\n<h3 id=\"AMD、CMD和CommonJS规范\"><a href=\"#AMD、CMD和CommonJS规范\" class=\"headerlink\" title=\"AMD、CMD和CommonJS规范\"></a>AMD、CMD和CommonJS规范</h3><h4 id=\"CommonJS规范\"><a href=\"#CommonJS规范\" class=\"headerlink\" title=\"CommonJS规范\"></a>CommonJS规范</h4><p> CommonJS是在浏览器环境之外构建JavaScript生态系统为目标产生的项目，比如服务器和桌面环境中。CommonJS规范是为了解决JavaScript的作用域问题而定义的模块形式，<br>可以使每个模块在它自身的命名空间中执行。该规范的主要内容是：模块必须通过  module.exports导出对外的变量或接口，通过require()来导入其他模块的输出到当前模块。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// moduleA.js  </span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"> value </span>)</span>&#123;  </span><br><span class=\"line\">    <span class=\"keyword\">return</span> value * <span class=\"number\">2</span>;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// moduleB.js  </span></span><br><span class=\"line\"><span class=\"keyword\">var</span> multiplyBy2 = <span class=\"built_in\">require</span>(<span class=\"string\">'./moduleA'</span>);  </span><br><span class=\"line\"><span class=\"keyword\">var</span> result = multiplyBy2(<span class=\"number\">4</span>);</span><br></pre></td></tr></table></figure>\n<p>CommonJS是同步加载模块，但其实也有浏览器端的实现，其原理是将所有模块都定义好并通过id进行索引，这样就可以浏览器进行解析了</p>\n<p>服务器端的Node.js遵循CommonJS规范。核心思想是允许模块通过require 方法来同步加载所要依赖的其他模块，然后通过 exports或module.exports来导出需要暴露的接口。</p>\n<p>优点：<br>服务器端便于重用<br>NPM中已经将近20w个模块包<br>简单并容易使用<br>缺点：<br>同步的模块方式不适合不适合在浏览器环境中，同步意味着阻塞加载，浏览器资源是异步加载的<br>不能非阻塞的并行加载多个模块</p>\n<h4 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h4><p>AMD规范其实只有一个主要接口 define(id,dependencies,factory)，它要在声明模块的时候指定所有的依赖dependencies，并且还要当做形参传到factory中，对于依赖的模块提前执行，依赖前置</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"string\">\"module\"</span>, [<span class=\"string\">\"dep1\"</span>, <span class=\"string\">\"dep2\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">d1, d2</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">return</span> someExportedValue;  </span><br><span class=\"line\">&#125;);  </span><br><span class=\"line\"><span class=\"built_in\">require</span>([<span class=\"string\">\"module\"</span>, <span class=\"string\">\"../file\"</span>], <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">module, file</span>) </span>&#123; <span class=\"comment\">/* ... */</span> &#125;);  \\</span><br></pre></td></tr></table></figure>\n<p>优点：<br>适合在浏览器环境异步加载<br>并行加载多个模块<br>缺点：<br>提高开发成本，代码阅读和书写比较困难<br>不符合通用的模块思维方式，是一种妥协的实现</p>\n<h4 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h4><p>CMD规范和AMD相似，尽量保持简单，并且与CommonJS和NodeJS的Modules规范保持了很大的兼容性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">require, exports, module</span>) </span>&#123;  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> $ = <span class=\"built_in\">require</span>(<span class=\"string\">'jquery'</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">var</span> Spinning = <span class=\"built_in\">require</span>(<span class=\"string\">'./spinning'</span>);  </span><br><span class=\"line\">  exports.doSomething = ...  </span><br><span class=\"line\">  <span class=\"built_in\">module</span>.exports = ...  </span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>优点：<br>依赖就近，延迟执行<br>很容易在node中运行<br>缺点：<br>依赖SPM打包，模块的加载逻辑偏重</p>\n<p><br></p>\n<h3 id=\"事件代理\"><a href=\"#事件代理\" class=\"headerlink\" title=\"事件代理\"></a>事件代理</h3><p>JavaScript事件代理则是一种简单的技巧，通过它你可以把事件处理器添加到一个父级元素上，这样就避免了把事件处理器添加到多个子级元素上。当我们需要对很多元素添加事件的时候，可以通过将事件添加到它们的父节点而将事件委托给父节点来触发处理函数。这主要得益于浏览器的事件冒泡机制。事件代理用到了两个在JavaSciprt事件中常被忽略的特性：事件冒泡以及目标元素。</p>\n<p><br></p>\n<h3 id=\"如果设计中使用了非标准的字体，如何去实现\"><a href=\"#如果设计中使用了非标准的字体，如何去实现\" class=\"headerlink\" title=\"如果设计中使用了非标准的字体，如何去实现\"></a>如果设计中使用了非标准的字体，如何去实现</h3><p>所谓的标准字体是多数机器上都会有的，或者即使没有也可以由默认字体替代的字体。<br>方法：</p>\n<ul>\n<li>用图片代替</li>\n<li>web fonts在线字库，如Google Webfonts，Typekit等等；<a href=\"http://www.chinaz.com/free/2012/0815/269267.shtml；\" target=\"_blank\" rel=\"noopener\">http://www.chinaz.com/free/2012/0815/269267.shtml；</a></li>\n<li>@font-face，Webfonts(字体服务例如：Google Webfonts，Typekit等等。)</li>\n</ul>\n<p><br></p>\n<h3 id=\"使用CSS预处理器的优缺点\"><a href=\"#使用CSS预处理器的优缺点\" class=\"headerlink\" title=\"使用CSS预处理器的优缺点\"></a>使用CSS预处理器的优缺点</h3><p>LESS&amp;SassLESS是受Sass启发而开发的工具，它列出了如下开发的理由：</p>\n<p>“为什么要开发一个Sass的替代品呢？原因很简单：首先是语法。Sass的一个关键特性是缩进式的语法，这种语法可以产生柱式外观的代码。但是你需要花费时间学习一门新的语法以及重新构建你现在的样式表。LESS给CSS带来了很多特性，使得LESS能够和CSS无缝地紧密结合在一起。因此，你可以平滑地由CSS迁移到LESS，如果你只是对使用变量或者操作感兴趣的话，你不需要学习一整门全新的语言。”</p>\n<p>Stylus相对前两者较新，可以看官方文档介绍的功能。</p>\n<p>1.来自NodeJS社区，所以和NodeJS走得很近，与JavaScript联系非常紧密。还有专门JavaScript API：<a href=\"http://learnboost.github.io/stylus/docs/js.html；\" target=\"_blank\" rel=\"noopener\">http://learnboost.github.io/stylus/docs/js.html；</a><br>2.支持Ruby之类等等框架；<br>3.更多更强大的支持和功能总结：Sass看起来在提供的特性上占有优势，但是LESS能够让开发者平滑地从现存CSS文件过渡到LESS，而不需要像Sass那样需要将CSS文件转换成Sass格式。Stylus功能上更为强壮，和js联系更加紧密。</p>\n<p><br></p>\n<h3 id=\"cookies，sessionStorage和localStorage的区别\"><a href=\"#cookies，sessionStorage和localStorage的区别\" class=\"headerlink\" title=\"cookies，sessionStorage和localStorage的区别\"></a>cookies，sessionStorage和localStorage的区别</h3><p>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。<br>  cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。<br>  sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</p>\n<p>存储大小：<br>  cookie数据大小不能超过4k。<br>  sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</p>\n<p>有期时间：<br>  localStorage    存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>  sessionStorage  数据在当前浏览器窗口关闭后自动删除。<br>  cookie          设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</p>\n<p><br></p>\n<h3 id=\"浏览器标准模式和怪异模式之间的区别\"><a href=\"#浏览器标准模式和怪异模式之间的区别\" class=\"headerlink\" title=\"浏览器标准模式和怪异模式之间的区别\"></a>浏览器标准模式和怪异模式之间的区别</h3><p>W3C标准推出以后，浏览器都开始采纳新标准，但存在一个问题就是如何保证旧的网页还能继续浏览，在标准出来以前，很多页面都是根据旧的渲染方法编写的，如果用的标准来渲染，将导致页面显示异常。为保持浏览器渲染的兼容性，使以前的页面能够正常浏览，浏览器都保留了旧的渲染方法（如：微软的IE）。这样浏览器渲染上就产生了Quircks mode和Standars mode，两种渲染方法共存在一个浏览器上。IE盒子模型和标准W3C盒子模型：ie的width包括：padding\\border。标准的width不包括：padding\\border</p>\n<p> 在js中如何判断当前浏览器正在以何种方式解析？<br>         document对象有个属性compatMode,它有两个值：BackCompat对应quirks mode，CSS1Compat对应strict mode。</p>\n<p><br></p>\n<h3 id=\"doctype（文档类型）的作用，有多少种文档类型\"><a href=\"#doctype（文档类型）的作用，有多少种文档类型\" class=\"headerlink\" title=\"doctype（文档类型）的作用，有多少种文档类型\"></a>doctype（文档类型）的作用，有多少种文档类型</h3><p>此标签可告知浏览器文档使用哪种HTML或XHTML规范。该标签可声明三种DTD类型，分别表示严格版本、过渡版本以及基于框架的HTML文档。</p>\n<p>HTML 4.01规定了三种文档类型：Strict、Transitional以及Frameset。</p>\n<p>XHTML 1.0规定了三种XML文档类型：Strict、Transitional以及Frameset。</p>\n<p>Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。</p>\n<p><br></p>\n<h3 id=\"对语义化的理解\"><a href=\"#对语义化的理解\" class=\"headerlink\" title=\"对语义化的理解\"></a>对语义化的理解</h3><p>1：去掉或样式丢失的时候能让页面呈现清晰的结构：html本身是没有表现的，我们看到例如 h1 是粗体，字体大小2em，加粗；strong 是加粗的，不要认为这是html的表现，这些其实html默认的css样式在起作用，所以去掉或样式丢失的时候能让页面呈现清晰的结构不是语义化的HTML结构的优点，但是浏览器都有有默认样式，默认样式的目的也是为了更好的表达html的语义，可以说浏览器的默认样式和语义化的HTML结构是不可分割的。</p>\n<p>2.屏幕阅读器（如果访客有视障）会完全根据你的标记来“读”你的网页。</p>\n<p>3.PDA、手机等设备可能无法像普通电脑的浏览器一样来渲染网页（通常是因为这些设备对CSS的支持较弱）。</p>\n<p>4.有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重。</p>\n<p>5.便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</p>\n<p><br></p>\n<h3 id=\"渐进增强和优雅降级\"><a href=\"#渐进增强和优雅降级\" class=\"headerlink\" title=\"渐进增强和优雅降级\"></a>渐进增强和优雅降级</h3><p>优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.</p>\n<p>渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。</p>\n<p><br></p>\n<h3 id=\"浏览器同一时间可以从一个域名下载多少资源\"><a href=\"#浏览器同一时间可以从一个域名下载多少资源\" class=\"headerlink\" title=\"浏览器同一时间可以从一个域名下载多少资源\"></a>浏览器同一时间可以从一个域名下载多少资源</h3><p>这个专业的说法叫“浏览器并发请求数”。意即，同一时间针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻止。所有浏览器的并发数目一般限制在10以内。</p>\n<p> <img src=\"https://pic4.zhimg.com/ea606d016e8ab77db9d8a8dfa5243a1b_r.jpg\" width=\"200\" height=\"200\"></p>\n<p><br></p>\n<h3 id=\"Canvas-与-SVG\"><a href=\"#Canvas-与-SVG\" class=\"headerlink\" title=\"Canvas 与 SVG\"></a>Canvas 与 SVG</h3><h4 id=\"Canvas\"><a href=\"#Canvas\" class=\"headerlink\" title=\"Canvas\"></a>Canvas</h4><ul>\n<li>依赖分辨率</li>\n<li>不支持事件处理器</li>\n<li>弱的文本渲染能力</li>\n<li>能够以 .png 或 .jpg 格式保存结果图像</li>\n<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘<h3 id=\"SVG\"><a href=\"#SVG\" class=\"headerlink\" title=\"SVG\"></a>SVG</h3></li>\n<li>不依赖分辨率</li>\n<li>支持事件处理器</li>\n<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>\n<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>\n<li>不适合游戏应用</li>\n</ul>\n<p><br></p>\n<h3 id=\"页面导入样式时，使用link和-import有什么区别\"><a href=\"#页面导入样式时，使用link和-import有什么区别\" class=\"headerlink\" title=\"页面导入样式时，使用link和@import有什么区别\"></a>页面导入样式时，使用link和@import有什么区别</h3><p>（1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS;</p>\n<p>（2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;</p>\n<p>（3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问</p>\n<p><br></p>\n<h3 id=\"介绍一下你对浏览器内核的理解\"><a href=\"#介绍一下你对浏览器内核的理解\" class=\"headerlink\" title=\"介绍一下你对浏览器内核的理解\"></a>介绍一下你对浏览器内核的理解</h3><p>  主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。<br>  渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>\n<p>  JS引擎则：解析和执行javascript来实现网页的动态效果。</p>\n<p>  最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。</p>\n<p><br></p>\n<h3 id=\"常见的浏览器内核有哪些？\"><a href=\"#常见的浏览器内核有哪些？\" class=\"headerlink\" title=\"常见的浏览器内核有哪些？\"></a>常见的浏览器内核有哪些？</h3><p>  Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML]<br>  Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等<br>  Presto内核：Opera7及以上。      [Opera内核原为：Presto，现为：Blink;]<br>  Webkit内核：Safari,Chrome等。   [ Chrome的：Blink（WebKit的分支）]</p>\n<p><br></p>\n<h3 id=\"html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和\"><a href=\"#html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分-HTML-和\" class=\"headerlink\" title=\"html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和\"></a>html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和</h3><p>HTML5？</p>\n<ul>\n<li><p>HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。</p>\n<pre><code>绘画 canvas;\n用于媒介回放的 video 和 audio 元素;\n本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失;\nsessionStorage 的数据在浏览器关闭后自动删除;\n语意化更好的内容元素，比如 article、footer、header、nav、section;\n表单控件，calendar、date、time、email、url、search;\n新的技术webworker, websocket, Geolocation;\n</code></pre><p>   移除的元素：</p>\n<pre><code>纯表现的元素：basefont，big，center，font, s，strike，tt，u;\n对可用性产生负面影响的元素：frame，frameset，noframes；\n</code></pre><ul>\n<li><p>支持HTML5新标签：<br>   IE8/IE7/IE6支持通过document.createElement方法产生的标签，</p>\n<pre><code>可以利用这一特性让这些浏览器支持HTML5新标签，\n浏览器支持新标签后，还需要添加标签默认的样式。\n</code></pre><p>   当然也可以直接使用成熟的框架、比如html5shim;</p>\n</li>\n<li><p>如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"HTML5的离线储存怎么使用\"><a href=\"#HTML5的离线储存怎么使用\" class=\"headerlink\" title=\"HTML5的离线储存怎么使用\"></a>HTML5的离线储存怎么使用</h3><p>  在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。<br>  原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。</p>\n<p><br></p>\n<h3 id=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"><a href=\"#浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\" class=\"headerlink\" title=\"浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？\"></a>浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？</h3><p>  在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。<br>  离线的情况下，浏览器就直接使用离线存储的资源。</p>\n<p><br></p>\n<h3 id=\"iframe有那些缺点？\"><a href=\"#iframe有那些缺点？\" class=\"headerlink\" title=\"iframe有那些缺点？\"></a>iframe有那些缺点？</h3><ul>\n<li>iframe会阻塞主页面的Onload事件；</li>\n<li><p>搜索引擎的检索程序无法解读这种页面，不利于SEO;</p>\n</li>\n<li><p>iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。</p>\n<p>使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript<br>动态给iframe添加src属性值，这样可以绕开以上两个问题。</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"Label的作用是什么？是怎么用的\"><a href=\"#Label的作用是什么？是怎么用的\" class=\"headerlink\" title=\"Label的作用是什么？是怎么用的?\"></a>Label的作用是什么？是怎么用的?</h3><p> label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;label <span class=\"keyword\">for</span>=<span class=\"string\">\"Name\"</span>&gt;<span class=\"built_in\">Number</span>:&lt;/label&gt;</span><br><span class=\"line\">&lt;input type=“text“name=<span class=\"string\">\"Name\"</span> id=<span class=\"string\">\"Name\"</span>/&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;label&gt;<span class=\"built_in\">Date</span>:&lt;input type=\"text\" name=\"B\"/&gt;&lt;/label&gt;</span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"HTML5的form如何关闭自动完成功能？\"><a href=\"#HTML5的form如何关闭自动完成功能？\" class=\"headerlink\" title=\"HTML5的form如何关闭自动完成功能？\"></a>HTML5的form如何关闭自动完成功能？</h3><p>  给不想要提示的 form 或某个 input 设置为 autocomplete=off。</p>\n<p><br></p>\n<h3 id=\"如何实现浏览器内多个标签页之间的通信\"><a href=\"#如何实现浏览器内多个标签页之间的通信\" class=\"headerlink\" title=\"如何实现浏览器内多个标签页之间的通信?\"></a>如何实现浏览器内多个标签页之间的通信?</h3><p>  WebSocket、SharedWorker；<br>  也可以调用localstorge、cookies等本地存储方式；</p>\n<p>  localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件，<br>  我们通过监听事件，控制它的值来进行页面信息通信；<br>  注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常；</p>\n<p><br></p>\n<h3 id=\"webSocket如何兼容低浏览器？\"><a href=\"#webSocket如何兼容低浏览器？\" class=\"headerlink\" title=\"webSocket如何兼容低浏览器？\"></a>webSocket如何兼容低浏览器？</h3><ul>\n<li>Adobe Flash Socket 、</li>\n<li>ActiveX HTMLFile (IE) 、</li>\n<li>基于 multipart 编码发送 XHR 、</li>\n<li>基于长轮询的 XHR</li>\n</ul>\n<p><br></p>\n<h3 id=\"页面可见性（Page-Visibility-API）-可以有哪些用途？\"><a href=\"#页面可见性（Page-Visibility-API）-可以有哪些用途？\" class=\"headerlink\" title=\"页面可见性（Page Visibility API） 可以有哪些用途？\"></a>页面可见性（Page Visibility API） 可以有哪些用途？</h3><p>  通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;<br>  在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；</p>\n<p><br></p>\n<h3 id=\"实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\"><a href=\"#实现不使用-border-画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\" class=\"headerlink\" title=\"实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。\"></a>实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div style=<span class=\"string\">\"height:1px;overflow:hidden;background:red\"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\"><a href=\"#介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\" class=\"headerlink\" title=\"介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？\"></a>介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？</h3><p>  （1）有两种， IE 盒子模型、W3C 盒子模型；<br>  （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；<br>  （3）区  别： IE的content部分把 border 和 padding计算了进去;</p>\n<p><br></p>\n<h3 id=\"CSS优先级算法如何计算？\"><a href=\"#CSS优先级算法如何计算？\" class=\"headerlink\" title=\"CSS优先级算法如何计算？\"></a>CSS优先级算法如何计算？</h3><ul>\n<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>\n<li><p>载入样式以最后载入的定位为准;</p>\n<p>优先级为:<br>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。<br>!important &gt;  id &gt; class &gt; tag<br>important 比 内联优先级高</p>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"CSS3新增伪类有那些？\"><a href=\"#CSS3新增伪类有那些？\" class=\"headerlink\" title=\"CSS3新增伪类有那些？\"></a>CSS3新增伪类有那些？</h3><pre><code>举例：\np:first-of-type    选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\np:last-of-type    选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\np:only-of-type    选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。\np:only-child        选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。\np:nth-child(2)    选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。\n\n:after            在元素之前添加内容,也可以用来做清除浮动。\n:before            在元素之后添加内容\n :enabled          \n:disabled         控制表单控件的禁用状态。\n:checked        单选框或复选框被选中。\n</code></pre><p><br></p>\n<h3 id=\"CSS3有哪些新特性？\"><a href=\"#CSS3有哪些新特性？\" class=\"headerlink\" title=\"CSS3有哪些新特性？\"></a>CSS3有哪些新特性？</h3><p> 新增各种CSS选择器    （: not(.input)：所有 class 不是“input”的节点）<br>      圆角            （border-radius:8px）<br>    多列布局        （multi-column layout）<br>    阴影和反射    （Shadow\\Reflect）<br>    文字特效        （text-shadow、）<br>    文字渲染        （Text-decoration）<br>    线性渐变        （gradient）<br>    旋转             （transform）<br>    缩放,定位,倾斜,动画,多背景<br>    例如:transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation:</p>\n<p><br></p>\n<h3 id=\"请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景\"><a href=\"#请解释一下CSS3的Flexbox（弹性盒布局模型）-以及适用场景\" class=\"headerlink\" title=\"请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景\"></a>请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景</h3><p>  一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。<br>   较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。<br>   采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。<br>   它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。<br>   常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。<br>   在布局上有了比以前更加灵活的空间。</p>\n<p><br></p>\n<h3 id=\"li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\"><a href=\"#li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\" class=\"headerlink\" title=\"li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？\"></a>li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？</h3><p> 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。</p>\n<p><br></p>\n<h3 id=\"对BFC规范-块级格式化上下文：block-formatting-context-的理解？\"><a href=\"#对BFC规范-块级格式化上下文：block-formatting-context-的理解？\" class=\"headerlink\" title=\"对BFC规范(块级格式化上下文：block formatting context)的理解？\"></a>对BFC规范(块级格式化上下文：block formatting context)的理解？</h3><p>（W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。）<br>   一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。<br>   不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。</p>\n<p><br></p>\n<h3 id=\"before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用\"><a href=\"#before-和-after中双冒号和单冒号-有什么区别？解释一下这2个伪元素的作用\" class=\"headerlink\" title=\"::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用\"></a>::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用</h3><p>单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成）<br>  双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法，<br>  比如:first-line、:first-letter、:before、:after等，<br>  而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。</p>\n<p>  想让插入的内容出现在其它内容前，使用::before，否者，使用::after；<br>  在代码顺序上，::after生成的内容也比::before生成的内容靠后。<br>  如果按堆栈视角，::after生成的内容会在::before生成的内容之上</p>\n<p><br></p>\n<h3 id=\"让页面里的字体变清晰，变细用CSS怎么做？\"><a href=\"#让页面里的字体变清晰，变细用CSS怎么做？\" class=\"headerlink\" title=\"让页面里的字体变清晰，变细用CSS怎么做？\"></a>让页面里的字体变清晰，变细用CSS怎么做？</h3><p>  -webkit-font-smoothing: antialiased;</p>\n<p><br></p>\n<h3 id=\"position-fixed-在android下无效怎么处理？\"><a href=\"#position-fixed-在android下无效怎么处理？\" class=\"headerlink\" title=\"position:fixed;在android下无效怎么处理？\"></a>position:fixed;在android下无效怎么处理？</h3><p>  fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport，<br>  原来的网页还好好的在那，fixed的内容也没有变过位置，<br>  所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。<br>  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no\"></p>\n<p><br></p>\n<h3 id=\"如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"><a href=\"#如果需要手动写动画，你认为最小时间间隔是多久，为什么？\" class=\"headerlink\" title=\"如果需要手动写动画，你认为最小时间间隔是多久，为什么？\"></a>如果需要手动写动画，你认为最小时间间隔是多久，为什么？</h3><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</p>\n<p>display:inline-block 什么时候会显示间隙？</p>\n<p>移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing</p>\n<p><br></p>\n<h3 id=\"什么是CSS-预处理器-后处理器？\"><a href=\"#什么是CSS-预处理器-后处理器？\" class=\"headerlink\" title=\"什么是CSS 预处理器 / 后处理器？\"></a>什么是CSS 预处理器 / 后处理器？</h3><ul>\n<li><p>预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性，<br> 还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。</p>\n<ul>\n<li>后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的<br>是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</li>\n</ul>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"JavaScript原型，原型链-有什么特点？\"><a href=\"#JavaScript原型，原型链-有什么特点？\" class=\"headerlink\" title=\"JavaScript原型，原型链 ? 有什么特点？\"></a>JavaScript原型，原型链 ? 有什么特点？</h3><p>每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时，<br> 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype，<br> 于是就这样一直找下去，也就是我们平时所说的原型链的概念。<br> 关系：instance.constructor.prototype = instance.<strong>proto</strong></p>\n<p> 特点：<br> JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。</p>\n<p><br></p>\n<h3 id=\"如何将字符串转化为数字，例如’12-3b’\"><a href=\"#如何将字符串转化为数字，例如’12-3b’\" class=\"headerlink\" title=\"如何将字符串转化为数字，例如’12.3b’?\"></a>如何将字符串转化为数字，例如’12.3b’?</h3><ul>\n<li>parseFloat(‘12.3b’);</li>\n<li>正则表达式，’12.3b’.match(/(\\d)+(.)?(\\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</li>\n</ul>\n<p><br></p>\n<h3 id=\"如何实现数组的随机排序？\"><a href=\"#如何实现数组的随机排序？\" class=\"headerlink\" title=\"如何实现数组的随机排序？\"></a>如何实现数组的随机排序？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>];</span><br><span class=\"line\">arr.sort(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">Math</span>.random() - <span class=\"number\">0.5</span>;</span><br><span class=\"line\"> <span class=\"comment\">// return Math.random() ;   从大到小</span></span><br><span class=\"line\"> <span class=\"comment\">// return Math.random() - 1;  从小到大</span></span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">sortNumber</span>(<span class=\"params\">a, b</span>)</span></span><br><span class=\"line\"><span class=\"function\"> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> a - b</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"keyword\">var</span> arr = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">6</span>)</span><br><span class=\"line\"> arr = [<span class=\"number\">6</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>,<span class=\"number\">3</span>,<span class=\"number\">12</span>,<span class=\"number\">1100</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"built_in\">document</span>.write(arr.sort(sortNumber))  <span class=\"comment\">// 实现数组又大到小排序</span></span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"Javascript如何实现继承？\"><a href=\"#Javascript如何实现继承？\" class=\"headerlink\" title=\"Javascript如何实现继承？\"></a>Javascript如何实现继承？</h3><p>1、构造继承<br> 2、原型继承<br> 3、实例继承<br> 4、拷贝继承</p>\n<p> 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。<br> <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Parent</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.name = <span class=\"string\">'wang'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.age = <span class=\"number\">28</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Parent();<span class=\"comment\">//继承了Parent，通过原型</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> demo = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\">alert(demo.age);</span><br><span class=\"line\">alert(demo.name);<span class=\"comment\">//得到被继承的属性</span></span><br></pre></td></tr></table></figure></p>\n<p><br></p>\n<h3 id=\"javascript创建对象的几种方式？\"><a href=\"#javascript创建对象的几种方式？\" class=\"headerlink\" title=\"javascript创建对象的几种方式？\"></a>javascript创建对象的几种方式？</h3><pre><code>1、对象字面量的方式\n2、用function来模拟无参的构造函数\n3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性）\n4 、用原型方式来创建\n</code></pre><p><br></p>\n<h3 id=\"Javascript作用链域\"><a href=\"#Javascript作用链域\" class=\"headerlink\" title=\"Javascript作用链域?\"></a>Javascript作用链域?</h3><p> 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。<br> 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找，<br> 直至全局函数，这种组织形式就是作用域链。</p>\n<p><br></p>\n<h3 id=\"eval是做什么的？\"><a href=\"#eval是做什么的？\" class=\"headerlink\" title=\"eval是做什么的？\"></a>eval是做什么的？</h3><p>它的功能是把对应的字符串解析成JS代码并运行；<br> 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。<br> 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(‘(‘+ str +’)’);</p>\n<p>什么是window对象? 什么是document对象?</p>\n<p> window对象是指浏览器打开的窗口。<br> document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</p>\n<p><br></p>\n<h3 id=\"“1”-“2”-“3”-map-parseInt-答案是多少？\"><a href=\"#“1”-“2”-“3”-map-parseInt-答案是多少？\" class=\"headerlink\" title=\"[“1”, “2”, “3”].map(parseInt) 答案是多少？\"></a>[“1”, “2”, “3”].map(parseInt) 答案是多少？</h3><p> parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)，<br> 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】;<br> 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。</p>\n<p> function parseInt(str, radix) {<br>     return str+’-‘+radix;<br> };<br> var a=[“1”, “2”, “3”];<br> a.map(parseInt);  // [“1-0”, “2-1”, “3-2”] 不能大于radix</p>\n<p> 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN<br> 所以[“1”, “2”, “3”].map(parseInt) 答案也就是：[1, NaN, NaN]</p>\n<p><br></p>\n<h3 id=\"什么是闭包（closure），为什么要用它？\"><a href=\"#什么是闭包（closure），为什么要用它？\" class=\"headerlink\" title=\"什么是闭包（closure），为什么要用它？\"></a>什么是闭包（closure），为什么要用它？</h3><p>  闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。</p>\n<p> 闭包的特性：</p>\n<p> 1.函数内再嵌套函数<br> 2.内部函数可以引用外层的参数和变量<br> 3.参数和变量不会被垃圾回收机制回收</p>\n<p><br></p>\n<h3 id=\"new操作符具体干了什么呢\"><a href=\"#new操作符具体干了什么呢\" class=\"headerlink\" title=\"new操作符具体干了什么呢?\"></a>new操作符具体干了什么呢?</h3><pre><code>1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。\n2、属性和方法被加入到 this 引用的对象中。\n3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。\n</code></pre><p><br></p>\n<h3 id=\"js延迟加载的方式有哪些？\"><a href=\"#js延迟加载的方式有哪些？\" class=\"headerlink\" title=\"js延迟加载的方式有哪些？\"></a>js延迟加载的方式有哪些？</h3><p> defer和async、动态创建DOM方式（用得最多）、按需异步载入js</p>\n<p><br></p>\n<h3 id=\"Ajax-是什么-如何创建一个Ajax？\"><a href=\"#Ajax-是什么-如何创建一个Ajax？\" class=\"headerlink\" title=\"Ajax 是什么? 如何创建一个Ajax？\"></a>Ajax 是什么? 如何创建一个Ajax？</h3><p>ajax的全称：Asynchronous Javascript And XML。<br> 异步传输+js+xml。<br> 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。</p>\n<p> (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象<br> (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息<br> (3)设置响应HTTP请求状态变化的函数<br> (4)发送HTTP请求<br> (5)获取异步调用返回的数据<br> (6)使用JavaScript和DOM实现局部刷新</p>\n<p><br></p>\n<h3 id=\"如何判断当前脚本运行在浏览器还是node环境中？\"><a href=\"#如何判断当前脚本运行在浏览器还是node环境中？\" class=\"headerlink\" title=\"如何判断当前脚本运行在浏览器还是node环境中？\"></a>如何判断当前脚本运行在浏览器还是node环境中？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">this</span> === <span class=\"built_in\">window</span> ? <span class=\"string\">'browser'</span> : <span class=\"string\">'node'</span>;</span><br></pre></td></tr></table></figure>\n<p>  通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中</p>\n<p><br></p>\n<h3 id=\"那些操作会造成内存泄漏？\"><a href=\"#那些操作会造成内存泄漏？\" class=\"headerlink\" title=\"那些操作会造成内存泄漏？\"></a>那些操作会造成内存泄漏？</h3><p> 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。<br> 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>\n<p> setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。<br> 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）</p>\n<p><br></p>\n<h3 id=\"检测浏览器版本版本有哪些方式？\"><a href=\"#检测浏览器版本版本有哪些方式？\" class=\"headerlink\" title=\"检测浏览器版本版本有哪些方式？\"></a>检测浏览器版本版本有哪些方式？</h3><p>  功能检测、userAgent特征检测</p>\n<p>  比如：navigator.userAgent</p>\n<p><br></p>\n<h3 id=\"Object-is-与原来的比较操作符“-”、“-”的区别？\"><a href=\"#Object-is-与原来的比较操作符“-”、“-”的区别？\" class=\"headerlink\" title=\"Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？\"></a>Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？</h3><p> 两等号判等，会在比较时进行类型转换；<br>  三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）；</p>\n<p>  Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同，<br>  但 Object.is(NaN, NaN) 会返回 true.</p>\n<p>   Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。<br>  前端框架相关</p>\n<p><br></p>\n<h3 id=\"是否了解公钥加密和私钥加密。\"><a href=\"#是否了解公钥加密和私钥加密。\" class=\"headerlink\" title=\"是否了解公钥加密和私钥加密。\"></a>是否了解公钥加密和私钥加密。</h3><p>  一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证;<br>  HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。</p>\n<p><br></p>\n<h3 id=\"对Node的优点和缺点提出了自己的看法？\"><a href=\"#对Node的优点和缺点提出了自己的看法？\" class=\"headerlink\" title=\"对Node的优点和缺点提出了自己的看法？\"></a>对Node的优点和缺点提出了自己的看法？</h3><pre><code>*（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，\n  因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。\n  此外，与Node代理服务器交互的客户端代码是由javascript语言编写的，\n  因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。\n\n*（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变，\n  而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。\n</code></pre><p><br></p>\n<h3 id=\"你有用过哪些前端性能优化的方法？\"><a href=\"#你有用过哪些前端性能优化的方法？\" class=\"headerlink\" title=\"你有用过哪些前端性能优化的方法？\"></a>你有用过哪些前端性能优化的方法？</h3><pre><code>（1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。\n\n（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数\n\n（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。\n\n（4） 当需要设置的样式很多时设置className而不是直接操作style。\n\n（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。\n\n（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。\n\n（7） 图片预加载，将样式表放在顶部，将脚本放在底部  加上时间戳。\n\n（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。\n对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。\n</code></pre><p><br></p>\n<h3 id=\"http状态码有那些？分别代表是什么意思？\"><a href=\"#http状态码有那些？分别代表是什么意思？\" class=\"headerlink\" title=\"http状态码有那些？分别代表是什么意思？\"></a>http状态码有那些？分别代表是什么意思？</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  [</span><br><span class=\"line\">      <span class=\"number\">100</span>  Continue    继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息</span><br><span class=\"line\">      <span class=\"number\">200</span>  OK         正常返回信息</span><br><span class=\"line\">      <span class=\"number\">201</span>  Created      请求成功并且服务器创建了新的资源</span><br><span class=\"line\">      <span class=\"number\">202</span>  Accepted     服务器已接受请求，但尚未处理</span><br><span class=\"line\">      <span class=\"number\">301</span>  Moved Permanently  请求的网页已永久移动到新位置。</span><br><span class=\"line\">      <span class=\"number\">302</span> Found          临时性重定向。</span><br><span class=\"line\">      <span class=\"number\">303</span> See Other      临时性重定向，且总是使用 GET 请求新的 URI。</span><br><span class=\"line\">      <span class=\"number\">304</span>  Not Modified 自从上次请求后，请求的网页未修改过。</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"number\">400</span> Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。</span><br><span class=\"line\">      <span class=\"number\">401</span> Unauthorized 请求未授权。</span><br><span class=\"line\">      <span class=\"number\">403</span> Forbidden      禁止访问。</span><br><span class=\"line\">      <span class=\"number\">404</span> Not Found      找不到如何与 URI 相匹配的资源。</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"number\">500</span> Internal Server <span class=\"built_in\">Error</span>  最常见的服务器端错误。</span><br><span class=\"line\">      <span class=\"number\">503</span> Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。</span><br><span class=\"line\">  ]</span><br><span class=\"line\"></span><br><span class=\"line\">完整版</span><br><span class=\"line\"><span class=\"number\">1</span>**(信息类)：表示接收到请求并且继续处理</span><br><span class=\"line\">  <span class=\"number\">100</span>——客户必须继续发出请求</span><br><span class=\"line\">  <span class=\"number\">101</span>——客户要求服务器根据请求转换HTTP协议版本</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>**(响应成功)：表示动作被成功接收、理解和接受</span><br><span class=\"line\">  <span class=\"number\">200</span>——表明该请求被成功地完成，所请求的资源发送回客户端</span><br><span class=\"line\">  <span class=\"number\">201</span>——提示知道新文件的URL</span><br><span class=\"line\">  <span class=\"number\">202</span>——接受和处理、但处理未完成</span><br><span class=\"line\">  <span class=\"number\">203</span>——返回信息不确定或不完整</span><br><span class=\"line\">  <span class=\"number\">204</span>——请求收到，但返回信息为空</span><br><span class=\"line\">  <span class=\"number\">205</span>——服务器完成了请求，用户代理必须复位当前已经浏览过的文件</span><br><span class=\"line\">  <span class=\"number\">206</span>——服务器已经完成了部分用户的GET请求</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>**(重定向类)：为了完成指定的动作，必须接受进一步处理</span><br><span class=\"line\">  <span class=\"number\">300</span>——请求的资源可在多处得到</span><br><span class=\"line\">  <span class=\"number\">301</span>——本网页被永久性转移到另一个URL</span><br><span class=\"line\">  <span class=\"number\">302</span>——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。</span><br><span class=\"line\">  <span class=\"number\">303</span>——建议客户访问其他URL或访问方式</span><br><span class=\"line\">  <span class=\"number\">304</span>——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用</span><br><span class=\"line\">  <span class=\"number\">305</span>——请求的资源必须从服务器指定的地址得到</span><br><span class=\"line\">  <span class=\"number\">306</span>——前一版本HTTP中使用的代码，现行版本中不再使用</span><br><span class=\"line\">  <span class=\"number\">307</span>——申明请求的资源临时性删除</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>**(客户端错误类)：请求包含错误语法或不能正确执行</span><br><span class=\"line\">  <span class=\"number\">400</span>——客户端请求有语法错误，不能被服务器所理解</span><br><span class=\"line\">  <span class=\"number\">401</span>——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</span><br><span class=\"line\">  HTTP <span class=\"number\">401.1</span> - 未授权：登录失败</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.2</span> - 未授权：服务器配置问题导致登录失败</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.3</span> - ACL 禁止访问资源</span><br><span class=\"line\">  　　HTTP <span class=\"number\">401.4</span> - 未授权：授权被筛选器拒绝</span><br><span class=\"line\">  HTTP <span class=\"number\">401.5</span> - 未授权：ISAPI 或 CGI 授权失败</span><br><span class=\"line\">  <span class=\"number\">402</span>——保留有效ChargeTo头响应</span><br><span class=\"line\">  <span class=\"number\">403</span>——禁止访问，服务器收到请求，但是拒绝提供服务</span><br><span class=\"line\">  HTTP <span class=\"number\">403.1</span> 禁止访问：禁止可执行访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.2</span> - 禁止访问：禁止读访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.3</span> - 禁止访问：禁止写访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.4</span> - 禁止访问：要求 SSL</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.5</span> - 禁止访问：要求 SSL <span class=\"number\">128</span></span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.6</span> - 禁止访问：IP 地址被拒绝</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.7</span> - 禁止访问：要求客户证书</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.8</span> - 禁止访问：禁止站点访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.9</span> - 禁止访问：连接的用户过多</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.10</span> - 禁止访问：配置无效</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.11</span> - 禁止访问：密码更改</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.12</span> - 禁止访问：映射器拒绝访问</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.13</span> - 禁止访问：客户证书已被吊销</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.15</span> - 禁止访问：客户访问许可过多</span><br><span class=\"line\">  　　HTTP <span class=\"number\">403.16</span> - 禁止访问：客户证书不可信或者无效</span><br><span class=\"line\">  HTTP <span class=\"number\">403.17</span> - 禁止访问：客户证书已经到期或者尚未生效</span><br><span class=\"line\">  <span class=\"number\">404</span>——一个<span class=\"number\">404</span>错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL</span><br><span class=\"line\">  <span class=\"number\">405</span>——用户在Request-Line字段定义的方法不允许</span><br><span class=\"line\">  <span class=\"number\">406</span>——根据用户发送的Accept拖，请求资源不可访问</span><br><span class=\"line\">  <span class=\"number\">407</span>——类似<span class=\"number\">401</span>，用户必须首先在代理服务器上得到授权</span><br><span class=\"line\">  <span class=\"number\">408</span>——客户端没有在用户指定的饿时间内完成请求</span><br><span class=\"line\">  <span class=\"number\">409</span>——对当前资源状态，请求不能完成</span><br><span class=\"line\">  <span class=\"number\">410</span>——服务器上不再有此资源且无进一步的参考地址</span><br><span class=\"line\">  <span class=\"number\">411</span>——服务器拒绝用户定义的Content-Length属性请求</span><br><span class=\"line\">  <span class=\"number\">412</span>——一个或多个请求头字段在当前请求中错误</span><br><span class=\"line\">  <span class=\"number\">413</span>——请求的资源大于服务器允许的大小</span><br><span class=\"line\">  <span class=\"number\">414</span>——请求的资源URL长于服务器允许的长度</span><br><span class=\"line\">  <span class=\"number\">415</span>——请求资源不支持请求项目格式</span><br><span class=\"line\">  <span class=\"number\">416</span>——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段</span><br><span class=\"line\">  <span class=\"number\">417</span>——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5</span>**(服务端错误类)：服务器不能正确执行一个正确的请求</span><br><span class=\"line\">  HTTP <span class=\"number\">500</span> - 服务器遇到错误，无法完成请求</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500.100</span> - 内部服务器错误 - ASP 错误</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-11</span> 服务器关闭</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-12</span> 应用程序重新启动</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-13</span> - 服务器太忙</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-14</span> - 应用程序无效</span><br><span class=\"line\">  　　HTTP <span class=\"number\">500</span><span class=\"number\">-15</span> - 不允许请求 global.asa</span><br><span class=\"line\">  　　<span class=\"built_in\">Error</span> <span class=\"number\">501</span> - 未实现</span><br><span class=\"line\">HTTP <span class=\"number\">502</span> - 网关错误</span><br><span class=\"line\">HTTP <span class=\"number\">503</span>：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\"><a href=\"#一个页面从输入-URL-到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\" class=\"headerlink\" title=\"一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）\"></a>一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">详细版：</span><br><span class=\"line\">  <span class=\"number\">1</span>、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理;</span><br><span class=\"line\">  <span class=\"number\">2</span>、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法;</span><br><span class=\"line\">  <span class=\"number\">3</span>、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求;</span><br><span class=\"line\">  <span class=\"number\">4</span>、进行HTTP协议会话，客户端发送报头(请求报头);</span><br><span class=\"line\">  <span class=\"number\">5</span>、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器;</span><br><span class=\"line\">  <span class=\"number\">6</span>、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理;</span><br><span class=\"line\">  <span class=\"number\">7</span>、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回<span class=\"number\">304</span>;</span><br><span class=\"line\">  <span class=\"number\">8</span>、浏览器开始下载html文档(响应报头，状态码<span class=\"number\">200</span>)，同时使用缓存;</span><br><span class=\"line\">  <span class=\"number\">9</span>、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie;</span><br><span class=\"line\">  <span class=\"number\">10</span>、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。</span><br><span class=\"line\"></span><br><span class=\"line\">简洁版：</span><br><span class=\"line\">  浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求；</span><br><span class=\"line\">  服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）；</span><br><span class=\"line\">  浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）；</span><br><span class=\"line\">  载入解析到的资源文件，渲染页面，完成。</span><br></pre></td></tr></table></figure>\n<p><br></p>\n<h3 id=\"移动端（Android-IOS）怎么做好用户体验\"><a href=\"#移动端（Android-IOS）怎么做好用户体验\" class=\"headerlink\" title=\"移动端（Android IOS）怎么做好用户体验?\"></a>移动端（Android IOS）怎么做好用户体验?</h3><p>  清晰的视觉纵线、<br>  信息的分组、极致的减法、<br>  利用选择代替输入、<br>  标签及文字的排布方式、<br>  依靠明文确认密码、<br>  合理的键盘利用、</p>\n<h3 id=\"TCP传输的三次握手四次挥手策略\"><a href=\"#TCP传输的三次握手四次挥手策略\" class=\"headerlink\" title=\"TCP传输的三次握手四次挥手策略\"></a>TCP传输的三次握手四次挥手策略</h3><p>第一次握手，客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。</p>\n<p>第二次握手，服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。</p>\n<p>第三次握手，客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。 客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。</p>\n<ul>\n<li><p>为什么要三次握手：<br>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源<br>TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！</p>\n</li>\n<li><p>四次挥手</p>\n</li>\n</ul>\n<p>1、主机向服务器发送一个断开连接的请求（ 不早了，我该走了 ）,发送一个FIN报文段；<br>2、服务器接到请求后发送确认收到请求的信号（ 知道了 ）回一个ACK报文段；<br>3、服务器向主机发送断开通知（ 我也该走了 ）发送FIN报文段，请求关闭连接；<br>4、主机接到断开通知后断开连接并反馈一个确认信号（ 嗯，好的 ），服务器收到确认信号后也断开连接；</p>\n<h3 id=\"TCP和UDP的区别\"><a href=\"#TCP和UDP的区别\" class=\"headerlink\" title=\"TCP和UDP的区别\"></a>TCP和UDP的区别</h3><p>TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来</p>\n<p>UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！<br>UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。</p>\n<h3 id=\"HTTP和HTTPS\"><a href=\"#HTTP和HTTPS\" class=\"headerlink\" title=\"HTTP和HTTPS\"></a>HTTP和HTTPS</h3><p>1、HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS<br>2、默认HTTP的端口号为80，HTTPS的端口号为443</p>\n<p>HTTPS 相对于 HTTP 性能上差点，因为多了 SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。</p>\n<h3 id=\"什么是Etag\"><a href=\"#什么是Etag\" class=\"headerlink\" title=\"什么是Etag\"></a>什么是Etag</h3><p>把Last-Modified和ETag请求的http报头一起使用，可利用客户端（例如浏览器）的缓存。ETag用于标识资源的状态，当资源发生变更时，如果其头信息中一个或者多个发生变化，或者消息实体发生变化，那么ETag也随之发生变化。浏览器下载组件的时候，会将它们存储到浏览器缓存中。如果需要再次获取相同的组件，浏览器将检查组件的缓存时间，<br>假如已经过期，那么浏览器将发送一个条件GET请求到服务器，服务器判断缓存还有效，则发送一个304响应，告诉浏览器可以重用缓存组件。</p>\n<h3 id=\"浏览器的渲染过程\"><a href=\"#浏览器的渲染过程\" class=\"headerlink\" title=\"浏览器的渲染过程\"></a>浏览器的渲染过程</h3><p>1、浏览器请求到HTML代码后，在生成DOM的最开始阶段，并行发起css、图片、js的请求，无论他们是否在HEAD里。浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。<br>2、CSS文件下载完成，开始构建CSSOM<br>3、所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。<br>4、有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作就是计算出每个节点在屏幕中的位置。<br>5、最后一步，按照算出来的规则，把内容渲染到屏幕上。</p>\n<p>以上五个步骤前3个步骤因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。</p>\n<h3 id=\"一个完整的URL包括以下几部分\"><a href=\"#一个完整的URL包括以下几部分\" class=\"headerlink\" title=\"一个完整的URL包括以下几部分\"></a>一个完整的URL包括以下几部分</h3><p>1、协议部分<br>2、域名部分<br>3、端口部分<br>4、虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止<br>5、文件名部分：从域名后的最后一个“/”开始到“？”为止<br>6、参数部分：从“？”开始到“#”为止之间的部分<br>7、锚部分：从“#”开始到最后</p>\n<h3 id=\"GET和POST的区别\"><a href=\"#GET和POST的区别\" class=\"headerlink\" title=\"GET和POST的区别\"></a>GET和POST的区别</h3><p>GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在1024字节，Get是通过地址栏来传值。</p>\n<p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。（常用于发送表单数据，新建、修改等），Post是通过提交表单来传值。</p>\n<h3 id=\"说说网络分层里七层模型是哪七层\"><a href=\"#说说网络分层里七层模型是哪七层\" class=\"headerlink\" title=\"说说网络分层里七层模型是哪七层\"></a>说说网络分层里七层模型是哪七层</h3><p>应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS）</p>\n<p>传输层（TCP和UDP）</p>\n<p>网络层（IP）</p>\n<p>物理和数据链路层（以太网）</p>\n<h3 id=\"讲讲304缓存的原理\"><a href=\"#讲讲304缓存的原理\" class=\"headerlink\" title=\"讲讲304缓存的原理\"></a>讲讲304缓存的原理</h3><p>服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。</p>\n<p>304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件</p>\n<h3 id=\"http-keep-alive与tcp-keep-alive\"><a href=\"#http-keep-alive与tcp-keep-alive\" class=\"headerlink\" title=\"http keep-alive与tcp keep-alive\"></a>http keep-alive与tcp keep-alive</h3><p>http keep-alive是为了让tcp活得更久一点，以便在同一个连接上传送多个http，提高socket的效率。而tcp keep-alive是TCP的一种检测TCP连接状况的保鲜机制。</p>\n<h3 id=\"常见web安全及防护原理\"><a href=\"#常见web安全及防护原理\" class=\"headerlink\" title=\"常见web安全及防护原理\"></a>常见web安全及防护原理</h3><ul>\n<li>sql注入原理<br>就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。</li>\n<li>XSS<br>指的是攻击者往Web页面里插入恶意html标签或者javascript代码。比如：攻击者在论坛中放一个看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单，当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。</li>\n<li>CSRF<br>CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。要完成一次CSRF攻击，受害者必须依次完成两个步骤：1、登录受信任网站A，并在本地生成Cookie。2、在不登出A的情况下，访问危险网站B。</li>\n</ul>\n<h3 id=\"对重构的理解\"><a href=\"#对重构的理解\" class=\"headerlink\" title=\"对重构的理解\"></a>对重构的理解</h3><p>在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。</p>\n<p>减少代码间的耦合<br>让代码保持弹性<br>严格按规范编写代码<br>设计可扩展的API<br>代替旧有的框架、语言(如VB)<br>增强用户体验<br>通常来说对于速度的优化也包含在重构中</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjvuo4ac60001gvk97dc6vgwj","category_id":"cjvuo4aca0003gvk9rhdrmfkg","_id":"cjvuo4aco000dgvk95frb02af"},{"post_id":"cjvuo4ac80002gvk9xzg78d0t","category_id":"cjvuo4aci0008gvk9aj2710zo","_id":"cjvuo4acq000igvk9zrker3xl"},{"post_id":"cjvuo4acc0005gvk9uxc26qp9","category_id":"cjvuo4aco000egvk9v4puk7n3","_id":"cjvuo4acs000ngvk9md449vgy"},{"post_id":"cjvuo4ace0006gvk9xunai8eq","category_id":"cjvuo4aco000egvk9v4puk7n3","_id":"cjvuo4act000qgvk9w84okfw9"},{"post_id":"cjvuo4acg0007gvk9667kz5iu","category_id":"cjvuo4acs000mgvk9l25o8x6d","_id":"cjvuo4act000ugvk98qjw3re8"},{"post_id":"cjvuo4ack000bgvk9x52jm5u7","category_id":"cjvuo4act000rgvk9eb08bu0p","_id":"cjvuo4acu000ygvk9d95occvp"},{"post_id":"cjvuo4acn000cgvk9z86q1z30","category_id":"cjvuo4act000vgvk9wgnd25aw","_id":"cjvuo4acu0012gvk9lnyoe77u"},{"post_id":"cjvuo4acp000ggvk9etu7y170","category_id":"cjvuo4acu000zgvk9d7ujrzrw","_id":"cjvuo4acw0014gvk9bb0cpse4"},{"post_id":"cjvuo4ai00015gvk9607xs91m","category_id":"cjvuo4acu000zgvk9d7ujrzrw","_id":"cjvuo4ai10017gvk9q535ehu6"},{"post_id":"cjvuo4aia0019gvk921rab0ge","category_id":"cjvuo4aib001agvk9mz02b8cl","_id":"cjvuo4aib001dgvk9v263p3y7"},{"post_id":"cjvuo4akn001egvk9rw458ux7","category_id":"cjvuo4aca0003gvk9rhdrmfkg","_id":"cjvuo4ako001ggvk9ihdzvrdi"}],"PostTag":[{"post_id":"cjvuo4ac60001gvk97dc6vgwj","tag_id":"cjvuo4acc0004gvk9vvk2f2wh","_id":"cjvuo4ack000agvk937pyr8ac"},{"post_id":"cjvuo4ac80002gvk9xzg78d0t","tag_id":"cjvuo4acj0009gvk9ttkl29qx","_id":"cjvuo4acp000hgvk9jsu57o7b"},{"post_id":"cjvuo4acc0005gvk9uxc26qp9","tag_id":"cjvuo4aco000fgvk9vnuihqdk","_id":"cjvuo4acr000lgvk96qjr12v2"},{"post_id":"cjvuo4ace0006gvk9xunai8eq","tag_id":"cjvuo4aco000fgvk9vnuihqdk","_id":"cjvuo4acs000pgvk90bvpi2yu"},{"post_id":"cjvuo4acg0007gvk9667kz5iu","tag_id":"cjvuo4acs000ogvk97na3fro7","_id":"cjvuo4act000tgvk91ubeoc25"},{"post_id":"cjvuo4ack000bgvk9x52jm5u7","tag_id":"cjvuo4act000sgvk9fgh3be49","_id":"cjvuo4acu000xgvk9dbuww1m5"},{"post_id":"cjvuo4acn000cgvk9z86q1z30","tag_id":"cjvuo4act000wgvk9hdmg1wl5","_id":"cjvuo4acu0011gvk90oq8eo7w"},{"post_id":"cjvuo4acp000ggvk9etu7y170","tag_id":"cjvuo4acu0010gvk94sq7k8th","_id":"cjvuo4acv0013gvk93nahdb1h"},{"post_id":"cjvuo4ai00015gvk9607xs91m","tag_id":"cjvuo4ai00016gvk94dqosrxn","_id":"cjvuo4ai10018gvk9r5t6ophx"},{"post_id":"cjvuo4aia0019gvk921rab0ge","tag_id":"cjvuo4aib001bgvk9xh1jplqb","_id":"cjvuo4aib001cgvk93lrsd9p5"},{"post_id":"cjvuo4akn001egvk9rw458ux7","tag_id":"cjvuo4acc0004gvk9vvk2f2wh","_id":"cjvuo4ako001fgvk91uumr2if"}],"Tag":[{"name":"interview","_id":"cjvuo4acc0004gvk9vvk2f2wh"},{"name":"docker","_id":"cjvuo4acj0009gvk9ttkl29qx"},{"name":"test","_id":"cjvuo4aco000fgvk9vnuihqdk"},{"name":"js","_id":"cjvuo4acs000ogvk97na3fro7"},{"name":"css","_id":"cjvuo4act000sgvk9fgh3be49"},{"name":"JS","_id":"cjvuo4act000wgvk9hdmg1wl5"},{"name":"vue","_id":"cjvuo4acu0010gvk94sq7k8th"},{"name":"vuex","_id":"cjvuo4ai00016gvk94dqosrxn"},{"name":"http","_id":"cjvuo4aib001bgvk9xh1jplqb"}]}}